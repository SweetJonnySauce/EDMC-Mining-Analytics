diff --git a/debugging.py b/debugging.py
deleted file mode 100644
index 8d3c59e..0000000
--- a/debugging.py
+++ /dev/null
@@ -1,131 +0,0 @@
-from __future__ import annotations
-
-import tkinter as tk
-from typing import Iterable
-
-DEBUG_BORDER_COLOR = "#ff8800"
-DEBUG_CELL_COLOR = "#4a90e2"
-DEBUG_EMPTY_CELL_COLOR = "#00b894"
-
-def collect_frames(root: tk.Widget, include_root: bool = True) -> list[tk.Frame]:
-    frames: list[tk.Frame] = []
-    if include_root and isinstance(root, tk.Frame):
-        frames.append(root)
-    for child in root.winfo_children():
-        frames.extend(collect_frames(child, include_root=True))
-    return frames
-
-def apply_frame_debugging(frames: Iterable[tk.Frame]) -> None:
-    for frame in frames:
-        try:
-            frame.configure(
-                highlightbackground=DEBUG_BORDER_COLOR,
-                highlightcolor=DEBUG_BORDER_COLOR,
-                highlightthickness=max(int(frame.cget("highlightthickness") or 0), 1),
-                bd=max(int(frame.cget("bd") or 0), 1),
-                relief=tk.SOLID,
-            )
-        except tk.TclError:
-            continue
-        for child in frame.winfo_children():
-            info = child.grid_info()
-            if not info:
-                continue
-            try:
-                child.configure(
-                    highlightbackground=DEBUG_CELL_COLOR,
-                    highlightcolor=DEBUG_CELL_COLOR,
-                    highlightthickness=max(int(child.cget("highlightthickness") or 0), 1),
-                )
-            except tk.TclError:
-                continue
-        _install_grid_overlays(frame)
-
-
-def _install_grid_overlays(frame: tk.Frame) -> None:
-    if getattr(frame, "_debug_overlays_bound", False):
-        _refresh_grid_overlays(frame)
-        return
-
-    def _on_configure(event: tk.Event) -> None:
-        widget = event.widget
-        if isinstance(widget, tk.Frame):
-            _refresh_grid_overlays(widget)
-
-    try:
-        frame.bind("<Configure>", _on_configure, add="+")
-        frame._debug_overlays_bound = True  # type: ignore[attr-defined]
-    except tk.TclError:
-        return
-    frame.after_idle(lambda fr=frame: _refresh_grid_overlays(fr))
-
-
-def _refresh_grid_overlays(frame: tk.Frame) -> None:
-    overlays: list[tk.Widget] = getattr(frame, "_debug_overlays", [])
-    for overlay in overlays:
-        try:
-            overlay.destroy()
-        except tk.TclError:
-            pass
-    frame._debug_overlays = []  # type: ignore[attr-defined]
-
-    try:
-        cols, rows = frame.grid_size()
-    except tk.TclError:
-        return
-
-    if cols <= 0 or rows <= 0:
-        return
-
-    occupied = _collect_occupied_cells(frame)
-    new_overlays: list[tk.Widget] = []
-    for row in range(rows):
-        for col in range(cols):
-            if (row, col) in occupied:
-                continue
-            try:
-                x, y, width, height = frame.grid_bbox(col, row)
-            except tk.TclError:
-                continue
-            if width <= 0 or height <= 0:
-                continue
-            overlay = tk.Frame(frame)
-            try:
-                background = frame.cget("background")
-                overlay.configure(background=background)
-            except tk.TclError:
-                pass
-            try:
-                overlay.configure(
-                    highlightbackground=DEBUG_EMPTY_CELL_COLOR,
-                    highlightcolor=DEBUG_EMPTY_CELL_COLOR,
-                    highlightthickness=1,
-                    bd=0,
-                )
-            except tk.TclError:
-                continue
-            overlay.place(x=x, y=y, width=width, height=height)
-            new_overlays.append(overlay)
-
-    frame._debug_overlays = new_overlays  # type: ignore[attr-defined]
-
-
-def _collect_occupied_cells(frame: tk.Frame) -> set[tuple[int, int]]:
-    occupied: set[tuple[int, int]] = set()
-    try:
-        slaves = frame.grid_slaves()
-    except tk.TclError:
-        return occupied
-
-    for child in slaves:
-        info = child.grid_info()
-        if not info:
-            continue
-        row = int(info.get("row", 0))
-        column = int(info.get("column", 0))
-        rowspan = int(info.get("rowspan", 1))
-        columnspan = int(info.get("columnspan", 1))
-        for r in range(row, row + rowspan):
-            for c in range(column, column + columnspan):
-                occupied.add((r, c))
-    return occupied
diff --git a/edmc_mining_analytics_version.py b/edmc_mining_analytics_version.py
deleted file mode 100644
index 05f439d..0000000
--- a/edmc_mining_analytics_version.py
+++ /dev/null
@@ -1,47 +0,0 @@
-"""Local loader for this plugin's version metadata.
-
-This avoids clashes with other EDMC plugins that also expose a top-level
-``version`` module by loading the metadata from this directory explicitly.
-"""
-
-from __future__ import annotations
-
-import importlib.util
-from pathlib import Path
-from types import ModuleType
-from typing import Tuple
-
-
-def _load_version_module() -> ModuleType:
-    """Load ``version.py`` from the current plugin directory explicitly."""
-
-    version_path = Path(__file__).resolve().with_name("version.py")
-    spec = importlib.util.spec_from_file_location(
-        "_edmc_mining_analytics_version", version_path
-    )
-    if spec is None or spec.loader is None:
-        raise ImportError(f"Unable to load version metadata from {version_path}")
-
-    module = importlib.util.module_from_spec(spec)
-    spec.loader.exec_module(module)
-    return module
-
-
-_version = _load_version_module()
-
-
-PLUGIN_VERSION: str = _version.PLUGIN_VERSION
-PLUGIN_REPO_URL: str = _version.PLUGIN_REPO_URL
-
-display_version = _version.display_version
-normalize_version = _version.normalize_version
-is_newer_version = _version.is_newer_version
-
-
-__all__ = [
-    "PLUGIN_VERSION",
-    "PLUGIN_REPO_URL",
-    "display_version",
-    "normalize_version",
-    "is_newer_version",
-]
diff --git a/http_client.py b/http_client.py
deleted file mode 100644
index dfeb2b1..0000000
--- a/http_client.py
+++ /dev/null
@@ -1,60 +0,0 @@
-"""Shared HTTP helpers using EDMC's timeout_session."""
-
-from __future__ import annotations
-
-from typing import Optional
-
-import requests
-
-from edmc_mining_analytics_version import PLUGIN_VERSION
-
-try:  # pragma: no cover - only available inside EDMC
-    from timeout_session import new_session  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    new_session = None  # type: ignore[assignment]
-
-try:  # pragma: no cover - only available inside EDMC
-    from config import config  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    config = None  # type: ignore[assignment]
-
-_SESSION: Optional[requests.Session] = None
-_PLUGIN_AGENT = f"EDMC-Mining-Analytics/{PLUGIN_VERSION}"
-
-
-def _build_user_agent(existing: Optional[str]) -> str:
-    base = existing or ""
-    candidate = base.strip()
-    if candidate and _PLUGIN_AGENT in candidate:
-        return candidate
-    if candidate:
-        return f"{candidate} {_PLUGIN_AGENT}"
-
-    config_agent = None
-    if config is not None:
-        try:
-            config_agent = getattr(config, "user_agent", None)
-        except Exception:
-            config_agent = None
-
-    if config_agent:
-        return f"{config_agent} {_PLUGIN_AGENT}"
-
-    return _PLUGIN_AGENT
-
-
-def get_shared_session() -> requests.Session:
-    """Return the shared requests session configured with EDMC defaults."""
-
-    global _SESSION
-    if _SESSION is None:
-        if new_session is not None:
-            session = new_session()
-        else:  # pragma: no cover - fallback for tests
-            session = requests.Session()
-        session.headers["User-Agent"] = _build_user_agent(session.headers.get("User-Agent"))
-        _SESSION = session
-    return _SESSION
-
-
-__all__ = ["get_shared_session"]
diff --git a/integrations/__init__.py b/integrations/__init__.py
deleted file mode 100644
index c9f8970..0000000
--- a/integrations/__init__.py
+++ /dev/null
@@ -1,10 +0,0 @@
-"""Integration helpers for EDMC Mining Analytics."""
-
-from .discord_summary import build_summary_message, build_test_message, send_webhook, format_duration
-
-__all__ = [
-    "build_summary_message",
-    "build_test_message",
-    "send_webhook",
-    "format_duration",
-]
diff --git a/integrations/discord_image_manager.py b/integrations/discord_image_manager.py
deleted file mode 100644
index 15c96c2..0000000
--- a/integrations/discord_image_manager.py
+++ /dev/null
@@ -1,120 +0,0 @@
-"""Helpers for managing Discord embed images."""
-
-from __future__ import annotations
-
-from typing import Iterable, List, Optional, Sequence
-
-from state import MiningState
-
-
-class DiscordImageManager:
-    """Manage Discord image configuration stored on :class:`MiningState`."""
-
-    _ANY_KEY = "__any__"
-
-    def __init__(self, state: MiningState) -> None:
-        self._state = state
-        if getattr(state, "discord_images", None) is None:
-            state.discord_images = []
-        if getattr(state, "discord_image_cycle", None) is None:
-            state.discord_image_cycle = {}
-
-    # ------------------------------------------------------------------ #
-    # Queries
-    # ------------------------------------------------------------------ #
-    def list_images(self) -> List[tuple[str, str]]:
-        """Return a copy of the configured ship/image pairs."""
-
-        images = getattr(self._state, "discord_images", []) or []
-        return [(ship or "", url) for ship, url in images if url]
-
-    def select_image(self, ship_name: Optional[str]) -> Optional[str]:
-        """Return the image URL for the given ship, rotating through matches."""
-
-        entries = self.list_images()
-        if not entries:
-            return None
-
-        ship = (ship_name or "").strip().lower()
-        if not ship:
-            ship = (self._state.current_ship or "").strip().lower()
-
-        matches: List[str] = []
-        any_matches: List[str] = []
-
-        for raw_ship, raw_url in entries:
-            url = raw_url.strip()
-            if not url:
-                continue
-            ship_value = raw_ship.strip()
-            if ship_value and ship_value.lower() != "any":
-                if ship_value.lower() == ship:
-                    matches.append(url)
-            else:
-                any_matches.append(url)
-
-        image = self._cycle_choice(matches, ship if ship else self._ANY_KEY)
-        if image:
-            return image
-        return self._cycle_choice(any_matches, self._ANY_KEY)
-
-    # ------------------------------------------------------------------ #
-    # Mutators
-    # ------------------------------------------------------------------ #
-    def add_image(self, ship: str, url: str) -> None:
-        """Add a ship/image mapping and reset its rotation."""
-
-        ship_value = ship.strip()
-        if ship_value.lower() == "any":
-            ship_value = ""
-        url_value = url.strip()
-        if not url_value:
-            return
-
-        images = getattr(self._state, "discord_images", [])
-        images.append((ship_value, url_value))
-        self._reset_cycle_for_keys((ship_value,))
-
-    def remove_indices(self, indices: Iterable[int]) -> None:
-        """Remove image entries at the given indices."""
-
-        targets: List[int] = sorted(set(idx for idx in indices if isinstance(idx, int)), reverse=True)
-        if not targets:
-            return
-
-        images = getattr(self._state, "discord_images", [])
-        removed: List[str] = []
-        for idx in targets:
-            if 0 <= idx < len(images):
-                ship_value, _ = images.pop(idx)
-                ship_value = ship_value.strip()
-                removed.append(ship_value if ship_value else "")
-        self._reset_cycle_for_keys(removed)
-
-    # ------------------------------------------------------------------ #
-    # Internals
-    # ------------------------------------------------------------------ #
-    def _cycle_choice(self, urls: Sequence[str], key: str) -> Optional[str]:
-        if not urls:
-            return None
-        cycle = getattr(self._state, "discord_image_cycle", None)
-        if cycle is None:
-            cycle = self._state.discord_image_cycle = {}
-        idx = cycle.get(key, 0)
-        selection = urls[idx % len(urls)]
-        cycle[key] = (idx + 1) % len(urls)
-        return selection
-
-    def _reset_cycle_for_keys(self, ships: Iterable[str]) -> None:
-        cycle = getattr(self._state, "discord_image_cycle", None)
-        if cycle is None:
-            cycle = self._state.discord_image_cycle = {}
-        keys = set()
-        for ship in ships:
-            ship_value = (ship or "").strip()
-            key = ship_value.lower() if ship_value and ship_value.lower() != "any" else self._ANY_KEY
-            keys.add(key)
-
-        images = getattr(self._state, "discord_images", [])
-        for key in keys:
-            cycle.pop(key, None)
diff --git a/integrations/discord_summary.py b/integrations/discord_summary.py
deleted file mode 100644
index 452acc3..0000000
--- a/integrations/discord_summary.py
+++ /dev/null
@@ -1,370 +0,0 @@
-"""Discord integration helpers for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-from collections import Counter
-from datetime import datetime, timezone
-from pathlib import Path
-from typing import Any, Dict, Iterable, List, Optional, Tuple
-
-import requests
-
-from http_client import get_shared_session
-from state import MiningState, resolve_commodity_display_name
-from .discord_image_manager import DiscordImageManager
-
-EMBED_COLOR = 0x1d9bf0
-TEST_COLOR = 0x95a5a6
-
-
-def send_webhook(webhook_url: str, payload: Dict[str, Any]) -> Tuple[bool, str]:
-    """Send a JSON payload to the provided Discord webhook URL."""
-
-    if not webhook_url:
-        return False, "Webhook URL is empty"
-    if not payload:
-        return False, "No payload to send"
-
-    session = get_shared_session()
-    try:
-        response = session.post(webhook_url, json=payload, timeout=5)
-    except requests.RequestException as exc:
-        return False, str(exc)
-
-    if 200 <= response.status_code < 300:
-        return True, ""
-    return False, f"HTTP {response.status_code}: {response.reason}"
-
-
-def build_summary_message(
-    state: MiningState,
-    payload: Dict[str, Any],
-    json_path: Optional[Path] = None,
-) -> Dict[str, Any]:
-    """Construct a Discord embed summarising the mining session."""
-
-    meta = payload.get("meta", {})
-    commodities = payload.get("commodities", {})
-
-    commander = meta.get("commander") or state.cmdr_name or "Unknown"
-    ship = meta.get("ship") or state.current_ship or "Unknown ship"
-
-    location_info = meta.get("location", {})
-    body = location_info.get("body") or state.mining_location or "Unknown body"
-    system = location_info.get("system") or state.current_system or "Unknown system"
-    ring = meta.get("ring") or state.mining_ring
-
-    base_location = None
-    if body and body.strip():
-        base_location = body.strip()
-    elif system and system.strip():
-        base_location = system.strip()
-    else:
-        base_location = "Unknown"
-
-    ring_suffix = _format_ring_info(
-        location_info.get("reserve_level") or meta.get("reserve_level") or state.edsm_reserve_level,
-        location_info.get("ring_type") or meta.get("ring_type") or state.edsm_ring_type,
-    )
-    if ring_suffix:
-        location_value = f"{base_location} ({ring_suffix})"
-    else:
-        location_value = base_location
-
-    fields: List[Dict[str, Any]] = [
-        {
-            "name": "Location",
-            "value": location_value,
-            "inline": False,
-        }
-    ]
-
-    if ring and ring.strip():
-        fields.append({"name": "Ring", "value": ring.strip(), "inline": False})
-
-    overall = meta.get("overall_tph", {})
-    duration_seconds = _safe_float(meta.get("duration_seconds")) or 0.0
-    duration_text = format_duration(duration_seconds)
-    total_tons = _safe_float(overall.get("tons"))
-    total_text = f"{total_tons:.1f}t" if total_tons is not None else "-"
-    tph_value = _safe_float(overall.get("tons_per_hour"))
-    tph_text = f"{tph_value:.1f}" if tph_value is not None else "-"
-    session_lines = [
-        f"Duration: {duration_text}",
-        f"Total: {total_text} @ {tph_text} TPH",
-    ]
-    fields.append({"name": "Session", "value": "\n".join(session_lines), "inline": False})
-
-    inventory = _safe_float(meta.get("inventory_tonnage"))
-    capacity = _safe_float(meta.get("cargo_capacity"))
-    cargo_lines: List[str] = []
-    if inventory is not None or capacity is not None:
-        inv_text = f"{inventory:.0f}t" if inventory is not None else "-"
-        cap_text = f"{capacity:.0f}t" if capacity is not None else "-"
-        if capacity and capacity > 0 and inventory is not None:
-            percent = (inventory / capacity) * 100.0
-            cargo_lines.append(f"Cargo: {inv_text} / {cap_text} ({percent:.1f}%)")
-        else:
-            cargo_lines.append(f"Cargo: {inv_text} / {cap_text}")
-    limpet_remaining = _safe_int(meta.get("limpets_remaining"))
-    if limpet_remaining is not None:
-        cargo_lines.append(f"Limpets remaining: {limpet_remaining}")
-    if cargo_lines:
-        fields.append({"name": "Inventory", "value": "\n".join(cargo_lines), "inline": False})
-
-    prospected_meta = meta.get("prospected", {}) or {}
-    content_summary = meta.get("content_summary", {}) or {}
-    prospect_lines = []
-    total_prospected = _safe_int(prospected_meta.get("total"))
-    if total_prospected is not None:
-        high = _safe_int(content_summary.get("High"), default=0) or 0
-        medium = _safe_int(content_summary.get("Medium"), default=0) or 0
-        low = _safe_int(content_summary.get("Low"), default=0) or 0
-        prospect_lines.append(
-            f"Asteroids: {total_prospected} (High {high}, Medium {medium}, Low {low})"
-        )
-    launched = _safe_int(meta.get("prospectors_launched"))
-    lost = _safe_int(meta.get("prospectors_lost"))
-    duplicates = _safe_int(prospected_meta.get("duplicates"))
-    collectors = _safe_int(meta.get("collectors_launched"))
-    collectors_abandoned = _safe_int(meta.get("collectors_abandoned"))
-    if any(value is not None for value in (launched, lost, duplicates, collectors)):
-        prospect_lines.append(
-            "Prospectors: "
-            f"{launched or 0} launched | Lost {lost or 0} | Duplicates {duplicates or 0}"
-        )
-        prospect_lines.append(
-            f"Collectors: {collectors or 0} | Abandoned {collectors_abandoned or 0}"
-        )
-    if prospect_lines:
-        fields.append({"name": "Prospecting", "value": "\n".join(prospect_lines), "inline": False})
-
-    refinement_meta = meta.get("refinement_activity", {}) or {}
-    max_rpm = _safe_float(refinement_meta.get("max_rpm", meta.get("max_rpm")))
-    current_rpm = _safe_float(refinement_meta.get("current_rpm"))
-    lookback = _safe_int(refinement_meta.get("lookback_seconds"))
-    refinement_parts = []
-    if max_rpm is not None:
-        refinement_parts.append(f"Max {max_rpm:.1f} RPM")
-    if current_rpm is not None:
-        refinement_parts.append(f"Current {current_rpm:.1f} RPM")
-    if lookback:
-        refinement_parts.append(f"Lookback {lookback}s")
-    if refinement_parts:
-        fields.append({"name": "Refining", "value": " | ".join(refinement_parts), "inline": False})
-
-    summary = payload.get("commodities", {})
-    top_value = _format_top_commodities(summary)
-    if top_value:
-        fields.append({"name": "Top Commodities", "value": top_value, "inline": False})
-
-    materials = meta.get("materials", [])
-    materials_value = _format_materials(materials)
-    if materials_value:
-        fields.append({"name": "Materials", "value": materials_value, "inline": False})
-
-    if meta.get("ended_via_reset"):
-        fields.append(
-            {
-                "name": "Notes",
-                "value": "Session ended via manual reset.",
-                "inline": False,
-            }
-        )
-
-    if json_path is not None:
-        fields.append(
-            {
-                "name": "Log",
-                "value": json_path.name,
-                "inline": False,
-            }
-        )
-
-    embed: Dict[str, Any] = {
-        "title": f"CMDR {commander} — Mining Summary",
-        "description": f"{ship}",
-        "color": EMBED_COLOR,
-        "fields": fields,
-        "footer": {"text": "EDMC Mining Analytics"},
-    }
-
-    image_url = embed.get("image", {}).get("url")
-    if not image_url:
-        manager = DiscordImageManager(state)
-        image_url = manager.select_image(meta.get("ship") or state.current_ship)
-        if image_url:
-            embed["image"] = {"url": image_url}
-
-    end_time = meta.get("end_time")
-    if isinstance(end_time, str) and end_time:
-        embed["timestamp"] = end_time
-
-    return {"embeds": [embed]}
-
-
-def build_test_message(state: MiningState) -> Dict[str, Any]:
-    """Create a payload that mimics a summary for webhook tests."""
-
-    now = datetime.now(timezone.utc)
-    meta = {
-        "start_time": now.isoformat().replace("+00:00", "Z"),
-        "end_time": now.isoformat().replace("+00:00", "Z"),
-        "duration_seconds": 0.0,
-        "overall_tph": {
-            "tons": state.current_cargo_tonnage,
-            "elapsed_seconds": 0.0,
-            "tons_per_hour": 0.0,
-        },
-        "location": {
-            "body": state.mining_location if state.mining_location else None,
-            "system": state.current_system if state.current_system else None,
-        },
-        "ship": state.current_ship or "Unknown ship",
-        "prospected": {
-            "total": state.prospected_count,
-            "already_mined": state.already_mined_count,
-            "duplicates": state.duplicate_prospected,
-        },
-        "prospectors_launched": state.prospector_launched_count,
-        "prospectors_lost": max(0, state.prospector_launched_count - state.prospected_count),
-        "collectors_launched": state.collection_drones_launched,
-        "collectors_abandoned": state.abandoned_limpets,
-        "limpets_remaining": state.limpets_remaining,
-        "content_summary": {
-            "High": state.prospect_content_counts.get("High", 0),
-            "Medium": state.prospect_content_counts.get("Medium", 0),
-            "Low": state.prospect_content_counts.get("Low", 0),
-        },
-        "materials": _materials_snapshot(state, state.materials_collected),
-        "commander": state.cmdr_name,
-        "ring": state.mining_ring,
-        "max_rpm": round(state.max_rpm, 2),
-        "refinement_activity": {
-            "lookback_seconds": state.refinement_lookback_seconds,
-            "current_rpm": round(state.current_rpm, 2),
-            "max_rpm": round(state.max_rpm, 2),
-        },
-    }
-
-    payload = {"meta": meta, "commodities": {}}
-    message = build_summary_message(state, payload, json_path=None)
-    embed = message["embeds"][0]
-    embed["title"] += " (Test)"
-    embed["description"] = "Webhook test message"
-    embed["color"] = TEST_COLOR
-    return message
-
-
-def format_duration(seconds: float) -> str:
-    total_seconds = max(0, int(seconds))
-    hours, remainder = divmod(total_seconds, 3600)
-    minutes, secs = divmod(remainder, 60)
-    parts: List[str] = []
-    if hours:
-        parts.append(f"{hours}h")
-    if minutes or (hours and secs):
-        parts.append(f"{minutes}m")
-    parts.append(f"{secs}s")
-    return " ".join(parts)
-
-
-def _safe_float(value: Any) -> Optional[float]:
-    try:
-        result = float(value)
-    except (TypeError, ValueError):
-        return None
-    return result
-
-
-def _safe_int(value: Any, *, default: Optional[int] = None) -> Optional[int]:
-    try:
-        return int(value)
-    except (TypeError, ValueError):
-        return default
-
-
-def _format_top_commodities(commodities: Dict[str, Any]) -> Optional[str]:
-    if not commodities:
-        return None
-    sorted_items = sorted(
-        commodities.items(),
-        key=lambda item: item[1].get("gathered", {}).get("tons", 0),
-        reverse=True,
-    )[:3]
-    lines: List[str] = []
-    for name, info in sorted_items:
-        tons = info.get("gathered", {}).get("tons", 0)
-        tph = info.get("tons_per_hour")
-        tph_text = f"{tph:.1f} TPH" if isinstance(tph, (int, float)) else "-"
-        lines.append(f"**{name}** — {tons:.1f} tons ({tph_text})")
-    return "\n".join(lines)
-
-
-def _format_materials(materials: Iterable[Dict[str, Any]]) -> Optional[str]:
-    if not materials:
-        return None
-    entries: List[Tuple[str, int]] = []
-    for material in materials:
-        if not isinstance(material, dict):
-            continue
-        name = material.get("name")
-        if not name or not isinstance(name, str):
-            continue
-        count_value = material.get("count")
-        try:
-            count = int(count_value)
-        except (TypeError, ValueError):
-            continue
-        if count <= 0:
-            continue
-        entries.append((name, count))
-    if not entries:
-        return None
-    entries.sort(key=lambda item: (-item[1], item[0]))
-    top_entries = entries[:8]
-    formatted = [f"{name} x{count}" for name, count in top_entries]
-    remaining = len(entries) - len(top_entries)
-    if remaining > 0:
-        formatted.append(f"+{remaining} more")
-    return ", ".join(formatted)
-
-
-def _materials_snapshot(state: MiningState, materials: Counter[str]) -> List[Dict[str, Any]]:
-    if not materials:
-        return []
-    if hasattr(materials, "items"):
-        items_iter = materials.items()
-    else:
-        items_iter = materials
-    snapshot: List[Dict[str, Any]] = []
-    for entry in items_iter:
-        try:
-            raw_name, raw_count = entry
-        except (TypeError, ValueError):
-            continue
-        if raw_count is None:
-            continue
-        try:
-            count = int(raw_count)
-        except (TypeError, ValueError):
-            continue
-        if count <= 0:
-            continue
-        name = _format_name(state, str(raw_name))
-        snapshot.append({"name": name, "count": count})
-    snapshot.sort(key=lambda entry: entry["name"])
-    return snapshot
-
-
-def _format_ring_info(reserve: Optional[Any], ring_type: Optional[Any]) -> Optional[str]:
-    reserve_text = reserve.strip() if isinstance(reserve, str) else None
-    ring_text = ring_type.strip() if isinstance(ring_type, str) else None
-    parts = [value for value in (reserve_text, ring_text) if value]
-    if not parts:
-        return None
-    return " ".join(parts)
-
-
-def _format_name(state: MiningState, value: str) -> str:
-    return resolve_commodity_display_name(state, value)
diff --git a/integrations/edmcoverlay.py b/integrations/edmcoverlay.py
deleted file mode 100644
index 1ba80cc..0000000
--- a/integrations/edmcoverlay.py
+++ /dev/null
@@ -1,363 +0,0 @@
-"""Helper utilities for sending mining metrics to EDMCOverlay."""
-
-from __future__ import annotations
-
-import logging
-from dataclasses import dataclass
-from datetime import datetime, timezone, timedelta
-from typing import Optional, Sequence, Tuple
-
-from logging_utils import get_logger
-from state import MiningState, update_rpm
-
-try:  # pragma: no cover - runtime environment provides this module
-    from EDMCOverlay import edmcoverlay as _overlay_module  # type: ignore[import]
-except ImportError:  # pragma: no cover - fallback to legacy package name
-    try:
-        from edmcoverlay import edmcoverlay as _overlay_module  # type: ignore[import]
-    except ImportError:
-        _overlay_module = None  # type: ignore[assignment]
-
-_log = get_logger("overlay")
-
-RPM_COLOR_RED = "#e74c3c"
-RPM_COLOR_YELLOW = "#f7931e"
-RPM_COLOR_GREEN = "#2ecc71"
-DEFAULT_LABEL_COLOR = "#b4b7bf"
-DEFAULT_VALUE_COLOR = "#ffffff"
-_METRIC_ORDER: Sequence[Tuple[str, str]] = (
-    ("tons_per_hour", "Tons/hr"),
-    ("rpm", "RPM"),
-    ("percent_full", "% Full"),
-    ("limpets", "Limpets"),
-)
-
-
-def is_overlay_available() -> bool:
-    """Check whether the EDMCOverlay module is importable."""
-
-    return _overlay_module is not None
-
-
-def determine_rpm_color(state: MiningState, rpm: float, *, default: str = DEFAULT_VALUE_COLOR) -> str:
-    """Resolve the RPM colour based on user-configured thresholds."""
-
-    try:
-        green_threshold = int(state.rpm_threshold_green)
-        yellow_threshold = int(state.rpm_threshold_yellow)
-        red_threshold = int(state.rpm_threshold_red)
-    except (TypeError, ValueError):
-        green_threshold = state.rpm_threshold_green
-        yellow_threshold = state.rpm_threshold_yellow
-        red_threshold = state.rpm_threshold_red
-
-    rpm_value = max(0.0, float(rpm))
-    if rpm_value >= max(1, green_threshold):
-        return RPM_COLOR_GREEN
-    if rpm_value >= max(1, yellow_threshold):
-        return RPM_COLOR_YELLOW
-    if rpm_value >= max(1, red_threshold):
-        return RPM_COLOR_RED
-    return default
-
-
-@dataclass
-class _OverlayMetric:
-    key: str
-    label: str
-    value: str
-    color: str
-
-
-class EdmcOverlayHelper:
-    """Coordinates EDMCOverlay availability checks and payload broadcasting."""
-
-    def __init__(self, state: MiningState) -> None:
-        self._state = state
-        self._overlay: Optional[object] = None
-        self._last_enabled = False
-        self._last_failure_logged = False
-        self._logger = logging.getLogger("EDMC.MiningAnalytics.Overlay")
-        self._preview_until: Optional[datetime] = None
-
-    # ------------------------------------------------------------------
-    # Availability lifecycle
-    # ------------------------------------------------------------------
-    def is_supported(self) -> bool:
-        """Return True when the edmcoverlay compatibility layer is importable."""
-
-        return is_overlay_available()
-
-    def refresh_availability(self) -> bool:
-        """Synchronise the state flag with current availability."""
-
-        available = self.is_supported()
-        self._state.overlay_available = available
-        return available
-
-    def reset(self) -> None:
-        """Drop the cached overlay client so we reconnect on next use."""
-
-        self._overlay = None
-        self._last_enabled = False
-
-    # ------------------------------------------------------------------
-    # Metric dispatch
-    # ------------------------------------------------------------------
-    def trigger_preview(self, duration_seconds: int = 5) -> None:
-        if duration_seconds <= 0:
-            self._preview_until = None
-            return
-        now = datetime.now(timezone.utc)
-        self._preview_until = now + timedelta(seconds=duration_seconds)
-
-    def clear_preview(self) -> None:
-        self._preview_until = None
-
-    def is_preview_active(self) -> bool:
-        return self._preview_active(datetime.now(timezone.utc))
-
-    def preview_seconds_remaining(self) -> Optional[float]:
-        now = datetime.now(timezone.utc)
-        if not self._preview_active(now):
-            return None
-        if self._preview_until is None:
-            return None
-        remaining = (self._preview_until - now).total_seconds()
-        return max(0.0, remaining)
-
-    def push_metrics(self) -> None:
-        """Emit the latest mining metrics to the overlay when enabled."""
-
-        now = datetime.now(timezone.utc)
-        preview_active = self._preview_active(now)
-
-        if not self._state.overlay_enabled:
-            self.clear_preview()
-            if self._last_enabled:
-                self._clear_overlay()
-            return
-
-        if not self.refresh_availability():
-            self.clear_preview()
-            if self._last_enabled:
-                self._clear_overlay()
-            return
-
-        if self._state.is_mining:
-            self.clear_preview()
-
-        if not self._state.is_mining and not preview_active:
-            if self._last_enabled:
-                self._clear_overlay()
-            return
-
-        client = self._resolve_overlay()
-        if client is None:
-            if not self._last_failure_logged:
-                _log.debug("EDMCOverlay helper unavailable; metrics not sent")
-                self._last_failure_logged = True
-            return
-
-        self._last_failure_logged = False
-        metrics = self._build_metrics()
-        if not metrics:
-            if self._last_enabled:
-                self._clear_overlay()
-            return
-
-        ttl = 5 if (preview_active and not self._state.is_mining) else self._derive_ttl()
-        anchor_x = max(0, int(self._state.overlay_anchor_x or 0))
-        anchor_y = max(0, int(self._state.overlay_anchor_y or 0))
-        row_height = 58
-        label_offset = 26
-
-        for index, metric in enumerate(metrics):
-            base_y = anchor_y + index * row_height
-            try:
-                client.send_message(
-                    f"edmcma.metric.{metric.key}.value",
-                    metric.value,
-                    metric.color,
-                    anchor_x,
-                    base_y,
-                    ttl=ttl,
-                    size="large",
-                )
-                client.send_message(
-                    f"edmcma.metric.{metric.key}.label",
-                    metric.label,
-                    DEFAULT_LABEL_COLOR,
-                    anchor_x,
-                    base_y + label_offset,
-                    ttl=ttl,
-                    size="normal",
-                )
-            except Exception:  # pragma: no cover - runtime specific failures
-                self._logger.exception("Failed to send overlay metric payload for %s", metric.key)
-                self.reset()
-                self._state.overlay_available = self.is_supported()
-                return
-
-        self._last_enabled = True
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _resolve_overlay(self) -> Optional[object]:
-        if not self.is_supported():
-            return None
-        if self._overlay is not None:
-            return self._overlay
-        try:
-            self._overlay = _overlay_module.Overlay()  # type: ignore[call-arg]
-        except Exception:  # pragma: no cover - runtime dependent
-            self._logger.exception("Unable to initialise EDMCOverlay compatibility client")
-            self._overlay = None
-        return self._overlay
-
-    def _build_metrics(self) -> Sequence[_OverlayMetric]:
-        metrics: list[_OverlayMetric] = []
-
-        total_rate = self._compute_total_tph()
-        metrics.append(
-            _OverlayMetric(
-                key="tons_per_hour",
-                label="Tons/hr",
-                value=self._format_rate(total_rate) if total_rate is not None else "--",
-                color=DEFAULT_VALUE_COLOR,
-            )
-        )
-
-        # Mirror UI behavior: only recompute RPM when actively mining
-        # and not paused; otherwise use last computed value.
-        if self._state.is_mining and not self._state.is_paused:
-            rpm = update_rpm(self._state)
-        else:
-            rpm = float(self._state.current_rpm or 0.0)
-        rpm_color = determine_rpm_color(self._state, rpm, default=self._state.rpm_display_color or DEFAULT_VALUE_COLOR)
-        self._state.rpm_display_color = rpm_color
-        metrics.append(
-            _OverlayMetric(
-                key="rpm",
-                label="RPM",
-                value=f"{rpm:.1f}" if rpm is not None else "--",
-                color=rpm_color,
-            )
-        )
-
-        percent_full = self._compute_percent_full()
-        metrics.append(
-            _OverlayMetric(
-                key="percent_full",
-                label="% Full",
-                value=f"{percent_full:.1f}%" if percent_full is not None else "--",
-                color=DEFAULT_VALUE_COLOR,
-            )
-        )
-
-        limpets_remaining = self._state.limpets_remaining
-        limpets_label = "--" if limpets_remaining is None else str(max(0, int(limpets_remaining)))
-        metrics.append(
-            _OverlayMetric(
-                key="limpets",
-                label="Limpets Remaining",
-                value=limpets_label,
-                color=DEFAULT_VALUE_COLOR,
-            )
-        )
-
-        return metrics
-
-    def _compute_total_tph(self) -> Optional[float]:
-        if not self._state.mining_start:
-            return None
-        total_amount = sum(amount for amount in self._state.cargo_additions.values() if amount > 0)
-        if total_amount <= 0:
-            return None
-        start_time = self._ensure_aware(self._state.mining_start)
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        elapsed_seconds = (end_time - start_time).total_seconds()
-        if elapsed_seconds <= 0:
-            return None
-        return total_amount / (elapsed_seconds / 3600.0)
-
-    def _compute_percent_full(self) -> Optional[float]:
-        capacity = self._state.cargo_capacity
-        if capacity is None or capacity <= 0:
-            return None
-        mined = max(0, self._state.current_cargo_tonnage)
-        limpets_remaining = self._state.limpets_remaining or 0
-        total_loaded = max(0, mined + max(0, limpets_remaining))
-        return min(100.0, max(0.0, (total_loaded / capacity) * 100.0))
-
-    def _derive_ttl(self) -> int:
-        interval_ms = self._state.overlay_refresh_interval_ms or 1000
-        try:
-            interval_ms = int(interval_ms)
-        except (TypeError, ValueError):
-            interval_ms = 1000
-        interval_ms = max(200, interval_ms)
-        interval_seconds = interval_ms / 1000.0
-        ttl_seconds = max(5.0, min(300.0, interval_seconds * 3 + 5.0))
-        return int(ttl_seconds)
-
-    @staticmethod
-    def _format_rate(rate: Optional[float]) -> str:
-        if rate is None:
-            return "--"
-        if rate >= 10:
-            return f"{rate:.0f}"
-        if rate >= 1:
-            return f"{rate:.1f}"
-        return f"{rate:.2f}"
-
-    def _clear_overlay(self) -> None:
-        client = self._resolve_overlay()
-        if client is None:
-            self._last_enabled = False
-            return
-        anchor_x = max(0, int(self._state.overlay_anchor_x or 0))
-        anchor_y = max(0, int(self._state.overlay_anchor_y or 0))
-        row_height = 58
-        label_offset = 26
-        for index, (key, _label) in enumerate(_METRIC_ORDER):
-            base_y = anchor_y + index * row_height
-            try:
-                client.send_message(
-                    f"edmcma.metric.{key}.value",
-                    "",
-                    DEFAULT_VALUE_COLOR,
-                    anchor_x,
-                    base_y,
-                    ttl=1,
-                    size="large",
-                )
-                client.send_message(
-                    f"edmcma.metric.{key}.label",
-                    "",
-                    DEFAULT_LABEL_COLOR,
-                    anchor_x,
-                    base_y + label_offset,
-                    ttl=1,
-                    size="normal",
-                )
-            except Exception:  # pragma: no cover
-                self._logger.exception("Failed to clear overlay message %s", key)
-                break
-        self._last_enabled = False
-        self.clear_preview()
-
-    @staticmethod
-    def _ensure_aware(value: datetime) -> datetime:
-        if value.tzinfo is None:
-            return value.replace(tzinfo=timezone.utc)
-        return value.astimezone(timezone.utc)
-
-    def _preview_active(self, now: datetime) -> bool:
-        if self._preview_until is None:
-            return False
-        if now >= self._preview_until:
-            self._preview_until = None
-            return False
-        return True
diff --git a/integrations/mining_edsm.py b/integrations/mining_edsm.py
deleted file mode 100644
index 12c5dc6..0000000
--- a/integrations/mining_edsm.py
+++ /dev/null
@@ -1,294 +0,0 @@
-"""EDSM integration helpers for reserve level and ring type lookups."""
-
-from __future__ import annotations
-
-import threading
-from typing import Callable, Optional, Tuple
-from urllib import parse as urlparse
-
-import requests
-
-from http_client import get_shared_session
-from logging_utils import get_logger
-from state import MiningState
-
-
-_log = get_logger("edsm")
-_plugin_log = get_logger()
-
-
-class EdsmClient:
-    """Fetch reserve levels and ring types from EDSM without blocking the UI."""
-
-    def __init__(
-        self,
-        state: MiningState,
-        on_updated: Callable[[], None],
-        *,
-        request_timeout: float = 5.0,
-        session: Optional[requests.Session] = None,
-    ) -> None:
-        self._state = state
-        self._on_updated = on_updated
-        self._timeout = max(1.0, float(request_timeout))
-        self._session = session or get_shared_session()
-        self._lock = threading.Lock()
-        self._last_system: Optional[str] = None
-        self._last_ring: Optional[Tuple[str, str]] = None
-        self._last_body: Optional[str] = None
-
-    # ------------------------------------------------------------------
-    # Public API
-    # ------------------------------------------------------------------
-    def refresh(
-        self,
-        *,
-        system: Optional[str],
-        ring_name: Optional[str],
-    ) -> None:
-        """Queue background refreshes for the provided location details."""
-
-        normalized_system = self._normalize(system)
-        normalized_ring = self._normalize(ring_name)
-
-        start_system_thread = False
-        start_ring_thread = False
-
-        with self._lock:
-            if normalized_system != self._last_system:
-                self._last_system = normalized_system
-                self._last_body = None
-                if not normalized_system:
-                    start_system_thread = False
-                    updated = False
-                    if self._update_reserve_level(None):
-                        updated = True
-                    if self._update_ring_type(None):
-                        updated = True
-                    if self._update_body_name(None):
-                        updated = True
-                    if updated:
-                        self._notify_updated()
-                else:
-                    start_system_thread = True
-
-            ring_combo = (
-                (normalized_system, normalized_ring)
-                if normalized_ring and normalized_system
-                else None
-            )
-            if ring_combo != self._last_ring:
-                self._last_ring = ring_combo
-                if ring_combo is None:
-                    updated = False
-                    if self._update_ring_type(None):
-                        updated = True
-                    if self._update_body_name(None):
-                        updated = True
-                    if updated:
-                        self._notify_updated()
-                else:
-                    start_ring_thread = True
-
-        if start_system_thread and normalized_system:
-            thread = threading.Thread(
-                target=self._fetch_reserve_level,
-                args=(normalized_system,),
-                name="edmcma-edsm-reserve",
-                daemon=True,
-            )
-            thread.start()
-
-        if start_ring_thread and normalized_system and normalized_ring:
-            thread = threading.Thread(
-                target=self._fetch_ring_type,
-                args=(normalized_system, normalized_ring),
-                name="edmcma-edsm-ring",
-                daemon=True,
-            )
-            thread.start()
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _fetch_reserve_level(self, system: str) -> None:
-        url = (
-            "https://www.edsm.net/api-v1/system?systemName="
-            + urlparse.quote(system)
-            + "&showId=1&showCoordinates=1&showInformation=1"
-        )
-        _log.debug("Requesting EDSM reserve level: %s", url)
-
-        data = None
-        try:
-            response = self._session.get(url, timeout=self._timeout)
-            response.raise_for_status()
-        except requests.RequestException as exc:
-            _log.debug("EDSM reserve request failed for %s: %s", system, exc)
-        else:
-            try:
-                data = response.json()
-            except ValueError:
-                _log.debug("EDSM reserve response for %s was not valid JSON", system)
-
-        reserve = None
-        if isinstance(data, dict):
-            info = data.get("information") or data.get("Information")
-            if isinstance(info, dict):
-                reserve_value = (
-                    info.get("reserveLevel")
-                    or info.get("ReserveLevel")
-                    or info.get("reserve")
-                    or info.get("Reserve")
-                )
-                if isinstance(reserve_value, str) and reserve_value.strip():
-                    reserve = reserve_value.strip()
-
-        with self._lock:
-            if system != self._last_system:
-                return
-
-        if self._update_reserve_level(reserve):
-            self._notify_updated()
-
-    def _fetch_ring_type(self, system: str, ring_name: str) -> None:
-        url = (
-            "https://www.edsm.net/api-system-v1/bodies?systemName="
-            + urlparse.quote(system)
-        )
-        _log.debug("Requesting EDSM ring data: %s", url)
-
-        data = None
-        try:
-            response = self._session.get(url, timeout=self._timeout)
-            response.raise_for_status()
-        except requests.RequestException as exc:
-            _log.debug("EDSM ring request failed for %s (%s): %s", system, ring_name, exc)
-        else:
-            try:
-                data = response.json()
-            except ValueError:
-                _log.debug("EDSM ring response for %s (%s) was not valid JSON", system, ring_name)
-
-        ring_type = None
-        reserve_level = None
-        body_name = None
-        if isinstance(data, dict):
-            bodies = data.get("bodies")
-            if isinstance(bodies, list):
-                target = ring_name.lower()
-                for body in bodies:
-                    if not isinstance(body, dict):
-                        continue
-                    rings = body.get("rings")
-                    if not isinstance(rings, list):
-                        continue
-                    for ring in rings:
-                        if not isinstance(ring, dict):
-                            continue
-                        name = ring.get("name") or ring.get("Name")
-                        if not isinstance(name, str):
-                            continue
-                        if name.lower() != target:
-                            continue
-                        ring_value = ring.get("type") or ring.get("Type")
-                        if isinstance(ring_value, str) and ring_value.strip():
-                            ring_type = ring_value.strip()
-                        reserve_value = (
-                            ring.get("reserveLevel")
-                            or ring.get("reserve")
-                            or ring.get("ReserveLevel")
-                            or ring.get("Reserve")
-                        )
-                        if isinstance(reserve_value, str) and reserve_value.strip():
-                            reserve_level = reserve_value.strip()
-                        break
-                    if ring_type:
-                        name_value = body.get("name") or body.get("Name")
-                        if isinstance(name_value, str) and name_value.strip():
-                            body_name = name_value.strip()
-                        break
-
-        with self._lock:
-            if (system, ring_name) != self._last_ring:
-                return
-
-        updated = False
-        if self._update_ring_type(ring_type):
-            updated = True
-        if reserve_level is not None and self._update_reserve_level(reserve_level):
-            updated = True
-        if body_name and self._update_body_name(body_name):
-            updated = True
-        if updated:
-            self._notify_updated()
-
-    def _update_reserve_level(self, value: Optional[str]) -> bool:
-        if value == self._state.edsm_reserve_level:
-            if value:
-                _log.debug("EDSM reserve level unchanged: %s", value)
-                _plugin_log.debug("EDSM reserve level unchanged: %s", value)
-            else:
-                _log.debug("EDSM reserve level unchanged: <none>")
-                _plugin_log.debug("EDSM reserve level unchanged: <none>")
-            return False
-        if value:
-            _log.debug("EDSM reserve level detected: %s", value)
-            _plugin_log.debug("EDSM reserve level detected: %s", value)
-        else:
-            _log.debug("Clearing EDSM reserve level")
-            _plugin_log.debug("Clearing EDSM reserve level")
-        self._state.edsm_reserve_level = value
-        return True
-
-    def _update_ring_type(self, value: Optional[str]) -> bool:
-        if value == self._state.edsm_ring_type:
-            if value:
-                _log.debug("EDSM ring type unchanged: %s", value)
-                _plugin_log.debug("EDSM ring type unchanged: %s", value)
-            else:
-                _log.debug("EDSM ring type unchanged: <none>")
-                _plugin_log.debug("EDSM ring type unchanged: <none>")
-            return False
-        if value:
-            _log.debug("EDSM ring type detected: %s", value)
-            _plugin_log.debug("EDSM ring type detected: %s", value)
-        else:
-            _log.debug("Clearing EDSM ring type")
-            _plugin_log.debug("Clearing EDSM ring type")
-        self._state.edsm_ring_type = value
-        return True
-
-    def _update_body_name(self, value: Optional[str]) -> bool:
-        if value == self._state.edsm_body_name:
-            if value:
-                _log.debug("EDSM body name unchanged: %s", value)
-                _plugin_log.debug("EDSM body name unchanged: %s", value)
-            else:
-                _log.debug("EDSM body name unchanged: <none>")
-                _plugin_log.debug("EDSM body name unchanged: <none>")
-            return False
-        if value:
-            _log.debug("EDSM body name detected: %s", value)
-            _plugin_log.debug("EDSM body name detected: %s", value)
-        else:
-            _log.debug("Clearing EDSM body name")
-            _plugin_log.debug("Clearing EDSM body name")
-        self._state.edsm_body_name = value
-        return True
-
-    def _notify_updated(self) -> None:
-        try:
-            self._on_updated()
-        except Exception:
-            _log.exception("Failed to process EDSM update notification")
-
-    @staticmethod
-    def _normalize(value: Optional[str]) -> Optional[str]:
-        if not value:
-            return None
-        stripped = value.strip()
-        return stripped or None
-
-
-__all__ = ["EdsmClient"]
diff --git a/integrations/mining_inara.py b/integrations/mining_inara.py
deleted file mode 100644
index 384d94f..0000000
--- a/integrations/mining_inara.py
+++ /dev/null
@@ -1,123 +0,0 @@
-"""Helpers for building and launching Inara commodity searches."""
-
-from __future__ import annotations
-
-import json
-import logging
-import webbrowser
-from pathlib import Path
-from typing import Dict, Optional
-
-from urllib.parse import urlencode
-
-from state import MiningState
-from logging_utils import get_logger
-
-
-_log = get_logger("inara")
-
-
-class InaraClient:
-    """Encapsulates Inara commodity search URL generation and settings."""
-
-    def __init__(self, state: MiningState) -> None:
-        self._state = state
-        self._commodity_map: Dict[str, int] = {}
-
-    @property
-    def commodity_map(self) -> Dict[str, int]:
-        return self._commodity_map
-
-    def load_mapping(self, path: Path) -> None:
-        if not path.exists():
-            _log.debug("Commodity link mapping file not found at %s", path)
-            self._commodity_map = {}
-            return
-
-        try:
-            with path.open("r", encoding="utf-8") as handle:
-                raw = json.load(handle)
-        except Exception:
-            _log.exception("Failed to load commodity link mapping from %s", path)
-            self._commodity_map = {}
-            return
-
-        if not isinstance(raw, dict):
-            _log.warning("Commodity link mapping file is not a JSON object: %s", path)
-            self._commodity_map = {}
-            return
-
-        processed: Dict[str, int] = {}
-        for key, value in raw.items():
-            if not isinstance(key, str):
-                continue
-            try:
-                processed[key.strip().lower()] = int(value)
-            except (TypeError, ValueError):
-                _log.debug("Skipping commodity mapping with non-int value: %s=%r", key, value)
-
-        self._commodity_map = processed
-
-    # ------------------------------------------------------------------
-    # Settings management
-    # ------------------------------------------------------------------
-    def set_search_mode(self, mode: int) -> None:
-        self._state.inara_settings.search_mode = 3 if mode == 3 else 1
-
-    def set_include_carriers(self, include: bool) -> None:
-        self._state.inara_settings.include_carriers = bool(include)
-
-    def set_include_surface(self, include: bool) -> None:
-        self._state.inara_settings.include_surface = bool(include)
-
-    # ------------------------------------------------------------------
-    # URL helpers
-    # ------------------------------------------------------------------
-    def build_url(self, commodity: str) -> Optional[str]:
-        commodity_id = self._commodity_map.get(commodity.lower())
-        if commodity_id is None:
-            return None
-
-        system_name = self._state.current_system
-        if not system_name:
-            _log.debug("Cannot build Inara link for %s: system unknown", commodity)
-            return None
-
-        include_carriers = "0" if self._state.inara_settings.include_carriers else "1"
-        include_surface = "0" if self._state.inara_settings.include_surface else "1"
-        search_mode = "3" if self._state.inara_settings.search_mode == 3 else "1"
-
-        query = {
-            "formbrief": "1",
-            "pi1": "2",
-            "pa1[]": [str(commodity_id)],
-            "ps1": system_name,
-            "pi10": search_mode,
-            "pi11": "0",
-            "pi3": "3",
-            "pi9": "0",
-            "pi4": include_surface,
-            "pi8": include_carriers,
-            "pi13": "0",
-            "pi5": "720",
-            "pi12": "0",
-            "pi7": "500",
-            "pi14": "0",
-            "ps3": "",
-        }
-
-        try:
-            return "https://inara.cz/elite/commodities/?" + urlencode(query, doseq=True)
-        except Exception:
-            _log.exception("Failed to encode Inara URL for commodity %s", commodity)
-            return None
-
-    def open_link(self, commodity: str) -> None:
-        url = self.build_url(commodity)
-        if not url:
-            return
-        try:
-            if not webbrowser.open_new(url):
-                webbrowser.open(url)
-        except Exception:
-            _log.exception("Failed to open browser for commodity %s", commodity)
diff --git a/integrations/spansh_hotspots.py b/integrations/spansh_hotspots.py
deleted file mode 100644
index a321e21..0000000
--- a/integrations/spansh_hotspots.py
+++ /dev/null
@@ -1,412 +0,0 @@
-"""Client for querying Spansh hotspots."""
-
-from __future__ import annotations
-
-import logging
-import time
-from dataclasses import dataclass
-from typing import Dict, Iterable, List, Optional, Sequence, Tuple
-
-import requests
-
-from logging_utils import get_logger
-from state import MiningState
-from http_client import get_shared_session
-
-_log = get_logger("spansh")
-_plugin_log = get_logger()
-
-API_BASE = "https://spansh.co.uk/api"
-DEFAULT_TIMEOUT = 10
-DEFAULT_MIN_INTERVAL = 1.5  # configurable throttling to the Spansh hotspot client so consecutive searches respect a minimum interval.
-MAX_SIGNAL_COUNT = 9999
-DEFAULT_RESULT_SIZE = 50
-
-
-@dataclass(frozen=True)
-class RingSignal:
-    """Represents a single hotspot signal entry from Spansh."""
-
-    name: str
-    count: int
-
-
-@dataclass(frozen=True)
-class RingHotspot:
-    """Represents a single ring hotspot row."""
-
-    system_name: str
-    body_name: str
-    ring_name: str
-    ring_type: str
-    distance_ls: float
-    distance_ly: float
-    signals: Tuple[RingSignal, ...]
-    signals_updated_at: Optional[str] = None
-
-
-@dataclass(frozen=True)
-class HotspotSearchResult:
-    """Normalised representation of a Spansh hotspot search."""
-
-    total_count: int
-    reference_system: Optional[str]
-    entries: Tuple[RingHotspot, ...]
-
-
-class SpanshHotspotClient:
-    """Encapsulates Spansh hotspot lookups."""
-
-    def __init__(
-        self,
-        state: MiningState,
-        session: Optional[requests.Session] = None,
-        min_interval_seconds: float = DEFAULT_MIN_INTERVAL,
-    ) -> None:
-        self._state = state
-        self._session = session or get_shared_session()
-        self._field_cache: Dict[str, List[str]] = {}
-        self._min_interval = max(0.0, float(min_interval_seconds))
-        self._last_search_completed_at: float = 0.0
-
-    # ------------------------------------------------------------------
-    # Field metadata
-    # ------------------------------------------------------------------
-    def list_ring_types(self) -> List[str]:
-        return self._get_field_values("rings")
-
-    def list_ring_signals(self) -> List[str]:
-        return self._get_field_values("ring_signals")
-
-    def list_reserve_levels(self) -> List[str]:
-        return self._get_field_values("reserve_level")
-
-    def suggest_system_names(self, query: str, limit: int = 10) -> List[str]:
-        candidate = (query or "").strip()
-        if len(candidate) < 2:
-            return []
-
-        url = f"{API_BASE}/systems/field_values/system_names"
-        params = {"q": candidate}
-        try:
-            response = self._session.get(url, params=params, timeout=DEFAULT_TIMEOUT)
-        except Exception:
-            _plugin_log.debug("Spansh reference suggestions failed (query=%r): request error", candidate)
-            return []
-
-        if response.status_code != 200:
-            _plugin_log.debug(
-                "Spansh reference suggestions failed (query=%r): status %s",
-                candidate,
-                response.status_code,
-            )
-            return []
-
-        try:
-            data = response.json()
-        except Exception:
-            _plugin_log.debug("Spansh reference suggestions failed (query=%r): invalid JSON", candidate)
-            return []
-
-        values = data.get("values")
-        if not isinstance(values, list):
-            _plugin_log.debug("Spansh reference suggestions unexpected payload (query=%r): %s", candidate, data)
-            return []
-
-        cleaned = []
-        seen: set[str] = set()
-        candidate_lower = candidate.lower()
-
-        for value in values:
-            if not isinstance(value, str):
-                continue
-            name = value.strip()
-            if not name:
-                continue
-            if name.lower() in seen:
-                continue
-            seen.add(name.lower())
-            cleaned.append(name)
-            if len(cleaned) >= limit:
-                break
-
-        # Ensure the user's current system is considered when it matches the query
-        current_system = (self._state.current_system or "").strip()
-        if current_system and current_system.lower().startswith(candidate_lower):
-            if current_system.lower() not in seen:
-                cleaned.insert(0, current_system)
-
-        _plugin_log.debug(
-            "Spansh reference suggestions query=%r params=%s returned %d candidate(s)",
-            candidate,
-            params,
-            len(cleaned),
-        )
-
-        return cleaned
-
-    def resolve_reference_system(self, reference: Optional[str]) -> str:
-        candidate = (reference or "").strip()
-        current_system = (self._state.current_system or "").strip()
-
-        if not candidate:
-            if current_system:
-                return current_system
-            raise ValueError("Reference system is unknown; please enter a system name.")
-
-        if current_system and candidate.lower() == current_system.lower():
-            return current_system
-
-        url = f"{API_BASE}/systems/field_values/system_names"
-        params = {"q": candidate}
-        try:
-            response = self._session.get(url, params=params, timeout=DEFAULT_TIMEOUT)
-        except Exception as exc:
-            _log.exception("Spansh reference system lookup failed: %s", exc)
-            raise RuntimeError("Failed to contact spansh.co.uk systems API") from exc
-
-        if response.status_code != 200:
-            raise RuntimeError(f"Spansh reference system lookup failed with status {response.status_code}")
-
-        try:
-            data = response.json()
-        except Exception as exc:
-            _log.exception("Failed to parse Spansh reference system response: %s", exc)
-            raise RuntimeError("Unable to decode Spansh reference system response") from exc
-
-        values = data.get("values")
-        if not isinstance(values, list):
-            values = []
-
-        cleaned = [str(value).strip() for value in values if isinstance(value, str) and str(value).strip()]
-        if not cleaned:
-            raise ValueError(f"Reference system '{candidate}' was not found on spansh.co.uk")
-
-        candidate_lower = candidate.lower()
-        for name in cleaned:
-            if name.lower() == candidate_lower:
-                return name
-
-        return cleaned[0]
-
-    def _get_field_values(self, field: str) -> List[str]:
-        cached = self._field_cache.get(field)
-        if cached is not None:
-            return cached
-
-        url = f"{API_BASE}/bodies/field_values/{field}"
-        try:
-            response = self._session.get(url, timeout=DEFAULT_TIMEOUT)
-        except Exception:
-            _log.exception("Failed to fetch Spansh field values for %s", field)
-            return []
-
-        if response.status_code != 200:
-            _log.warning("Non-200 response when fetching field values for %s: %s", field, response.status_code)
-            return []
-
-        try:
-            payload = response.json()
-        except Exception:
-            _log.exception("Failed to decode field values response for %s", field)
-            return []
-
-        values = payload.get("values")
-        if not isinstance(values, list):
-            _log.debug("Unexpected payload for field values %s: %s", field, payload)
-            return []
-
-        cleaned = [str(value) for value in values if isinstance(value, str)]
-        self._field_cache[field] = cleaned
-        return cleaned
-
-    # ------------------------------------------------------------------
-    # Hotspot search
-    # ------------------------------------------------------------------
-    def search_hotspots(
-        self,
-        distance_min: float,
-        distance_max: float,
-        ring_signals: Sequence[str],
-        reserve_levels: Sequence[str],
-        ring_types: Sequence[str],
-        limit: int = DEFAULT_RESULT_SIZE,
-        page: int = 0,
-        reference_system: Optional[str] = None,
-        min_hotspots: int = 1,
-    ) -> HotspotSearchResult:
-        """Query Spansh for hotspots near the current system."""
-
-        system = (reference_system or self._state.current_system or "").strip()
-        if not system:
-            raise ValueError("Reference system is unknown; cannot perform hotspot search.")
-
-        filters: Dict[str, object] = {}
-
-        min_count = max(1, int(min_hotspots))
-
-        if distance_min is not None or distance_max is not None:
-            min_val = float(distance_min if distance_min is not None else 0.0)
-            max_val = float(distance_max if distance_max is not None else MAX_SIGNAL_COUNT)
-            if max_val < min_val:
-                min_val, max_val = max_val, min_val
-            filters["distance"] = {"min": min_val, "max": max_val}
-
-        cleaned_signals = [signal for signal in (ring_signals or []) if signal]
-        if cleaned_signals:
-            filters["ring_signals"] = [
-                {
-                    "comparison": "<=>",
-                    "count": [min_count, MAX_SIGNAL_COUNT],
-                    "name": cleaned_signals,
-                }
-            ]
-
-        cleaned_reserves = [reserve for reserve in (reserve_levels or []) if reserve]
-        if cleaned_reserves:
-            if len(cleaned_reserves) == 1:
-                filters["reserve_level"] = {"value": cleaned_reserves[0]}
-            else:
-                filters["reserve_level"] = {"value": cleaned_reserves}
-
-        cleaned_rings = [ring_type for ring_type in (ring_types or []) if ring_type]
-        if cleaned_rings:
-            filters["rings"] = [{"type": cleaned_rings}]
-
-        payload = {
-            "filters": filters,
-            "reference_system": system,
-            "sort": [{"distance": {"direction": "asc"}}],
-            "size": max(1, min(int(limit or DEFAULT_RESULT_SIZE), 200)),
-            "page": max(0, int(page)),
-        }
-
-        delay = 0.0
-        now = time.monotonic()
-        elapsed = now - self._last_search_completed_at
-        if elapsed < self._min_interval:
-            delay = self._min_interval - elapsed
-            time.sleep(delay)
-
-        url = f"{API_BASE}/bodies/search"
-        try:
-            response = self._session.post(url, json=payload, timeout=DEFAULT_TIMEOUT)
-        except Exception as exc:
-            _log.exception("Spansh hotspot request failed: %s", exc)
-            raise RuntimeError("Failed to contact spansh.co.uk bodies API") from exc
-
-        if response.status_code != 200:
-            _log.warning("Spansh hotspot search returned status %s", response.status_code)
-            raise RuntimeError(f"Spansh hotspot search failed with status {response.status_code}")
-
-        try:
-            data = response.json()
-        except Exception as exc:
-            _log.exception("Failed to parse Spansh hotspot response: %s", exc)
-            raise RuntimeError("Unable to decode Spansh hotspot results") from exc
-
-        results = data.get("results") or []
-        entries = self._extract_ring_entries(
-            results,
-            set(cleaned_signals) if cleaned_signals else None,
-            set(cleaned_rings) if cleaned_rings else None,
-        )
-
-        reference = data.get("reference") or {}
-        reference_name = reference.get("name") if isinstance(reference, dict) else None
-        if not reference_name:
-            reference_name = system
-        total_count = int(data.get("count") or 0)
-
-        if _log.isEnabledFor(logging.DEBUG) or _plugin_log.isEnabledFor(logging.DEBUG):
-            log_args = (
-                system,
-                len(results),
-                len(entries),
-                total_count,
-                payload["size"],
-                payload["page"],
-                filters,
-            )
-            if _log.isEnabledFor(logging.DEBUG):
-                _log.debug(
-                    "Spansh hotspot search for %s returned %d rows (hotspots=%d, total_count=%d, limit=%d, page=%d) with filters %s",
-                    *log_args,
-                )
-            if _plugin_log is not _log and _plugin_log.isEnabledFor(logging.DEBUG):
-                _plugin_log.debug(
-                    "Spansh hotspot search for %s returned %d rows (hotspots=%d, total_count=%d, limit=%d, page=%d) with filters %s",
-                    *log_args,
-        )
-
-        self._last_search_completed_at = time.monotonic()
-
-        return HotspotSearchResult(
-            total_count=total_count,
-            reference_system=reference_name,
-            entries=tuple(entries),
-        )
-
-    def _extract_ring_entries(
-        self,
-        bodies: Iterable[Dict[str, object]],
-        required_signals: Optional[set[str]],
-        allowed_ring_types: Optional[set[str]],
-    ) -> List[RingHotspot]:
-        rows: List[RingHotspot] = []
-        for body in bodies:
-            if not isinstance(body, dict):
-                continue
-            system_name = str(body.get("system_name") or "")
-            body_name = str(body.get("name") or "")
-            distance_ls = float(body.get("distance_to_arrival") or 0.0)
-            distance_ly = float(body.get("distance") or 0.0)
-
-            rings = body.get("rings") or []
-            if not isinstance(rings, list):
-                continue
-
-            for ring in rings:
-                if not isinstance(ring, dict):
-                    continue
-                ring_type = str(ring.get("type") or "")
-                if allowed_ring_types and ring_type not in allowed_ring_types:
-                    continue
-                ring_name = str(ring.get("name") or "")
-                signals_payload = ring.get("signals") or []
-                if not isinstance(signals_payload, list):
-                    signals_payload = []
-
-                signals: List[RingSignal] = []
-                for entry in signals_payload:
-                    if not isinstance(entry, dict):
-                        continue
-                    name = entry.get("name")
-                    count = entry.get("count", 0)
-                    if not isinstance(name, str):
-                        continue
-                    try:
-                        count_value = int(count)
-                    except (TypeError, ValueError):
-                        count_value = 0
-                    signals.append(RingSignal(name=name, count=count_value))
-
-                if required_signals:
-                    signal_names = {signal.name for signal in signals}
-                    if not signal_names & required_signals:
-                        continue
-
-                rows.append(
-                    RingHotspot(
-                        system_name=system_name,
-                        body_name=body_name,
-                        ring_name=ring_name,
-                        ring_type=ring_type,
-                        distance_ls=distance_ls,
-                        distance_ly=distance_ly,
-                        signals=tuple(signals),
-                        signals_updated_at=str(ring.get("signals_updated_at") or None),
-                    )
-                )
-
-        return rows
diff --git a/journal.py b/journal.py
deleted file mode 100644
index 91ea2e6..0000000
--- a/journal.py
+++ /dev/null
@@ -1,1384 +0,0 @@
-"""Journal event processing for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-import logging
-from collections import Counter
-from dataclasses import dataclass
-from datetime import datetime, timezone, timedelta
-from typing import Any, Callable, Optional, Tuple
-import threading
-
-from state import (
-    MiningState,
-    register_refinement,
-    recompute_histograms,
-    reset_mining_state,
-    update_rpm,
-)
-from session_recorder import SessionRecorder
-from logging_utils import get_logger
-from integrations.mining_edsm import EdsmClient
-
-try:  # pragma: no cover - only available inside EDMC
-    from edmc_data import ship_name_map  # type: ignore[import]
-except ImportError:  # pragma: no cover - fallback when not running inside EDMC
-    ship_name_map = {}
-
-
-_log = get_logger("journal")
-_plugin_log = get_logger()
-
-
-@dataclass
-class PendingShipUpdate:
-    """Tracks ship-change events that expect a follow-up loadout."""
-
-    key: str
-    context: str
-    ship_display: Optional[str]
-    ship_source: Optional[str]
-    capacity_value: Optional[int]
-    capacity_source: Optional[str]
-    initiated_at: datetime
-    entry: Optional[dict]
-    shared_state: Optional[dict]
-
-
-_PENDING_SHIP_UPDATE_TIMEOUT = timedelta(seconds=10)
-
-
-class JournalProcessor:
-    """Transforms EDMC journal events into mining analytics state updates."""
-
-    def __init__(
-        self,
-        state: MiningState,
-        refresh_ui: Callable[[], None],
-        on_session_start: Callable[[], None],
-        on_session_end: Callable[[], None],
-        persist_inferred_capacities: Callable[[], None],
-        notify_mining_activity: Optional[Callable[[str], None]] = None,
-        session_recorder: Optional[SessionRecorder] = None,
-        edsm_client: Optional[EdsmClient] = None,
-    ) -> None:
-        self._state = state
-        self._refresh_ui = refresh_ui
-        self._on_session_start = on_session_start
-        self._on_session_end = on_session_end
-        self._persist_inferred_capacities = persist_inferred_capacities
-        self._notify_mining_activity = notify_mining_activity
-        self._initial_state_checked = False
-        self._pending_ship_updates: dict[str, PendingShipUpdate] = {}
-        self._pending_timeout_timer: Optional[threading.Timer] = None
-        self._session_recorder = session_recorder
-        self._edsm = edsm_client
-
-    # ------------------------------------------------------------------
-    # Public API
-    # ------------------------------------------------------------------
-    def handle_entry(self, entry: dict, shared_state: Optional[dict] = None) -> None:
-        if not entry:
-            return
-
-        edmc_state = shared_state if isinstance(shared_state, dict) else None
-
-        event_time = self._parse_timestamp(entry.get("timestamp")) or datetime.now(timezone.utc)
-        update_rpm(self._state, event_time)
-        if (
-            not self._initial_state_checked
-            and edmc_state
-            and any(
-                key in edmc_state
-                for key in ("Ship", "ShipType", "ShipName", "ShipLocalised", "CargoCapacity", "ShipID")
-            )
-        ):
-            self._initial_state_checked = True
-            self._handle_ship_update(
-                entry=None,
-                shared_state=edmc_state,
-                context="Initial state detected",
-                event_type="InitialState",
-                event_time=event_time,
-            )
-            self._flush_expired_ship_updates(event_time)
-            self._schedule_pending_timeout()
-        self._schedule_pending_timeout()
-
-        event = entry.get("event")
-        if event == "LaunchDrone":
-            self._process_launch_drone(entry, edmc_state, event_time)
-        elif event == "ProspectedAsteroid" and self._state.is_mining:
-            self._register_prospected_asteroid(entry, event_time)
-        elif event == "Cargo":
-            self._process_cargo(entry, edmc_state, is_mining=self._state.is_mining, event_time=event_time)
-        elif event == "MiningRefined":
-            if self._session_recorder:
-                type_localised_raw = entry.get("Type_Localised")
-                localized = None
-                if isinstance(type_localised_raw, str):
-                    localized = type_localised_raw.strip() or None
-                raw_type = entry.get("Type")
-                type_name = None
-                if isinstance(raw_type, str):
-                    type_name = raw_type.strip() or None
-                if not localized:
-                    localized = type_name
-                self._session_recorder.record_mining_refined(
-                    event_time,
-                    commodity_localised=localized,
-                    commodity_type=type_name,
-                )
-            register_refinement(self._state, event_time)
-            self._emit_mining_activity("MiningRefined")
-        elif event == "BuyDrones":
-            if self._session_recorder:
-                count = entry.get("Count")
-                try:
-                    parsed_count = int(count) if count is not None else None
-                except (TypeError, ValueError):
-                    parsed_count = None
-                drone_type = entry.get("Type")
-                drone_name = drone_type if isinstance(drone_type, str) else None
-                self._session_recorder.record_buy_drones(event_time, count=parsed_count, drone_type=drone_name)
-        elif event == "SupercruiseEntry" and self._state.is_mining:
-            self._update_mining_state(
-                False,
-                "Entered Supercruise",
-                entry.get("timestamp"),
-                state=edmc_state,
-                entry=entry,
-            )
-        elif event == "MaterialCollected" and self._state.is_mining:
-            self._register_material_collected(entry)
-        elif event == "LoadGame":
-            self._handle_ship_update(
-                entry,
-                edmc_state,
-                context="LoadGame detected",
-                event_type=event,
-                event_time=event_time,
-            )
-        elif event == "Loadout":
-            message = f"Journal Loadout received: {entry}"
-            _log.debug(message)
-            if _plugin_log is not _log:
-                _plugin_log.debug(message)
-            self._handle_ship_update(
-                entry,
-                edmc_state,
-                context="Loadout detected",
-                event_type=event,
-                event_time=event_time,
-            )
-        elif event == "ShipyardSwap":
-            message = f"Journal ShipyardSwap received: {entry}"
-            _log.debug(message)
-            if _plugin_log is not _log:
-                _plugin_log.debug(message)
-            self._handle_ship_update(
-                entry,
-                edmc_state,
-                context="Ship swap detected",
-                event_type=event,
-                event_time=event_time,
-            )
-
-        system_name = self._detect_current_system(entry)
-        if system_name:
-            self._set_current_system(system_name)
-            self._refresh_edsm()
-
-        if isinstance(shared_state, dict):
-            shared_state.update(
-                {
-                    "edmc_mining_active": self._state.is_mining,
-                    "edmc_mining_start": self._state.mining_start.isoformat() if self._state.mining_start else None,
-                    "edmc_mining_prospected": self._state.prospected_count,
-                    "edmc_mining_already_mined": self._state.already_mined_count,
-                    "edmc_mining_cargo": dict(self._state.cargo_additions),
-                    "edmc_mining_cargo_totals": dict(self._state.cargo_totals),
-                    "edmc_mining_limpets": self._state.limpets_remaining,
-                    "edmc_mining_collection_drones": self._state.collection_drones_launched,
-                    "edmc_mining_prospect_histogram": self._serialize_histogram(),
-                    "edmc_mining_prospect_duplicates": self._state.duplicate_prospected,
-                    "edmc_mining_histogram_bin": self._state.histogram_bin_size,
-                    "edmc_mining_limpets_abandoned": self._state.abandoned_limpets,
-                    "edmc_mining_prospect_content": dict(self._state.prospect_content_counts),
-                    "edmc_mining_materials_collected": dict(self._state.materials_collected),
-                    "edmc_mining_cargo_tph": self._serialize_tph(),
-                    "edmc_mining_total_tph": self._compute_total_tph(),
-                    "edmc_mining_prospectors_launched": self._state.prospector_launched_count,
-                    "edmc_mining_prospectors_lost": max(0, self._state.prospector_launched_count - self._state.prospected_count),
-                }
-            )
-
-        self._refresh_ui()
-
-    # ------------------------------------------------------------------
-    # Event handlers
-    # ------------------------------------------------------------------
-    def _process_launch_drone(
-        self,
-        entry: dict,
-        edmc_state: Optional[dict],
-        event_time: datetime,
-    ) -> None:
-        drone_type = entry.get("Type")
-        if not isinstance(drone_type, str):
-            self._state.last_event_was_drone_launch = False
-            return
-
-        dtype = drone_type.lower()
-        if dtype == "prospector":
-            if not self._state.is_mining:
-                self._update_mining_state(
-                    True,
-                    "Prospector drone launched",
-                    entry.get("timestamp"),
-                    state=edmc_state,
-                    entry=entry,
-                )
-            self._state.prospector_launched_count += 1
-        elif dtype == "collection" and self._state.is_mining:
-            self._state.collection_drones_launched += 1
-
-        self._state.last_event_was_drone_launch = True
-        self._refresh_ui()
-        self._emit_mining_activity(f"LaunchDrone:{dtype}")
-        if self._session_recorder:
-            self._session_recorder.record_launch_drone(event_time, drone_type=drone_type)
-
-    def _register_prospected_asteroid(self, entry: dict, event_time: datetime) -> None:
-        key = self._make_prospect_key(entry)
-        duplicate = key in self._state.prospected_seen if key is not None else False
-
-        content_level = self._extract_content_level(entry)
-        remaining = entry.get("Remaining")
-        try:
-            remaining_value = float(remaining)
-        except (TypeError, ValueError):
-            remaining_value = None
-        already_mined = remaining_value is not None and remaining_value < 100
-
-        body_value = entry.get("Body") or entry.get("BodyName")
-        if isinstance(body_value, str) and "ring" in body_value.lower():
-            self._state.mining_ring = body_value
-            self._refresh_edsm()
-
-        if self._session_recorder:
-            materials_payload = entry.get("Materials")
-            materials_iter = materials_payload if isinstance(materials_payload, list) else []
-            body_value = entry.get("Body")
-            body_name = body_value if isinstance(body_value, str) and body_value.strip() else None
-            self._session_recorder.record_prospected_asteroid(
-                event_time,
-                materials=materials_iter,
-                content_level=content_level,
-                remaining=remaining_value,
-                already_mined=already_mined,
-                duplicate=duplicate,
-                body=body_name,
-            )
-
-        if key is None:
-            _log.debug("Prospected asteroid entry missing key data: %s", entry)
-            return
-
-        if duplicate:
-            self._state.duplicate_prospected += 1
-            _log.debug("Duplicate prospected asteroid detected; ignoring for stats")
-            return
-
-        self._state.prospected_seen.add(key)
-        self._state.prospected_count += 1
-
-        if content_level:
-            self._state.prospect_content_counts[content_level] += 1
-
-        if already_mined:
-            self._state.already_mined_count += 1
-
-        materials = entry.get("Materials")
-        if isinstance(materials, list):
-            for material in materials:
-                if not isinstance(material, dict):
-                    continue
-                name_raw = material.get("Name")
-                proportion_raw = material.get("Proportion")
-                if not isinstance(name_raw, str):
-                    continue
-                try:
-                    proportion = float(proportion_raw)
-                except (TypeError, ValueError):
-                    continue
-                normalized = name_raw.lower()
-                self._state.prospected_samples.setdefault(normalized, []).append(proportion)
-
-        recompute_histograms(self._state)
-        self._emit_mining_activity("ProspectedAsteroid")
-        self._refresh_edsm()
-
-    def _register_material_collected(self, entry: dict) -> None:
-        name = entry.get("Name")
-        if not isinstance(name, str):
-            return
-        count = entry.get("Count")
-        try:
-            quantity = max(1, int(count))
-        except (TypeError, ValueError):
-            quantity = 1
-        normalized = name.lower()
-        self._state.materials_collected[normalized] += quantity
-
-    def _handle_ship_update(
-        self,
-        entry: Optional[dict],
-        shared_state: Optional[dict],
-        *,
-        context: str,
-        event_type: Optional[str],
-        event_time: datetime,
-    ) -> None:
-        ship_display: Optional[str]
-        ship_source: Optional[str]
-        capacity_value: Optional[int]
-        capacity_source: Optional[str]
-
-        key = self._make_ship_key(entry, shared_state)
-
-        if event_type == "ShipyardSwap" and key:
-            ship_display, ship_source, _, _ = self._extract_ship_and_capacity(entry, None)
-
-            if not ship_display and isinstance(entry, dict):
-                raw_localised = entry.get("ShipType_Localised")
-                if isinstance(raw_localised, str) and raw_localised.strip():
-                    ship_display = raw_localised.strip()
-                    ship_source = "journal"
-                else:
-                    raw_type = entry.get("ShipType")
-                    if isinstance(raw_type, str) and raw_type.strip():
-                        ship_display = raw_type.strip()
-                        ship_source = "journal"
-
-            self._apply_ship_state(
-                ship_display,
-                ship_source,
-                None,
-                None,
-                ship_key=key,
-                context=context,
-                entry=entry,
-                shared_state=shared_state,
-                emit_log=False,
-            )
-
-            ship_summary = ship_display or "Unknown ship"
-            _plugin_log.debug(
-                "Ship swap initiated: ship=%s, cargo_capacity=unknown (awaiting loadout)",
-                ship_summary,
-            )
-
-            self._state.cargo_capacity = None
-            self._state.cargo_capacity_is_inferred = False
-
-            self._pending_ship_updates[key] = PendingShipUpdate(
-                key=key,
-                context=context,
-                ship_display=ship_display,
-                ship_source=ship_source,
-                capacity_value=None,
-                capacity_source=None,
-                initiated_at=event_time,
-                entry=entry,
-                shared_state=shared_state,
-            )
-            _log.debug(
-                "Queued ship update for %s (%s); awaiting Loadout",
-                key,
-                context,
-            )
-            self._schedule_pending_timeout()
-            return
-
-        ship_display, ship_source, capacity_value, capacity_source = self._extract_ship_and_capacity(entry, shared_state)
-
-        if event_type == "Loadout" and key:
-            pending = self._pending_ship_updates.pop(key, None)
-            if pending:
-                elapsed = (event_time - pending.initiated_at).total_seconds()
-                _log.debug(
-                    "Loadout received for %s after %.2fs",
-                    key,
-                    max(0.0, elapsed),
-                )
-                if not ship_display:
-                    ship_display = pending.ship_display
-                    ship_source = pending.ship_source
-            self._apply_ship_state(
-                ship_display,
-                ship_source,
-                capacity_value,
-                capacity_source,
-                ship_key=key,
-                context=context,
-                entry=entry,
-                shared_state=shared_state,
-                emit_log=True,
-            )
-            if self._pending_ship_updates:
-                self._schedule_pending_timeout()
-            else:
-                self._cancel_pending_timeout()
-            return
-
-        awaiting_initial_loadout = False
-        if event_type == "InitialState" and key:
-            if capacity_value is None:
-                self._pending_ship_updates[key] = PendingShipUpdate(
-                    key=key,
-                    context=context,
-                    ship_display=ship_display,
-                    ship_source=ship_source,
-                    capacity_value=None,
-                    capacity_source=None,
-                    initiated_at=event_time,
-                    entry=entry,
-                    shared_state=shared_state,
-                )
-                _log.debug("Initial state queued for %s; awaiting Loadout", key)
-                awaiting_initial_loadout = True
-            else:
-                self._pending_ship_updates.pop(key, None)
-                self._cancel_pending_timeout()
-
-        self._apply_ship_state(
-            ship_display,
-            ship_source,
-            capacity_value,
-            capacity_source,
-            ship_key=key,
-            context=context,
-            entry=entry,
-            shared_state=shared_state,
-            emit_log=True,
-        )
-        if awaiting_initial_loadout:
-            self._schedule_pending_timeout()
-
-    def _make_ship_key(self, entry: Optional[dict], shared_state: Optional[dict]) -> Optional[str]:
-        ship_id: Optional[int] = None
-        if isinstance(entry, dict):
-            ship_id = entry.get("ShipID")
-        if ship_id is None and isinstance(shared_state, dict):
-            ship_id = shared_state.get("ShipID")
-        if isinstance(ship_id, int):
-            return f"id:{ship_id}"
-
-        ship_type: Optional[str] = None
-        if isinstance(entry, dict):
-            for key in ("Ship", "ShipType", "ShipType_Localised"):
-                value = entry.get(key)
-                if isinstance(value, str) and value.strip():
-                    ship_type = value.strip().lower()
-                    break
-        if ship_type is None and isinstance(shared_state, dict):
-            value = shared_state.get("Ship") or shared_state.get("ShipType")
-            if isinstance(value, str) and value.strip():
-                ship_type = value.strip().lower()
-        if ship_type is None:
-            return None
-        return f"type:{ship_type}"
-
-    def _schedule_pending_timeout(self) -> None:
-        if not self._pending_ship_updates:
-            self._cancel_pending_timeout()
-            return
-        duration = _PENDING_SHIP_UPDATE_TIMEOUT.total_seconds()
-        timer = self._pending_timeout_timer
-        if timer is not None:
-            timer.cancel()
-        timer = threading.Timer(duration, self._pending_timeout_tick)
-        timer.daemon = True
-        timer.start()
-        self._pending_timeout_timer = timer
-
-    def _cancel_pending_timeout(self) -> None:
-        timer = self._pending_timeout_timer
-        if timer is not None:
-            timer.cancel()
-            self._pending_timeout_timer = None
-
-    def _pending_timeout_tick(self) -> None:
-        current_time = datetime.now(timezone.utc)
-        self._flush_expired_ship_updates(current_time)
-        if self._pending_ship_updates:
-            self._schedule_pending_timeout()
-        else:
-            self._cancel_pending_timeout()
-
-    def _flush_expired_ship_updates(self, current_time: datetime) -> None:
-        expired: list[str] = []
-        for key, pending in list(self._pending_ship_updates.items()):
-            if current_time - pending.initiated_at >= _PENDING_SHIP_UPDATE_TIMEOUT:
-                elapsed = (current_time - pending.initiated_at).total_seconds()
-                _log.debug(
-                    "Ship update for %s timed out after %.2fs; emitting pending data",
-                    key,
-                    max(0.0, elapsed),
-                )
-                ship_summary = pending.ship_display or "Unknown ship"
-                self._state.current_ship = pending.ship_display
-                self._state.current_ship_key = key
-                self._state.cargo_capacity = pending.capacity_value
-                self._state.cargo_capacity_is_inferred = False
-                _plugin_log.debug(
-                    "Ship swap timeout: ship=%s, cargo_capacity=unknown (no loadout received)",
-                    ship_summary,
-                )
-                if _plugin_log is not _log:
-                    _log.debug(
-                        "Ship swap timeout for %s (no loadout received)",
-                        key,
-                    )
-                self._activate_inferred_capacity(
-                    key,
-                    reason=f"timeout ({pending.context})",
-                    force=True,
-                )
-                expired.append(key)
-        for key in expired:
-            self._pending_ship_updates.pop(key, None)
-        if not self._pending_ship_updates:
-            self._cancel_pending_timeout()
-
-    def _apply_ship_state(
-        self,
-        ship_display: Optional[str],
-        ship_source: Optional[str],
-        capacity_value: Optional[int],
-        capacity_source: Optional[str],
-        ship_key: Optional[str],
-        *,
-        context: str,
-        entry: Optional[dict],
-        shared_state: Optional[dict],
-        emit_log: bool,
-    ) -> Tuple[str, str]:
-        ship_before = self._state.current_ship
-        capacity_before = self._state.cargo_capacity
-        if ship_key is not None:
-            self._state.current_ship_key = ship_key
-
-        normalized_before = ship_before.lower() if isinstance(ship_before, str) else None
-        normalized_incoming = ship_display.lower() if isinstance(ship_display, str) else None
-
-        ship_changed = False
-        if ship_display:
-            if (
-                ship_source != "shared_state"
-                or self._state.current_ship is None
-                or normalized_before != normalized_incoming
-            ):
-                ship_changed = normalized_before != normalized_incoming
-                self._state.current_ship = ship_display
-        else:
-            if self._state.current_ship is not None:
-                ship_changed = True
-                self._state.current_ship = None
-
-        if capacity_value is not None:
-            should_apply_capacity = (
-                capacity_source != "shared_state"
-                or self._state.cargo_capacity is None
-                or ship_changed
-            )
-            inferred_reason = f"{context} ({capacity_source or 'unknown'})"
-            self._update_inferred_capacity(
-                self._state.current_ship_key,
-                capacity_value,
-                reason=inferred_reason,
-                activate=False,
-            )
-            if should_apply_capacity:
-                self._state.cargo_capacity = capacity_value
-                self._state.cargo_capacity_is_inferred = False
-        elif ship_changed:
-            self._state.cargo_capacity = None
-            self._state.cargo_capacity_is_inferred = False
-
-        ship_summary = self._state.current_ship or "Unknown ship (no data provided)"
-        if capacity_value is not None and (
-            capacity_source != "shared_state"
-            or capacity_before is None
-            or ship_changed
-        ):
-            capacity_origin = capacity_source or "unknown"
-            capacity_summary = f"{self._state.cargo_capacity}t (source={capacity_origin})"
-        elif self._state.cargo_capacity is not None:
-            if self._state.cargo_capacity_is_inferred:
-                capacity_summary = f"({self._state.cargo_capacity}t inferred)"
-            else:
-                capacity_summary = f"{self._state.cargo_capacity}t (existing)"
-        else:
-            capacity_origin = capacity_source or ("cleared" if ship_changed else "not provided")
-            capacity_summary = f"unknown (capacity {capacity_origin})"
-
-        if emit_log:
-            _plugin_log.info(
-                "%s: ship=%s, cargo_capacity=%s",
-                context,
-                ship_summary,
-                capacity_summary,
-            )
-        if _plugin_log is not _log:
-            _log.debug(
-                "%s details: ship=%s ship_source=%s capacity=%s capacity_source=%s entry=%s shared_state=%s",
-                context,
-                ship_display,
-                ship_source,
-                capacity_value,
-                capacity_source,
-                entry,
-                shared_state,
-            )
-
-        return ship_summary, capacity_summary
-
-    def _extract_ship_and_capacity(
-        self,
-        entry: Optional[dict],
-        shared_state: Optional[dict],
-    ) -> Tuple[Optional[str], Optional[str], Optional[int], Optional[str]]:
-        capacity_value: Optional[int] = None
-        capacity_source: Optional[str] = None
-
-        def coerce_capacity(source: Optional[dict], label: str) -> None:
-            nonlocal capacity_value, capacity_source
-            if capacity_value is not None or not isinstance(source, dict):
-                return
-            try:
-                raw = source.get("CargoCapacity")
-            except Exception:
-                raw = None
-            if isinstance(raw, (int, float)) and raw >= 0:
-                capacity_value = int(raw)
-                capacity_source = label
-
-        coerce_capacity(entry, "journal")
-        coerce_capacity(shared_state, "shared_state")
-
-        entry_state: dict[str, Any] = {}
-        if isinstance(entry, dict):
-            for key in (
-                "ShipName",
-                "ShipLocalised",
-                "Ship_Localised",
-                "Ship",
-                "ShipType",
-                "ShipType_Localised",
-            ):
-                value = entry.get(key)
-                if isinstance(value, str) and value.strip():
-                    entry_state[key] = value.strip()
-
-        shared_state_normalized: dict[str, Any] = {}
-        if isinstance(shared_state, dict):
-            for key in (
-                "ShipName",
-                "ShipLocalised",
-                "Ship_Localised",
-                "Ship",
-                "ShipType",
-                "ShipType_Localised",
-            ):
-                value = shared_state.get(key) if isinstance(shared_state, dict) else None
-                if isinstance(value, str) and value.strip():
-                    shared_state_normalized[key] = value.strip()
-
-        ship_display = None
-        ship_source = None
-        if entry_state:
-            ship_display = self._resolve_ship_name(entry_state)
-            if ship_display:
-                ship_source = "journal"
-        if ship_display is None and shared_state_normalized:
-            ship_display = self._resolve_ship_name(shared_state_normalized)
-            if ship_display:
-                ship_source = "shared_state"
-        if ship_display is None and isinstance(entry, dict):
-            for key in ("ShipType_Localised", "ShipType", "Ship"):
-                value = entry.get(key)
-                if isinstance(value, str) and value.strip():
-                    ship_display = value.strip()
-                    ship_source = "fallback"
-                    break
-
-        return ship_display, ship_source, capacity_value, capacity_source
-
-    def _process_cargo(
-        self,
-        entry: dict,
-        edmc_state: Optional[dict],
-        *,
-        is_mining: bool,
-        event_time: datetime,
-    ) -> None:
-        inventory = entry.get("Inventory")
-        if not isinstance(inventory, list):
-            return
-
-        entry_count_raw = entry.get("Count")
-        try:
-            cargo_event_count = int(entry_count_raw) if entry_count_raw is not None else None
-        except (TypeError, ValueError):
-            cargo_event_count = None
-
-        cargo_counts: dict[str, int] = {}
-        limpets = None
-        for item in inventory:
-            if not isinstance(item, dict):
-                continue
-            raw_name = item.get("Name")
-            count = item.get("Count")
-            if not isinstance(raw_name, str) or not isinstance(count, int):
-                continue
-            normalized = raw_name.lower()
-            cargo_counts[normalized] = count
-            localized_name = item.get("Name_Localised")
-            display_name = self._select_display_name(localized_name, raw_name)
-            self._state.commodity_display_names[normalized] = display_name
-            if normalized == "drones":
-                limpets = count
-
-        previous_limpets = self._state.limpets_remaining
-        if limpets is not None:
-            if not self._state.limpets_start_initialized:
-                self._state.limpets_start = limpets
-                self._state.limpets_start_initialized = True
-            self._state.limpets_remaining = limpets
-
-        total_cargo = sum(count for commodity, count in cargo_counts.items() if commodity != "drones")
-        self._state.current_cargo_tonnage = total_cargo
-
-        capacity_value: Optional[int] = None
-        capacity_source: Optional[str] = None
-        if edmc_state:
-            raw_capacity = edmc_state.get("CargoCapacity")
-            if isinstance(raw_capacity, (int, float)) and raw_capacity >= 0:
-                capacity_value = int(raw_capacity)
-                capacity_source = "shared_state"
-        if capacity_value is None:
-            raw_capacity = entry.get("Capacity")
-            if isinstance(raw_capacity, (int, float)) and raw_capacity >= 0:
-                capacity_value = int(raw_capacity)
-                capacity_source = "journal"
-
-        ship_key = self._state.current_ship_key
-        if ship_key is None:
-            ship_key = self._make_ship_key(entry, edmc_state)
-            if ship_key is not None:
-                self._state.current_ship_key = ship_key
-        if capacity_value is not None and capacity_value > 0:
-            self._update_inferred_capacity(
-                ship_key,
-                capacity_value,
-                reason=f"Cargo event ({capacity_source or 'unknown'})",
-                activate=False,
-            )
-            should_apply = (
-                capacity_source != "shared_state"
-                or self._state.cargo_capacity is None
-                or self._state.cargo_capacity_is_inferred
-            )
-            if should_apply:
-                self._state.cargo_capacity = capacity_value
-                self._state.cargo_capacity_is_inferred = False
-        else:
-            limpets_onboard = (
-                limpets
-                if limpets is not None
-                else (self._state.limpets_remaining if self._state.limpets_remaining is not None else 0)
-            )
-            observed_total = max(0, total_cargo) + max(0, limpets_onboard)
-            if observed_total > 0:
-                self._update_inferred_capacity(
-                    ship_key,
-                    observed_total,
-                    reason=f"Cargo event observed cargo ({observed_total}t)",
-                    activate=True,
-                )
-            else:
-                self._activate_inferred_capacity(
-                    ship_key,
-                    reason="Cargo event (no capacity data)",
-                )
-
-        if _log.isEnabledFor(logging.DEBUG):
-            _log.debug(
-                "Cargo update: total=%st capacity=%s (source=%s)",
-                self._state.current_cargo_tonnage,
-                self._state.cargo_capacity,
-                "inferred"
-                if self._state.cargo_capacity_is_inferred
-                else (
-                    "shared"
-                    if edmc_state and edmc_state.get("CargoCapacity") is not None
-                    else capacity_source or "journal"
-                ),
-            )
-
-        if not is_mining:
-            self._state.last_cargo_counts = dict(cargo_counts)
-            return
-
-        if not self._state.last_cargo_counts:
-            self._state.last_cargo_counts = dict(cargo_counts)
-            return
-
-        additions_made = False
-        for name, count in cargo_counts.items():
-            if name == "drones":
-                continue
-            prev = self._state.last_cargo_counts.get(name, 0)
-            increment = count - prev
-            if increment > 0:
-                additions_made = True
-                new_total = self._state.cargo_additions.get(name, 0) + increment
-                self._state.cargo_additions[name] = new_total
-                self._state.cargo_totals[name] = new_total
-                self._state.harvested_commodities.add(name)
-                if name not in self._state.commodity_start_times:
-                    timestamp = self._parse_timestamp(entry.get("timestamp"))
-                    self._state.commodity_start_times[name] = timestamp or datetime.now(timezone.utc)
-
-        self._state.cargo_additions = {k: v for k, v in self._state.cargo_additions.items() if v > 0}
-        self._state.cargo_totals = dict(self._state.cargo_additions)
-        valid_keys = set(self._state.cargo_totals)
-        self._state.commodity_display_names = {
-            key: value for key, value in self._state.commodity_display_names.items() if key in valid_keys
-        }
-
-        if self._state.limpets_start is not None and self._state.limpets_remaining is not None:
-            launched = self._state.prospector_launched_count + self._state.collection_drones_launched - 1
-            abandoned = self._state.limpets_start - self._state.limpets_remaining - launched
-            self._state.abandoned_limpets = max(0, abandoned)
-
-        if additions_made or (
-            limpets is not None and previous_limpets is not None and limpets != previous_limpets
-        ):
-            self._refresh_ui()
-
-        self._state.last_cargo_counts = dict(cargo_counts)
-        if self._session_recorder:
-                self._session_recorder.record_cargo_event(
-                    event_time,
-                    total_cargo=total_cargo,
-                    inventory=dict(cargo_counts),
-                    limpets=limpets,
-                    event_count=cargo_event_count,
-                )
-        self._emit_mining_activity("Cargo")
-
-    # ------------------------------------------------------------------
-    # Inferred capacity helpers
-    # ------------------------------------------------------------------
-    def _update_inferred_capacity(
-        self,
-        ship_key: Optional[str],
-        candidate: Optional[int],
-        *,
-        reason: str,
-        activate: bool,
-    ) -> None:
-        if ship_key is None or candidate is None:
-            return
-        try:
-            capacity = int(candidate)
-        except (TypeError, ValueError):
-            return
-        if capacity <= 0:
-            return
-
-        prior = self._state.inferred_capacity_map.get(ship_key)
-        changed = prior is None or capacity > prior
-        if changed:
-            self._state.inferred_capacity_map[ship_key] = capacity
-            _plugin_log.debug(
-                "Inferred cargo capacity updated: ship_key=%s capacity=%st (reason=%s)",
-                ship_key,
-                capacity,
-                reason,
-            )
-            if _plugin_log is not _log:
-                _log.debug(
-                    "Inferred cargo capacity updated: ship_key=%s capacity=%s reason=%s prior=%s",
-                    ship_key,
-                    capacity,
-                    reason,
-                    prior,
-                )
-            try:
-                self._persist_inferred_capacities()
-            except Exception:
-                _log.exception("Unable to persist inferred cargo capacities")
-
-        if activate:
-            self._activate_inferred_capacity(ship_key, reason, force=changed)
-
-    def _activate_inferred_capacity(
-        self,
-        ship_key: Optional[str],
-        reason: str,
-        *,
-        force: bool = False,
-    ) -> None:
-        if ship_key is None:
-            return
-        _plugin_log.debug(
-            "Inference requested: ship_key=%s (reason=%s)",
-            ship_key,
-            reason,
-        )
-        if _plugin_log is not _log:
-            _log.debug(
-                "Inference requested: ship_key=%s reason=%s",
-                ship_key,
-                reason,
-            )
-        inferred = self._state.inferred_capacity_map.get(ship_key)
-        if inferred is None or inferred <= 0:
-            _plugin_log.debug(
-                "No stored inferred cargo capacity for ship_key=%s; skipping",
-                ship_key,
-            )
-            if _plugin_log is not _log:
-                _log.debug(
-                    "No stored inferred cargo capacity for ship_key=%s",
-                    ship_key,
-                )
-            return
-        if not self._state.cargo_capacity_is_inferred and self._state.cargo_capacity is not None:
-            _plugin_log.debug(
-                "Actual cargo capacity present; inference skipped for ship_key=%s",
-                ship_key,
-            )
-            if _plugin_log is not _log:
-                _log.debug(
-                    "Actual cargo capacity present; inference skipped for ship_key=%s",
-                    ship_key,
-                )
-            return
-
-        already_active = (
-            self._state.cargo_capacity_is_inferred
-            and self._state.cargo_capacity == inferred
-        )
-        if already_active and not force:
-            return
-
-        _plugin_log.debug(
-            "Inferring cargo capacity for ship_key=%s (reason=%s)",
-            ship_key,
-            reason,
-        )
-        if _plugin_log is not _log:
-            _log.debug(
-                "Inferring cargo capacity for ship_key=%s reason=%s",
-                ship_key,
-                reason,
-            )
-
-        self._state.cargo_capacity = inferred
-        self._state.cargo_capacity_is_inferred = True
-        _plugin_log.debug(
-            "Applied inferred cargo capacity: ship_key=%s capacity=%st (reason=%s)",
-            ship_key,
-            inferred,
-            reason,
-        )
-        if _plugin_log is not _log:
-            _log.debug(
-                "Applied inferred cargo capacity: ship_key=%s capacity=%s reason=%s",
-                ship_key,
-                inferred,
-                reason,
-            )
-        self._refresh_ui()
-
-    def _emit_mining_activity(self, reason: str) -> None:
-        callback = getattr(self, "_notify_mining_activity", None)
-        if not callback:
-            return
-        try:
-            callback(reason)
-        except Exception:
-            _log.exception("Failed to notify mining activity (%s)", reason)
-
-    # ------------------------------------------------------------------
-    # Mining session helpers
-    # ------------------------------------------------------------------
-    def _update_mining_state(
-        self,
-        active: bool,
-        reason: str,
-        timestamp: Optional[str],
-        state: Optional[dict] = None,
-        entry: Optional[dict] = None,
-    ) -> None:
-        if self._state.is_mining == active:
-            return
-
-        if active:
-            ship_display, ship_source, capacity_value, capacity_source = self._extract_ship_and_capacity(entry, state)
-            existing_ship = self._state.current_ship
-            existing_capacity = self._state.cargo_capacity
-            existing_ship_key = self._state.current_ship_key
-            existing_capacity_inferred = self._state.cargo_capacity_is_inferred
-            ship_key = self._make_ship_key(entry, state)
-
-            normalized_existing = existing_ship.lower() if isinstance(existing_ship, str) else None
-            normalized_incoming = ship_display.lower() if isinstance(ship_display, str) else None
-            ship_changed = False
-
-            ship_to_use = existing_ship
-            if ship_display:
-                if (
-                    ship_source != "shared_state"
-                    or existing_ship is None
-                    or normalized_existing != normalized_incoming
-                ):
-                    ship_changed = normalized_existing != normalized_incoming
-                    ship_to_use = ship_display
-            capacity_to_use = existing_capacity
-            if capacity_value is not None:
-                if (
-                    capacity_source != "shared_state"
-                    or existing_capacity is None
-                    or ship_changed
-                ):
-                    capacity_to_use = capacity_value
-            elif ship_changed:
-                capacity_to_use = None
-
-            start_time = self._parse_timestamp(timestamp) or datetime.now(timezone.utc)
-            reset_mining_state(self._state)
-            self._state.is_mining = True
-            self._state.mining_start = start_time
-            self._state.mining_end = None
-            self._state.mining_location = self._detect_current_location(state or entry)
-            system_name = self._detect_current_system(state or entry)
-            if system_name:
-                self._set_current_system(system_name)
-            self._refresh_edsm()
-
-            self._state.current_ship = ship_to_use
-            self._state.current_ship_key = ship_key or existing_ship_key
-            self._state.cargo_capacity = capacity_to_use
-            if capacity_to_use is not None:
-                if capacity_value is not None and capacity_to_use > 0:
-                    self._state.cargo_capacity_is_inferred = False
-                    self._update_inferred_capacity(
-                        self._state.current_ship_key,
-                        capacity_to_use,
-                        reason="Mining start provided capacity",
-                        activate=False,
-                    )
-                else:
-                    self._state.cargo_capacity_is_inferred = bool(existing_capacity_inferred)
-                    if existing_capacity_inferred:
-                        self._update_inferred_capacity(
-                            self._state.current_ship_key,
-                            capacity_to_use,
-                            reason="Mining start inferred capacity",
-                            activate=False,
-                        )
-            else:
-                self._state.cargo_capacity_is_inferred = False
-
-            _plugin_log.info("Mining start event triggered (reason=%s)", reason)
-            if _plugin_log is not _log:
-                _log.debug(
-                    "Mining start event logged via plugin logger (reason=%s, entry=%s, shared_state=%s)",
-                    reason,
-                    entry,
-                    state,
-                )
-
-            ship_summary = ship_to_use or "Unknown ship (ship data unavailable)"
-            if capacity_to_use is not None:
-                if capacity_value is not None and (
-                    capacity_source != "shared_state" or existing_capacity is None or ship_changed
-                ):
-                    capacity_origin = capacity_source or "unknown"
-                elif existing_capacity is not None:
-                    capacity_origin = "previous"
-                else:
-                    capacity_origin = "unknown"
-                capacity_summary = f"{capacity_to_use}t (source={capacity_origin})"
-            else:
-                capacity_origin = capacity_source or ("cleared" if ship_changed else "not provided")
-                capacity_summary = f"unknown (capacity {capacity_origin})"
-
-            _plugin_log.info(
-                "Mining started: ship=%s, cargo_capacity=%s",
-                ship_summary,
-                capacity_summary,
-            )
-            if _plugin_log is not _log:
-                _log.debug(
-                    "Mining started log dispatched: ship=%s, cargo_capacity=%s",
-                    ship_summary,
-                    capacity_summary,
-                )
-
-            if self._session_recorder and start_time is not None:
-                self._session_recorder.start_session(start_time, reason=reason)
-
-            self._on_session_start()
-            if self._state.mining_start:
-                _plugin_log.info(
-                    "Mining started at %s (location=%s) - reason: %s",
-                    self._state.mining_start.isoformat(),
-                    self._state.mining_location,
-                    reason,
-                )
-                if _plugin_log is not _log:
-                    _log.debug(
-                        "Mining start details logged: time=%s location=%s reason=%s",
-                        self._state.mining_start.isoformat(),
-                        self._state.mining_location,
-                        reason,
-                    )
-        else:
-            self._state.is_mining = False
-            self._state.mining_end = self._parse_timestamp(timestamp) or datetime.now(timezone.utc)
-            system_name = self._detect_current_system(state)
-            if system_name:
-                self._set_current_system(system_name)
-        if self._session_recorder and self._state.mining_end is not None:
-            self._session_recorder.end_session(self._state.mining_end, reason=reason)
-        self._on_session_end()
-
-        _log.info("Mining state changed to %s (%s)", "active" if active else "inactive", reason)
-        self._refresh_edsm()
-
-    # ------------------------------------------------------------------
-    # Utility helpers
-    # ------------------------------------------------------------------
-    def _set_current_system(self, value: Optional[str]) -> None:
-        normalized = str(value).strip() if value else None
-        if normalized == "":
-            normalized = None
-        self._state.current_system = normalized
-
-    def _detect_current_location(self, state: Optional[dict]) -> Optional[str]:
-        if not state:
-            return None
-        try:
-            body = state.get("Body")
-            if body:
-                if isinstance(body, str) and "ring" in body.lower():
-                    self._state.mining_ring = str(body)
-                    self._refresh_edsm()
-                return str(body)
-        except Exception:
-            pass
-        try:
-            system = state.get("System") or state.get("SystemName") or state.get("StarSystem")
-            if system:
-                return str(system)
-        except Exception:
-            pass
-        return None
-
-    @staticmethod
-    def _detect_current_system(state: Optional[dict]) -> Optional[str]:
-        if not state:
-            return None
-        for key in ("System", "SystemName", "StarSystem"):
-            try:
-                value = state.get(key)
-            except Exception:
-                value = None
-            if value:
-                return str(value)
-        return None
-
-    def _refresh_edsm(self) -> None:
-        if not self._edsm:
-            return
-        self._edsm.refresh(
-            system=self._state.current_system,
-            ring_name=self._state.mining_ring,
-        )
-
-    def _resolve_ship_name(self, state: Optional[dict]) -> Optional[str]:
-        if not state:
-            return None
-        try:
-            ship_name = state.get("ShipName")
-            if isinstance(ship_name, str) and ship_name.strip():
-                return ship_name.strip()
-        except Exception:
-            pass
-        try:
-            ship_localised = state.get("ShipLocalised")
-            if isinstance(ship_localised, str) and ship_localised.strip():
-                return ship_localised.strip()
-        except Exception:
-            pass
-        ship_type = None
-        for key in ("Ship", "ShipType"):
-            try:
-                value = state.get(key)
-            except Exception:
-                value = None
-            if isinstance(value, str) and value.strip():
-                ship_type = value.strip()
-                break
-        if not ship_type:
-            return None
-        lookup_key = ship_type.lower()
-        mapped = ship_name_map.get(lookup_key) or ship_name_map.get(ship_type)
-        return mapped or ship_type
-
-    @staticmethod
-    def _parse_timestamp(value: Optional[str]) -> Optional[datetime]:
-        if not value:
-            return None
-        try:
-            if value.endswith("Z"):
-                value = value[:-1] + "+00:00"
-            parsed = datetime.fromisoformat(value)
-            if parsed.tzinfo is None:
-                parsed = parsed.replace(tzinfo=timezone.utc)
-            return parsed
-        except Exception:
-            _log.debug("Unable to parse timestamp: %s", value)
-            return None
-
-    @staticmethod
-    def _ensure_aware(value: datetime) -> datetime:
-        if value.tzinfo is None:
-            return value.replace(tzinfo=timezone.utc)
-        return value
-
-    def _make_prospect_key(self, entry: dict) -> Optional[Tuple[str, Tuple[Tuple[str, float], ...]]]:
-        materials = entry.get("Materials")
-        if not isinstance(materials, list):
-            return None
-
-        items: list[Tuple[str, float]] = []
-        for material in materials:
-            if not isinstance(material, dict):
-                continue
-            name_raw = material.get("Name")
-            proportion_raw = material.get("Proportion")
-            if not isinstance(name_raw, str):
-                continue
-            try:
-                proportion = float(proportion_raw)
-            except (TypeError, ValueError):
-                continue
-            items.append((name_raw.lower(), round(proportion, 4)))
-
-        if not items:
-            return None
-
-        items.sort()
-        body = entry.get("Body")
-        body_component = str(body) if isinstance(body, str) else ""
-        content = str(entry.get("Content", ""))
-        content_localised = str(entry.get("Content_Localised", ""))
-        return ("|".join(filter(None, (body_component, content, content_localised))), tuple(items))
-
-    @staticmethod
-    def _extract_content_level(entry: dict) -> Optional[str]:
-        for key in ("Content_Localised", "Content"):
-            value = entry.get(key)
-            if not value:
-                continue
-            text = str(value).lower()
-            if "high" in text:
-                return "High"
-            if "medium" in text:
-                return "Medium"
-            if "low" in text:
-                return "Low"
-        return None
-
-    def _serialize_histogram(self) -> dict[str, dict[str, int]]:
-        serialized: dict[str, dict[str, int]] = {}
-        harvested = self._state.harvested_commodities
-        if not harvested:
-            return serialized
-        for material, counter in self._state.prospected_histogram.items():
-            if material not in harvested or not counter:
-                continue
-            size = max(1, self._state.histogram_bin_size)
-            labels = {
-                self._format_bin_label(bin_index, size): count
-                for bin_index, count in sorted(counter.items())
-                if count > 0
-            }
-            serialized[self._format_cargo_name(material)] = labels
-        return serialized
-
-    def _serialize_tph(self) -> dict[str, float]:
-        data: dict[str, float] = {}
-        for commodity in self._state.cargo_additions:
-            rate = self._compute_tph(commodity)
-            if rate is None:
-                continue
-            data[self._format_cargo_name(commodity)] = round(rate, 3)
-        return data
-
-    def _compute_total_tph(self) -> Optional[float]:
-        if not self._state.mining_start:
-            return None
-        total_amount = sum(amount for amount in self._state.cargo_additions.values() if amount > 0)
-        if total_amount <= 0:
-            return None
-        start_time = self._ensure_aware(self._state.mining_start)
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        elapsed_hours = (end_time - start_time).total_seconds() / 3600.0
-        if elapsed_hours <= 0:
-            return None
-        return total_amount / elapsed_hours
-
-    def _compute_tph(self, commodity: str) -> Optional[float]:
-        start = self._state.commodity_start_times.get(commodity)
-        if not start:
-            return None
-        start = self._ensure_aware(start)
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        elapsed_hours = (end_time - start).total_seconds() / 3600.0
-        if elapsed_hours <= 0:
-            return None
-        amount = self._state.cargo_additions.get(commodity, 0)
-        if amount <= 0:
-            return None
-        return amount / elapsed_hours
-
-    def _format_cargo_name(self, name: str) -> str:
-        key = str(name or "").lower()
-        display = self._state.commodity_display_names.get(key)
-        if display:
-            return display
-        return str(name or "").replace("_", " ").title()
-
-    @staticmethod
-    def _select_display_name(localized: Any, fallback: str) -> str:
-        if isinstance(localized, str):
-            candidate = localized.strip()
-            if candidate:
-                return candidate
-        text = str(fallback or "")
-        return text.replace("_", " ").title()
-
-    @staticmethod
-    def _format_bin_label(bin_index: int, size: int) -> str:
-        start = bin_index * size
-        end = min(start + size, 100)
-        return f"{int(start)}-{int(end)}%"
diff --git a/load.py b/load.py
index 82a2f67..25573d8 100644
--- a/load.py
+++ b/load.py
@@ -16,7 +16,7 @@ try:
 except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
     raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
 
-from plugin import MiningAnalyticsPlugin
+from edmc_mining_analytics import MiningAnalyticsPlugin
 
 _plugin = MiningAnalyticsPlugin()
 
diff --git a/logging_utils.py b/logging_utils.py
deleted file mode 100644
index b0e0efa..0000000
--- a/logging_utils.py
+++ /dev/null
@@ -1,36 +0,0 @@
-"""Helper utilities to integrate with EDMC's logging system."""
-
-from __future__ import annotations
-
-import logging
-from pathlib import Path
-
-PLUGIN_FOLDER_NAME = Path(__file__).resolve().parent.name
-
-try:  # pragma: no cover - only available when running inside EDMC
-    from EDMCLogging import get_plugin_logger  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    get_plugin_logger = None  # type: ignore[assignment]
-
-if get_plugin_logger is not None:
-    BASE_LOGGER = get_plugin_logger(PLUGIN_FOLDER_NAME)
-else:
-    BASE_LOGGER = logging.getLogger(PLUGIN_FOLDER_NAME)
-    BASE_LOGGER.propagate = True
-
-
-def get_logger(suffix: str | None = None) -> logging.Logger:
-    """Return the shared plugin logger or one of its children."""
-
-    if suffix is None:
-        return BASE_LOGGER
-    logger = BASE_LOGGER.getChild(suffix)
-    logger.propagate = True
-    logger.setLevel(logging.NOTSET)
-    return logger
-
-
-def set_log_level(level: int) -> None:
-    """Update the base logger level (and implicitly its children)."""
-
-    BASE_LOGGER.setLevel(level)
diff --git a/mining_analytics_ui.py b/mining_analytics_ui.py
deleted file mode 100644
index eeaa5b9..0000000
--- a/mining_analytics_ui.py
+++ /dev/null
@@ -1,3 +0,0 @@
-from mining_ui.main_mining_ui import edmcmaMiningUI
-
-__all__ = ["edmcmaMiningUI"]
diff --git a/mining_ui/__init__.py b/mining_ui/__init__.py
deleted file mode 100644
index 85088c7..0000000
--- a/mining_ui/__init__.py
+++ /dev/null
@@ -1,5 +0,0 @@
-"""UI package for EDMC Mining Analytics."""
-
-from .main_mining_ui import edmcmaMiningUI
-
-__all__ = ["edmcmaMiningUI"]
diff --git a/mining_ui/components/__init__.py b/mining_ui/components/__init__.py
deleted file mode 100644
index 29ce6be..0000000
--- a/mining_ui/components/__init__.py
+++ /dev/null
@@ -1,7 +0,0 @@
-"""Reusable widget builders for the mining UI."""
-
-from __future__ import annotations
-
-from . import top_bar, details_bar, commodities_table
-
-__all__ = ["top_bar", "details_bar", "commodities_table"]
diff --git a/mining_ui/components/commodities_table.py b/mining_ui/components/commodities_table.py
deleted file mode 100644
index 1fc685f..0000000
--- a/mining_ui/components/commodities_table.py
+++ /dev/null
@@ -1,84 +0,0 @@
-from __future__ import annotations
-
-from dataclasses import dataclass, field
-from typing import Any, Callable, Dict, List, Sequence
-
-import tkinter as tk
-
-from mining_ui.theme_adapter import ThemeAdapter
-
-
-@dataclass
-class CommoditiesWidgets:
-    header_frame: tk.Frame
-    toggle_var: tk.BooleanVar
-    toggle: tk.Checkbutton
-    table_frame: tk.Frame
-    grid_config: Dict[str, Any]
-    headers: List[tk.Label] = field(default_factory=list)
-
-
-def build_commodities_section(
-    parent: tk.Widget,
-    theme: ThemeAdapter,
-    *,
-    columns: Sequence[Dict[str, Any]],
-    on_toggle: Callable[[], None],
-    header_style: Callable[[tk.Label], None],
-    initial_visible: bool,
-) -> CommoditiesWidgets:
-    header_frame = tk.Frame(parent, highlightthickness=0, bd=0)
-    header_frame.grid(row=3, column=0, sticky="w", padx=4)
-    theme.register(header_frame)
-
-    title = tk.Label(
-        header_frame,
-        text="Mined Commodities",
-        font=(None, 9, "bold"),
-        anchor="w",
-    )
-    title.pack(side="left")
-    theme.register(title)
-
-    toggle_var = tk.BooleanVar(master=parent, value=initial_visible)
-    toggle = tk.Checkbutton(
-        header_frame,
-        variable=toggle_var,
-        command=on_toggle,
-    )
-    toggle.pack(side="left", padx=(6, 0))
-    theme.register(toggle)
-    theme.style_checkbox(toggle)
-
-    table_frame = tk.Frame(parent, highlightthickness=0, bd=0)
-    grid_config = {
-        "row": 4,
-        "column": 0,
-        "sticky": "nsew",
-        "padx": 4,
-        "pady": (2, 6),
-    }
-    table_frame.grid(**grid_config)
-    theme.register(table_frame)
-
-    headers: List[tk.Label] = []
-    for idx, column in enumerate(columns):
-        table_frame.columnconfigure(idx, weight=column.get("weight", 1))
-        header = tk.Label(
-            table_frame,
-            text=column["label"],
-            anchor=column["anchor"],
-        )
-        header.grid(row=0, column=idx, sticky=column["sticky"], padx=(0, 6), pady=(0, 2))
-        theme.register(header)
-        header_style(header)
-        headers.append(header)
-
-    return CommoditiesWidgets(
-        header_frame=header_frame,
-        toggle_var=toggle_var,
-        toggle=toggle,
-        table_frame=table_frame,
-        grid_config=grid_config,
-        headers=headers,
-    )
diff --git a/mining_ui/components/details_bar.py b/mining_ui/components/details_bar.py
deleted file mode 100644
index 3d98fde..0000000
--- a/mining_ui/components/details_bar.py
+++ /dev/null
@@ -1,98 +0,0 @@
-from __future__ import annotations
-
-from dataclasses import dataclass
-from typing import Callable, Optional
-
-import tkinter as tk
-import tkinter.font as tkfont
-
-from tooltip import WidgetTooltip
-from mining_ui.theme_adapter import ThemeAdapter
-
-
-@dataclass
-class DetailsBarWidgets:
-    frame: tk.Frame
-    summary_var: tk.StringVar
-    summary_label: tk.Label
-    summary_tooltip: WidgetTooltip
-    rpm_frame: tk.Frame
-    rpm_var: tk.StringVar
-    rpm_label: tk.Label
-    rpm_title_label: tk.Label
-    rpm_tooltip: WidgetTooltip
-    rpm_font: Optional[tkfont.Font]
-
-
-def build_details_bar(
-    parent: tk.Widget,
-    theme: ThemeAdapter,
-    *,
-    border: int,
-    relief: str,
-    hover_predicate: Callable[[tk.Widget, int, int], bool],
-) -> DetailsBarWidgets:
-    details_bar = tk.Frame(parent, highlightthickness=border, bd=border, relief=relief)
-    details_bar.grid(row=1, column=0, sticky="ew", padx=4, pady=(0, 6))
-    details_bar.columnconfigure(0, weight=1)
-    theme.register(details_bar)
-
-    summary_var = tk.StringVar(master=details_bar, value="")
-    summary_label = tk.Label(
-        details_bar,
-        textvariable=summary_var,
-        justify="left",
-        anchor="w",
-    )
-    summary_label.grid(row=0, column=0, sticky="ew")
-    theme.register(summary_label)
-    summary_tooltip = WidgetTooltip(
-        summary_label,
-        hover_predicate=hover_predicate,
-    )
-
-    rpm_frame = tk.Frame(
-        details_bar,
-        highlightthickness=border,
-        bd=border if border else 0,
-        relief=relief if border else tk.FLAT,
-    )
-    rpm_frame.grid(row=0, column=1, sticky="e", padx=(8, 0))
-    theme.register(rpm_frame)
-    rpm_frame.columnconfigure(0, weight=1)
-
-    rpm_var = tk.StringVar(master=rpm_frame, value="0.0")
-    rpm_value = tk.Label(
-        rpm_frame,
-        textvariable=rpm_var,
-        anchor="center",
-        justify="center",
-    )
-    rpm_font: Optional[tkfont.Font] = None
-    try:
-        base_font = tkfont.nametofont(rpm_value.cget("font"))
-        rpm_font = tkfont.Font(font=base_font)
-        rpm_font.configure(size=max(18, int(base_font.cget("size")) + 8), weight="bold")
-        rpm_value.configure(font=rpm_font)
-    except tk.TclError:
-        rpm_font = None
-    rpm_value.grid(row=0, column=0, sticky="ew")
-    theme.register(rpm_value)
-
-    rpm_title = tk.Label(rpm_frame, text="RPM", anchor="center")
-    rpm_title.grid(row=1, column=0, sticky="ew", pady=(2, 0))
-    theme.register(rpm_title)
-    rpm_tooltip = WidgetTooltip(rpm_title)
-
-    return DetailsBarWidgets(
-        frame=details_bar,
-        summary_var=summary_var,
-        summary_label=summary_label,
-        summary_tooltip=summary_tooltip,
-        rpm_frame=rpm_frame,
-        rpm_var=rpm_var,
-        rpm_label=rpm_value,
-        rpm_title_label=rpm_title,
-        rpm_tooltip=rpm_tooltip,
-        rpm_font=rpm_font,
-    )
diff --git a/mining_ui/components/top_bar.py b/mining_ui/components/top_bar.py
deleted file mode 100644
index 23adaea..0000000
--- a/mining_ui/components/top_bar.py
+++ /dev/null
@@ -1,180 +0,0 @@
-from __future__ import annotations
-
-from dataclasses import dataclass
-from pathlib import Path
-from typing import Callable, Optional
-
-import tkinter as tk
-import tkinter.font as tkfont
-
-from tooltip import WidgetTooltip
-from mining_ui.theme_adapter import ThemeAdapter
-
-
-@dataclass
-class TopBarWidgets:
-    frame: tk.Frame
-    reserve_line: tk.Frame
-    status_var: tk.StringVar
-    reserve_var: tk.StringVar
-    reserve_label: tk.Label
-    reserve_warning_label: tk.Label
-    version_label: tk.Label
-    version_font: Optional[tkfont.Font]
-    hotspot_button: tk.Button
-    hotspot_icon: Optional[tk.PhotoImage]
-    hotspot_tooltip: WidgetTooltip
-    details_toggle: tk.Button
-
-
-def build_top_bar(
-    parent: tk.Widget,
-    theme: ThemeAdapter,
-    *,
-    border: int,
-    relief: str,
-    plugin_dir: Optional[Path],
-    repo_url: str,
-    version_text: str,
-    on_hotspot: Callable[[], None],
-    on_toggle_details: Callable[[], None],
-    warning_color: str,
-) -> TopBarWidgets:
-    top_bar = tk.Frame(parent, highlightthickness=border, bd=border, relief=relief)
-    top_bar.grid(row=0, column=0, sticky="ew", padx=4, pady=(4, 2))
-    top_bar.columnconfigure(0, weight=1)
-    theme.register(top_bar)
-
-    status_container = tk.Frame(top_bar, highlightthickness=border, bd=border, relief=relief)
-    status_container.grid(row=0, column=0, sticky="ew")
-    status_container.columnconfigure(0, weight=1)
-    theme.register(status_container)
-
-    status_var = tk.StringVar(master=status_container, value="Not mining")
-    status_label = tk.Label(
-        status_container,
-        textvariable=status_var,
-        justify="left",
-        anchor="w",
-    )
-    status_label.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 0))
-    status_label.configure(pady=0)
-    theme.register(status_label)
-
-    reserve_line = tk.Frame(status_container, highlightthickness=0, bd=0)
-    reserve_line.grid(row=1, column=0, columnspan=2, sticky="w", pady=(0, 0))
-    theme.register(reserve_line)
-
-    reserve_var = tk.StringVar(master=reserve_line, value="")
-    reserve_label = tk.Label(
-        reserve_line,
-        textvariable=reserve_var,
-        justify="left",
-        anchor="w",
-    )
-    reserve_label.pack(side="left", anchor="w", pady=0)
-    reserve_label.configure(pady=0)
-    theme.register(reserve_label)
-
-    warning_label = tk.Label(
-        reserve_line,
-        text="",
-        justify="left",
-        anchor="w",
-    )
-    warning_label.pack(side="left", anchor="w", pady=0)
-    warning_label.configure(pady=0)
-    try:
-        base_font = tkfont.nametofont(reserve_label.cget("font"))
-        warning_label.configure(font=base_font)
-    except tk.TclError:
-        pass
-    try:
-        background = reserve_line.cget("background")
-        warning_label.configure(background=background)
-    except tk.TclError:
-        pass
-    warning_label.configure(foreground=warning_color)
-    theme.register(warning_label)
-
-    control_cluster = tk.Frame(top_bar, highlightthickness=border, bd=border, relief=relief)
-    control_cluster.grid(row=0, column=1, sticky="e")
-    theme.register(control_cluster)
-
-    version_label = tk.Label(control_cluster, text=version_text, anchor="e", cursor="hand2")
-    version_font: Optional[tkfont.Font] = None
-    try:
-        base_font = tkfont.nametofont(version_label.cget("font"))
-        version_font = tkfont.Font(font=base_font)
-        version_font.configure(underline=True)
-        version_label.configure(font=version_font)
-    except tk.TclError:
-        version_font = None
-    version_label.pack(side="left", padx=(4, 4))
-    version_label.bind("<Button-1>", lambda _evt: _open_url(repo_url))
-    theme.register(version_label)
-
-    hotspot_icon = _load_hotspot_icon(plugin_dir)
-    hotspot_button = tk.Button(
-        control_cluster,
-        image=hotspot_icon,
-        command=on_hotspot,
-        cursor="hand2",
-        width=24,
-        height=24,
-    )
-    if hotspot_icon is None:
-        hotspot_button.configure(text="H", width=3)
-    theme.style_button(hotspot_button)
-    hotspot_button.pack(side="left", padx=(0, 4))
-    hotspot_tooltip = WidgetTooltip(hotspot_button, text="Nearby Hotspots")
-
-    details_toggle = tk.Button(
-        control_cluster,
-        text="",
-        command=on_toggle_details,
-        cursor="hand2",
-    )
-    theme.style_button(details_toggle)
-    details_toggle.pack(side="left")
-
-    return TopBarWidgets(
-        frame=top_bar,
-        status_var=status_var,
-        reserve_var=reserve_var,
-        reserve_label=reserve_label,
-        reserve_warning_label=warning_label,
-        reserve_line=reserve_line,
-        version_label=version_label,
-        version_font=version_font,
-        hotspot_button=hotspot_button,
-        hotspot_icon=hotspot_icon,
-        hotspot_tooltip=hotspot_tooltip,
-        details_toggle=details_toggle,
-    )
-
-
-def _load_hotspot_icon(plugin_dir: Optional[Path]) -> Optional[tk.PhotoImage]:
-    icon_path = None
-    if plugin_dir:
-        candidate = plugin_dir / "assets" / "platinum_hotspot_icon_20x20.png"
-        if candidate.exists():
-            icon_path = candidate
-    if icon_path is None:
-        try:
-            icon_path = Path(__file__).resolve().parents[2] / "assets" / "platinum_hotspot_icon_20x20.png"
-        except Exception:
-            icon_path = Path("assets/platinum_hotspot_icon_20x20.png")
-    try:
-        return tk.PhotoImage(file=str(icon_path))
-    except Exception:
-        return None
-
-
-def _open_url(url: str) -> None:
-    import webbrowser
-
-    try:
-        webbrowser.open(url)
-    except Exception:
-        pass
diff --git a/mining_ui/histograms.py b/mining_ui/histograms.py
deleted file mode 100644
index 2aa516a..0000000
--- a/mining_ui/histograms.py
+++ /dev/null
@@ -1,197 +0,0 @@
-"""Histogram window helpers for EDMC Mining Analytics UI."""
-
-from __future__ import annotations
-
-from collections import Counter
-from typing import Optional, TYPE_CHECKING
-
-try:
-    import tkinter as tk
-    import tkinter.font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-if TYPE_CHECKING:  # pragma: no cover
-    from .main_mining_ui import edmcmaMiningUI
-
-from state import compute_percentage_stats
-
-
-def open_histogram_window(ui: "edmcmaMiningUI", commodity: str) -> None:
-    counter = ui._state.prospected_histogram.get(commodity)
-    if not counter:
-        return
-
-    window = ui._hist_windows.get(commodity)
-    if window and window.winfo_exists():
-        canvas = ui._hist_canvases.get(commodity)
-        if canvas and canvas.winfo_exists():
-            draw_histogram(ui, canvas, commodity)
-        window.lift()
-        return
-
-    parent = ui._frame
-    if parent is None:
-        return
-
-    top = tk.Toplevel(parent)
-    ui._theme.register(top)
-    top.title(f"{ui._format_cargo_name(commodity)} histogram")
-    canvas = tk.Canvas(
-        top,
-        width=360,
-        height=260,
-        background=ui._theme.table_background_color(),
-        highlightthickness=0,
-    )
-    canvas.pack(fill="both", expand=True)
-    ui._theme.register(canvas)
-    top.bind(
-        "<Configure>",
-        lambda event, c=commodity, cv=canvas: draw_histogram(ui, cv, c),
-    )
-    if not hasattr(canvas, "_theme_change_bound"):
-        canvas.bind(
-            "<<ThemeChanged>>",
-            lambda _evt, c=commodity, cv=canvas: draw_histogram(ui, cv, c),
-            add="+",
-        )
-        canvas._theme_change_bound = True
-    draw_histogram(ui, canvas, commodity, counter)
-    top.protocol("WM_DELETE_WINDOW", lambda c=commodity: close_histogram_window(ui, c))
-    ui._hist_windows[commodity] = top
-    ui._hist_canvases[commodity] = canvas
-
-
-def close_histogram_windows(ui: "edmcmaMiningUI") -> None:
-    for commodity in list(ui._hist_windows):
-        close_histogram_window(ui, commodity)
-    ui._hist_windows.clear()
-    ui._hist_canvases.clear()
-
-
-def close_histogram_window(ui: "edmcmaMiningUI", commodity: str) -> None:
-    window = ui._hist_windows.pop(commodity, None)
-    ui._hist_canvases.pop(commodity, None)
-    if not window:
-        return
-    try:
-        window.destroy()
-    except Exception:
-        pass
-
-
-def draw_histogram(
-    ui: "edmcmaMiningUI",
-    canvas: tk.Canvas,
-    commodity: str,
-    counter: Optional[Counter[int]] = None,
-) -> None:
-    canvas.delete("all")
-    if counter is None:
-        counter = ui._state.prospected_histogram.get(commodity, Counter())
-    if not counter:
-        canvas.create_text(180, 100, text="No data available")
-        return
-
-    if ui._theme.is_dark_theme:
-        bg_color = "#000000"
-    else:
-        bg_color = ui._theme.table_background_color()
-    canvas.configure(background=bg_color)
-
-    width = max(1, canvas.winfo_width())
-    height = max(1, canvas.winfo_height())
-    padding_x = 24
-    padding_top = 80
-    padding_bottom = 48
-    min_height = padding_top + padding_bottom + 1
-    if height < min_height:
-        height = float(min_height)
-    bins = sorted(counter.keys())
-    full_range = list(range(bins[0], bins[-1] + 1))
-    size = max(1, ui._state.histogram_bin_size)
-    labels = {bin_index: ui._format_bin_label(bin_index, size) for bin_index in full_range}
-
-    stats = compute_percentage_stats(ui._state.prospected_samples.get(commodity, []))
-    average_percent = stats[1] if stats else None
-
-    label_font = tkfont.nametofont("TkDefaultFont")
-    max_label_width = max((label_font.measure(text) for text in labels.values()), default=0)
-    min_bin_width = max(48.0, max_label_width + 12.0)
-    bin_count = max(1, len(full_range))
-    available_width = max(1.0, width - padding_x * 2)
-    bin_width = max(min_bin_width, available_width / bin_count)
-
-    heading_text = f"{ui._format_cargo_name(commodity)} histogram"
-    if average_percent is not None:
-        heading_text += f" — avg {average_percent:.1f}%"
-    try:
-        title_font = tkfont.nametofont("TkCaptionFont")
-    except (tk.TclError, RuntimeError):
-        title_font = tkfont.nametofont("TkDefaultFont")
-    heading_width = title_font.measure(heading_text) + padding_x * 2
-
-    requested_width = max(padding_x * 2 + bin_width * bin_count, heading_width, 360.0)
-    if requested_width > width:
-        canvas.config(width=int(requested_width))
-        width = requested_width
-        available_width = max(1.0, width - padding_x * 2)
-        bin_width = max(min_bin_width, available_width / bin_count)
-
-    max_count = max((counter.get(bin_index, 0) for bin_index in full_range), default=0) or 1
-    if ui._theme.is_dark_theme:
-        text_color = ui._theme.default_text_color()
-        bar_color = ui._theme.button_background_color()
-    else:
-        text_color = ui._theme.table_foreground_color()
-        bar_color = "#4a90e2"
-    bar_area_height = max(1, height - padding_top - padding_bottom)
-    bar_base_y = height - padding_bottom
-    label_y = bar_base_y + 6
-
-    canvas.create_text(
-        width / 2,
-        padding_top / 2,
-        text=heading_text,
-        fill=text_color,
-        font=title_font,
-    )
-
-    for idx, bin_index in enumerate(full_range):
-        count = counter.get(bin_index, 0)
-        x0 = padding_x + idx * bin_width
-        x1 = x0 + bin_width * 0.8
-        bar_height = bar_area_height * (count / max_count)
-        y0 = bar_base_y - bar_height
-        y1 = bar_base_y
-        canvas.create_rectangle(x0, y0, x1, y1, fill=bar_color, outline=bar_color)
-        label = labels[bin_index]
-        canvas.create_text((x0 + x1) / 2, label_y, text=label, anchor="n", fill=text_color)
-        canvas.create_text((x0 + x1) / 2, y0 - 4, text=str(count), anchor="s", fill=text_color)
-
-
-def refresh_histogram_windows(ui: "edmcmaMiningUI") -> None:
-    for commodity, canvas in list(ui._hist_canvases.items()):
-        window = ui._hist_windows.get(commodity)
-        if not window or not window.winfo_exists() or not canvas.winfo_exists():
-            ui._hist_canvases.pop(commodity, None)
-            ui._hist_windows.pop(commodity, None)
-            continue
-        draw_histogram(ui, canvas, commodity)
-
-
-def recompute_histograms(ui: "edmcmaMiningUI") -> None:
-    from state import recompute_histograms as _recompute  # local import to avoid circular deps
-
-    _recompute(ui._state)
-
-
-__all__ = [
-    "open_histogram_window",
-    "close_histogram_windows",
-    "close_histogram_window",
-    "draw_histogram",
-    "refresh_histogram_windows",
-    "recompute_histograms",
-]
diff --git a/mining_ui/hotspot_search_window.py b/mining_ui/hotspot_search_window.py
deleted file mode 100644
index 0e89bd2..0000000
--- a/mining_ui/hotspot_search_window.py
+++ /dev/null
@@ -1,1854 +0,0 @@
-"""Hotspot search window components (controller + view)."""
-
-from __future__ import annotations
-
-import queue
-import threading
-import time
-from dataclasses import dataclass, replace
-from typing import Callable, Dict, List, Optional, Sequence, Tuple
-
-try:
-    import tkinter as tk
-    from tkinter import ttk
-    import tkinter.font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-from logging_utils import get_logger
-from state import MiningState
-from integrations.spansh_hotspots import (
-    DEFAULT_RESULT_SIZE,
-    HotspotSearchResult,
-    RingHotspot,
-    SpanshHotspotClient,
-)
-from mining_ui.theme_adapter import ThemeAdapter
-
-_log = get_logger("ui")
-
-
-@dataclass(frozen=True)
-class HotspotSearchParams:
-    distance_min: float
-    distance_max: float
-    ring_signals: Tuple[str, ...]
-    reserve_levels: Tuple[str, ...]
-    ring_types: Tuple[str, ...]
-    min_hotspots: int
-    reference_text: str
-    page: int
-    limit: int
-
-
-@dataclass(frozen=True)
-class HotspotSavedFilters:
-    distance_min: Optional[float]
-    distance_max: Optional[float]
-    reserve_levels: Optional[Sequence[str]]
-    ring_types: Optional[Sequence[str]]
-    ring_signals: Optional[Sequence[str]]
-    min_hotspots: Optional[int]
-
-
-@dataclass(frozen=True)
-class SearchStartResult:
-    status: str
-    started: bool
-    token: Optional[int]
-
-
-class HotspotSearchController:
-    """Handle hotspot search logic and state coordination."""
-
-    FALLBACK_RING_SIGNALS = [
-        "Platinum",
-        "Painite",
-        "Void Opal",
-        "Tritium",
-        "Serendibite",
-        "Rhodplumsite",
-        "Monazite",
-    ]
-    FALLBACK_RING_TYPES = ["Metallic", "Metal Rich", "Icy", "Rocky"]
-    FALLBACK_RESERVE_LEVELS = ["Pristine", "Major", "Common", "Low", "Depleted"]
-
-    def __init__(self, state: MiningState, client: SpanshHotspotClient) -> None:
-        self._state = state
-        self._client = client
-        self._ring_signal_options = list(self.FALLBACK_RING_SIGNALS)
-        self._ring_type_options = list(self.FALLBACK_RING_TYPES)
-        self._reserve_level_options = list(self.FALLBACK_RESERVE_LEVELS)
-        self._metadata_callbacks: list[
-            Callable[[Sequence[str], Sequence[str], Sequence[str]], None]
-        ] = []
-        self._metadata_lock = threading.Lock()
-        self._metadata_ready = False
-
-        self._search_thread: Optional[threading.Thread] = None
-        self._pending_search_params: Optional[HotspotSearchParams] = None
-        self._search_token: int = 0
-        self._search_result_queue: "queue.Queue[tuple[int, tuple[str, object]]]" = queue.Queue()
-        self._reference_suggestion_queue: "queue.Queue[tuple[int, List[str]]]" = queue.Queue()
-        self._reference_suggestion_token: int = 0
-
-        self._start_metadata_refresh()
-
-
-    # ------------------------------------------------------------------
-    # Public API
-    # ------------------------------------------------------------------
-    @property
-    def state(self) -> MiningState:
-        return self._state
-
-    @property
-    def ring_signal_options(self) -> Sequence[str]:
-        return self._ring_signal_options
-
-    @property
-    def ring_type_options(self) -> Sequence[str]:
-        return self._ring_type_options
-
-    @property
-    def reserve_level_options(self) -> Sequence[str]:
-        return self._reserve_level_options
-
-    def register_metadata_callback(
-        self,
-        callback: Callable[[Sequence[str], Sequence[str], Sequence[str]], None],
-    ) -> None:
-        immediate_payload: Optional[
-            Tuple[Sequence[str], Sequence[str], Sequence[str]]
-        ] = None
-        with self._metadata_lock:
-            self._metadata_callbacks.append(callback)
-            if self._metadata_ready:
-                immediate_payload = (
-                    tuple(self._ring_signal_options),
-                    tuple(self._ring_type_options),
-                    tuple(self._reserve_level_options),
-                )
-        if immediate_payload:
-            try:
-                callback(*immediate_payload)
-            except Exception:
-                _log.exception("Failed to deliver hotspot metadata update callback")
-
-    def get_saved_filters(self) -> HotspotSavedFilters:
-        return HotspotSavedFilters(
-            distance_min=self._state.spansh_last_distance_min,
-            distance_max=self._state.spansh_last_distance_max,
-            reserve_levels=self._state.spansh_last_reserve_levels,
-            ring_types=self._state.spansh_last_ring_types,
-            ring_signals=self._state.spansh_last_ring_signals,
-            min_hotspots=self._state.spansh_last_min_hotspots,
-        )
-
-    def get_current_system(self) -> str:
-        return self._state.current_system or ""
-
-    def persist_filters_from_ui(
-        self,
-        distance_min_text: str,
-        distance_max_text: str,
-        reserves: Sequence[str],
-        ring_types: Sequence[str],
-        ring_signals: Sequence[str],
-        min_hotspots: int,
-    ) -> None:
-        self._state.spansh_last_distance_min = self._parse_optional_float(distance_min_text, None)
-        self._state.spansh_last_distance_max = self._parse_optional_float(distance_max_text, None)
-        self._state.spansh_last_reserve_levels = list(reserves)
-        self._state.spansh_last_ring_types = list(ring_types)
-        self._state.spansh_last_ring_signals = list(ring_signals)
-        self._state.spansh_last_min_hotspots = min_hotspots
-
-    def begin_search(self, params: HotspotSearchParams, display_reference: str) -> SearchStartResult:
-        self._state.spansh_last_distance_min = params.distance_min
-        self._state.spansh_last_distance_max = params.distance_max
-        self._state.spansh_last_ring_signals = list(params.ring_signals)
-        self._state.spansh_last_reserve_levels = list(params.reserve_levels)
-        self._state.spansh_last_ring_types = list(params.ring_types)
-        self._state.spansh_last_min_hotspots = max(1, int(params.min_hotspots))
-
-        if self._search_thread and self._search_thread.is_alive():
-            self._pending_search_params = params
-            status = (
-                f"Waiting for previous Spansh search to finish before searching near {display_reference}..."
-            )
-            return SearchStartResult(status=status, started=False, token=None)
-
-        self._pending_search_params = None
-        self._search_token += 1
-        token = self._search_token
-
-        thread = threading.Thread(
-            target=self._search_worker,
-            args=(token, params),
-            name="EDMC-SpanshSearch",
-            daemon=True,
-        )
-        self._search_thread = thread
-        thread.start()
-
-        status = f"Searching for hotspots near {display_reference}..."
-        return SearchStartResult(status=status, started=True, token=token)
-
-    def poll_search_results(self) -> Optional[tuple[int, tuple[str, object]]]:
-        try:
-            return self._search_result_queue.get_nowait()
-        except queue.Empty:
-            return None
-
-    def on_search_complete(self) -> Optional[HotspotSearchParams]:
-        self._search_thread = None
-        pending = self._pending_search_params
-        self._pending_search_params = None
-        return pending
-
-    def request_reference_suggestions(self, query: str) -> Optional[int]:
-        trimmed = query.strip()
-        if len(trimmed) < 2:
-            return None
-
-        self._reference_suggestion_token += 1
-        token = self._reference_suggestion_token
-
-        def worker() -> None:
-            try:
-                suggestions = self._client.suggest_system_names(trimmed, limit=10)
-            except Exception:
-                suggestions = []
-            try:
-                self._reference_suggestion_queue.put((token, suggestions))
-            except Exception:
-                pass
-
-        threading.Thread(target=worker, name="EDMC-SpanshSuggestions", daemon=True).start()
-        return token
-
-    def poll_reference_suggestions(self) -> Optional[tuple[int, List[str]]]:
-        try:
-            return self._reference_suggestion_queue.get_nowait()
-        except queue.Empty:
-            return None
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _start_metadata_refresh(self) -> None:
-        threading.Thread(
-            target=self._load_metadata_async,
-            name="EDMC-SpanshMetadata",
-            daemon=True,
-        ).start()
-
-    def _load_metadata_async(self) -> None:
-        try:
-            ring_signals = self._sorted_unique(
-                self._client.list_ring_signals(),
-                self.FALLBACK_RING_SIGNALS,
-            )
-        except Exception:
-            ring_signals = list(self.FALLBACK_RING_SIGNALS)
-
-        try:
-            ring_types = self._sorted_unique(
-                self._client.list_ring_types(),
-                self.FALLBACK_RING_TYPES,
-            )
-        except Exception:
-            ring_types = list(self.FALLBACK_RING_TYPES)
-
-        try:
-            reserve_levels = self._sorted_unique(
-                self._client.list_reserve_levels(),
-                self.FALLBACK_RESERVE_LEVELS,
-                preserve_order=True,
-            )
-        except Exception:
-            reserve_levels = list(self.FALLBACK_RESERVE_LEVELS)
-
-        with self._metadata_lock:
-            self._ring_signal_options = list(ring_signals)
-            self._ring_type_options = list(ring_types)
-            self._reserve_level_options = list(reserve_levels)
-            self._metadata_ready = True
-            callbacks = list(self._metadata_callbacks)
-
-        for callback in callbacks:
-            try:
-                callback(
-                    tuple(self._ring_signal_options),
-                    tuple(self._ring_type_options),
-                    tuple(self._reserve_level_options),
-                )
-            except Exception:
-                _log.exception("Failed to notify hotspot metadata callback")
-
-    def _search_worker(self, token: int, params: HotspotSearchParams) -> None:
-        reference_text_input = (params.reference_text or "").strip()
-        try:
-            resolved_reference = self._client.resolve_reference_system(reference_text_input)
-            result = self._client.search_hotspots(
-                distance_min=params.distance_min,
-                distance_max=params.distance_max,
-                ring_signals=params.ring_signals,
-                reserve_levels=params.reserve_levels,
-                ring_types=params.ring_types,
-                limit=params.limit,
-                page=params.page,
-                min_hotspots=max(1, int(params.min_hotspots)),
-                reference_system=resolved_reference,
-            )
-            result = self._filter_results_by_min_hotspots(result, params)
-            outcome: tuple[str, object] = ("success", (result, resolved_reference))
-        except ValueError as exc:
-            outcome = ("value_error", str(exc))
-        except RuntimeError as exc:
-            outcome = ("runtime_error", str(exc))
-        except Exception as exc:  # pragma: no cover - defensive
-            _log.exception("Unexpected error during hotspot search: %s", exc)
-            outcome = ("exception", str(exc))
-
-        try:
-            self._search_result_queue.put_nowait((token, outcome))
-        except Exception:  # pragma: no cover - defensive
-            pass
-
-    def _filter_results_by_min_hotspots(
-        self,
-        result: HotspotSearchResult,
-        params: HotspotSearchParams,
-    ) -> HotspotSearchResult:
-        min_required = max(1, int(params.min_hotspots))
-        if params.ring_signals:
-            return result
-
-        filtered_entries = tuple(
-            entry for entry in result.entries if self._total_signal_count(entry) >= min_required
-        )
-
-        if len(filtered_entries) == len(result.entries):
-            return result
-
-        return HotspotSearchResult(
-            total_count=result.total_count,
-            reference_system=result.reference_system,
-            entries=filtered_entries,
-        )
-
-    @staticmethod
-    def _total_signal_count(entry: RingHotspot) -> int:
-        total = 0
-        for signal in entry.signals:
-            try:
-                count = int(signal.count)
-            except (TypeError, ValueError):
-                continue
-            if count > 0:
-                total += count
-        return total
-
-    @staticmethod
-    def _sorted_unique(
-        values: Sequence[str],
-        fallback: Sequence[str],
-        *,
-        preserve_order: bool = False,
-    ) -> List[str]:
-        if not values:
-            return list(fallback)
-        seen: set[str] = set()
-        result: List[str] = []
-        iterable = values if preserve_order else sorted(values)
-        for item in iterable:
-            cleaned = item.strip()
-            lowered = cleaned.lower()
-            if not cleaned or lowered in seen:
-                continue
-            seen.add(lowered)
-            result.append(cleaned)
-        return result or list(fallback)
-
-    @staticmethod
-    def _parse_optional_float(value: str, default: Optional[float]) -> Optional[float]:
-        try:
-            cleaned = value.strip()
-        except AttributeError:
-            return default
-        if not cleaned:
-            return default
-        try:
-            return float(cleaned)
-        except ValueError:
-            return default
-
-
-class HotspotSearchWindow:
-    """Toplevel window that performs and displays Spansh hotspot searches."""
-
-    DEFAULT_DISTANCE_MIN = "0"
-    DEFAULT_DISTANCE_MAX = "100"
-    DEFAULT_SIGNAL = "Platinum"
-    DEFAULT_RESERVE = "Pristine"
-    DEFAULT_RING_TYPE = "Metallic"
-    DEFAULT_MIN_HOTSPOTS = 1
-    RESULTS_PER_PAGE = DEFAULT_RESULT_SIZE
-
-    FALLBACK_RING_SIGNALS = [
-        "Platinum",
-        "Painite",
-        "Void Opal",
-        "Tritium",
-        "Serendibite",
-        "Rhodplumsite",
-        "Monazite",
-    ]
-    FALLBACK_RING_TYPES = ["Metallic", "Metal Rich", "Icy", "Rocky"]
-    FALLBACK_RESERVE_LEVELS = ["Pristine", "Major", "Common", "Low", "Depleted"]
-
-    def __init__(
-        self,
-        parent: tk.Widget,
-        theme: ThemeAdapter,
-        controller: HotspotSearchController,
-        on_close: Callable[["HotspotSearchWindow"], None],
-    ) -> None:
-        self._parent = parent
-        self._theme = theme
-        self._controller = controller
-        self._on_close = on_close
-        self._search_job: Optional[str] = None
-
-        self._toplevel = tk.Toplevel(parent)
-        self._toplevel.title("Nearby Hotspots")
-        self._toplevel.transient(parent.winfo_toplevel())
-        self._toplevel.protocol("WM_DELETE_WINDOW", self.close)
-        self._toplevel.minsize(960, 420)
-        self._theme.register(self._toplevel)
-
-        self._distance_min_var = tk.StringVar(master=self._toplevel, value=self.DEFAULT_DISTANCE_MIN)
-        self._distance_max_var = tk.StringVar(master=self._toplevel, value=self.DEFAULT_DISTANCE_MAX)
-        self._reserve_var = tk.StringVar(master=self._toplevel, value=self.DEFAULT_RESERVE)
-        self._reference_system_var = tk.StringVar(master=self._toplevel, value="")
-
-        self._ring_signal_options = list(self._controller.ring_signal_options)
-        self._ring_type_options = list(self._controller.ring_type_options)
-        self._reserve_level_options = list(self._controller.reserve_level_options)
-
-        self._signals_listbox: Optional[tk.Listbox] = None
-        self._ring_type_listbox: Optional[tk.Listbox] = None
-        self._reserve_combobox: Optional[ttk.Combobox] = None
-        self._min_hotspots_var: Optional[tk.StringVar] = None
-        self._reference_entry: Optional[ttk.Entry] = None
-        self._reference_frame: Optional[tk.Frame] = None
-        self._results_tree: Optional[ttk.Treeview] = None
-        self._hotspot_container: Optional[tk.Frame] = None
-        self._hotspot_controls_frame: Optional[tk.Frame] = None
-        self._results_frame: Optional[tk.Frame] = None
-        self._active_search_token: Optional[int] = None
-        self._result_poll_job: Optional[str] = None
-        self._reference_suggestions_listbox: Optional[tk.Listbox] = None
-        self._reference_suggestions_visible = False
-        self._reference_suggestion_job: Optional[str] = None
-        self._reference_suggestion_poll_job: Optional[str] = None
-        self._reference_suggestion_token: int = 0
-        self._reference_last_query: str = ""
-        self._reference_suggestions_suppressed = False
-        self._status_var = tk.StringVar(master=self._toplevel, value="")
-        self._pagination_frame: Optional[tk.Frame] = None
-        self._pagination_pack_options: Dict[str, object] = {}
-        self._prev_page_button: Optional[ttk.Button] = None
-        self._next_page_button: Optional[ttk.Button] = None
-        self._page_label_var: Optional[tk.StringVar] = None
-        self._active_params: Optional[HotspotSearchParams] = None
-        self._last_successful_params: Optional[HotspotSearchParams] = None
-        self._last_result_total: int = 0
-        self._last_results_count: int = 0
-        self._pagination_has_prev: bool = False
-        self._pagination_has_next: bool = False
-        self._search_started_at: Optional[float] = None
-        self._last_search_duration: Optional[float] = None
-
-        self._build_ui()
-        self._controller.register_metadata_callback(self._handle_metadata_update)
-        self._schedule_initial_search()
-
-    # ------------------------------------------------------------------
-    # Window lifecycle helpers
-    # ------------------------------------------------------------------
-    @property
-    def is_open(self) -> bool:
-        return bool(self._toplevel and self._toplevel.winfo_exists())
-
-    def focus(self) -> None:
-        if not self.is_open:
-            return
-        try:
-            self._toplevel.deiconify()
-            self._toplevel.lift()
-            self._toplevel.focus_force()
-        except Exception:
-            pass
-
-    def close(self) -> None:
-        if self._search_job and self._toplevel and self._toplevel.winfo_exists():
-            try:
-                self._toplevel.after_cancel(self._search_job)
-            except Exception:
-                pass
-        self._search_job = None
-
-        if self._toplevel and self._toplevel.winfo_exists():
-            if self._result_poll_job:
-                try:
-                    self._toplevel.after_cancel(self._result_poll_job)
-                except Exception:
-                    pass
-            if self._reference_suggestion_job:
-                try:
-                    self._toplevel.after_cancel(self._reference_suggestion_job)
-                except Exception:
-                    pass
-            if self._reference_suggestion_poll_job:
-                try:
-                    self._toplevel.after_cancel(self._reference_suggestion_poll_job)
-                except Exception:
-                    pass
-            try:
-                self._toplevel.destroy()
-            except Exception:
-                pass
-        elif self._result_poll_job and self._toplevel:
-            try:
-                self._toplevel.after_cancel(self._result_poll_job)
-            except Exception:
-                pass
-        self._result_poll_job = None
-        self._reference_suggestion_job = None
-        self._reference_suggestion_poll_job = None
-        self._pending_search_params = None
-        self._search_thread = None
-
-        if self._on_close:
-            try:
-                self._on_close(self)
-            except Exception:
-                pass
-
-        self._toplevel = None
-        self._hotspot_container = None
-        self._hotspot_controls_frame = None
-        self._results_frame = None
-        self._results_tree = None
-        self._reference_entry = None
-        self._reference_frame = None
-        self._reference_system_var = None
-        self._min_hotspots_var = None
-        self._hide_reference_suggestions()
-        self._reference_suggestions_listbox = None
-        self._reference_suggestions_visible = False
-        self._reference_suggestions_suppressed = False
-        self._pagination_frame = None
-        self._pagination_pack_options = {}
-        self._prev_page_button = None
-        self._next_page_button = None
-        self._page_label_var = None
-        self._active_params = None
-        self._last_successful_params = None
-        self._last_result_total = 0
-        self._last_results_count = 0
-        self._pagination_has_prev = False
-        self._pagination_has_next = False
-        self._search_started_at = None
-        self._last_search_duration = None
-
-    def _handle_metadata_update(
-        self,
-        ring_signals: Sequence[str],
-        ring_types: Sequence[str],
-        reserve_levels: Sequence[str],
-    ) -> None:
-        if not self._toplevel:
-            return
-
-        def apply() -> None:
-            if not self.is_open:
-                return
-            self._apply_metadata_update(
-                list(ring_signals),
-                list(ring_types),
-                list(reserve_levels),
-            )
-
-        try:
-            self._toplevel.after(0, apply)
-        except Exception:
-            apply()
-
-    # ------------------------------------------------------------------
-    # UI construction
-    # ------------------------------------------------------------------
-    def _build_ui(self) -> None:
-        container = tk.Frame(self._toplevel, highlightthickness=0, bd=0)
-        container.pack(fill="both", expand=True, padx=12, pady=12)
-        self._theme.register(container)
-        self._hotspot_container = container
-
-        filters = self._controller.get_saved_filters()
-
-        reference_initial = self._controller.get_current_system()
-        self._reference_system_var.set(reference_initial)
-        self._reference_last_query = reference_initial.strip().lower()
-
-        layout_frame = tk.Frame(container, highlightthickness=0, bd=0)
-        layout_frame.pack(fill="x", pady=(0, 12))
-        self._theme.register(layout_frame)
-        layout_frame.columnconfigure(0, weight=1)
-        layout_frame.columnconfigure(1, weight=1)
-        layout_frame.rowconfigure(0, weight=0)
-        layout_frame.rowconfigure(1, weight=1)
-
-        reference_frame = tk.Frame(layout_frame, highlightthickness=0, bd=0)
-        reference_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 12), pady=(0, 8))
-        self._theme.register(reference_frame)
-        self._reference_frame = reference_frame
-
-        reference_frame.columnconfigure(0, weight=0)
-        reference_frame.columnconfigure(1, weight=1)
-
-        reference_label = tk.Label(reference_frame, text="Reference System", anchor="w")
-        reference_label.grid(row=0, column=0, sticky="w", padx=0)
-        self._theme.register(reference_label)
-
-        reference_entry = ttk.Entry(reference_frame, textvariable=self._reference_system_var, width=28)
-        reference_entry.grid(row=0, column=1, sticky="ew")
-        self._theme.register(reference_entry)
-        reference_entry.bind("<KeyRelease>", self._handle_reference_key_release, add="+")
-        reference_entry.bind("<Down>", self._handle_reference_entry_down, add="+")
-        reference_entry.bind("<Return>", self._handle_reference_entry_return, add="+")
-        self._reference_entry = reference_entry
-
-        suggestions_listbox = tk.Listbox(reference_frame, height=6, exportselection=False)
-        self._theme.register(suggestions_listbox)
-        suggestions_listbox.grid(row=1, column=1, sticky="ew", pady=(0, 0))
-        suggestions_listbox.grid_remove()
-        suggestions_listbox.bind("<Return>", self._apply_reference_suggestion_event, add="+")
-        suggestions_listbox.bind("<Double-Button-1>", self._apply_reference_suggestion_event, add="+")
-        suggestions_listbox.bind("<Escape>", self._hide_reference_suggestions_event, add="+")
-        suggestions_listbox.bind("<FocusOut>", self._on_reference_suggestions_focus_out, add="+")
-        suggestions_listbox.bind("<Up>", self._handle_suggestion_navigation, add="+")
-        suggestions_listbox.bind("<Down>", self._handle_suggestion_navigation, add="+")
-        self._reference_suggestions_listbox = suggestions_listbox
-
-        self._distance_min_var.set(self._format_distance(filters.distance_min, self.DEFAULT_DISTANCE_MIN))
-        self._distance_max_var.set(self._format_distance(filters.distance_max, self.DEFAULT_DISTANCE_MAX))
-
-        left_controls_frame = tk.Frame(layout_frame, highlightthickness=0, bd=0)
-        left_controls_frame.grid(row=1, column=0, sticky="nsew", padx=(0, 12))
-        left_controls_frame.columnconfigure(0, weight=1)
-        left_controls_frame.columnconfigure(1, weight=0)
-        left_controls_frame.rowconfigure(1, weight=1)
-        self._theme.register(left_controls_frame)
-        self._hotspot_controls_frame = left_controls_frame
-
-        distance_frame = tk.LabelFrame(left_controls_frame, text="Distance (LY)")
-        distance_frame.grid(row=0, column=0, sticky="ew", padx=(0, 8))
-        self._theme.register(distance_frame)
-
-        tk.Label(distance_frame, text="Min").grid(row=0, column=0, sticky="w", padx=(4, 4), pady=(2, 2))
-        min_entry = ttk.Entry(distance_frame, textvariable=self._distance_min_var, width=8)
-        min_entry.grid(row=0, column=1, sticky="w", padx=(0, 8), pady=(2, 2))
-
-        tk.Label(distance_frame, text="Max").grid(row=1, column=0, sticky="w", padx=(4, 4), pady=(2, 2))
-        max_entry = ttk.Entry(distance_frame, textvariable=self._distance_max_var, width=8)
-        max_entry.grid(row=1, column=1, sticky="w", padx=(0, 8), pady=(2, 2))
-
-        reserve_frame = tk.LabelFrame(left_controls_frame, text="Reserve Level")
-        reserve_frame.grid(row=0, column=1, sticky="ew")
-        self._theme.register(reserve_frame)
-
-        reserve_values = self._reserve_level_options or self.FALLBACK_RESERVE_LEVELS
-        reserve_combo = ttk.Combobox(
-            reserve_frame,
-            textvariable=self._reserve_var,
-            values=reserve_values,
-            width=12,
-            state="readonly",
-        )
-        reserve_combo.grid(row=0, column=0, padx=6, pady=6)
-        reserve_default = self._resolve_single_default(filters.reserve_levels, reserve_values, self.DEFAULT_RESERVE)
-        self._reserve_var.set(reserve_default)
-        if reserve_default in reserve_values:
-            reserve_combo.set(reserve_default)
-        elif reserve_values:
-            reserve_combo.current(0)
-        self._reserve_combobox = reserve_combo
-
-        ring_type_frame = tk.LabelFrame(left_controls_frame, text="Ring Filters")
-        ring_type_frame.grid(row=1, column=0, sticky="nsew", pady=(8, 0), padx=(0, 8))
-        self._theme.register(ring_type_frame)
-
-        ring_type_list = tk.Listbox(
-            ring_type_frame,
-            selectmode="extended",
-            height=min(6, max(3, len(self._ring_type_options))),
-            exportselection=False,
-        )
-        ring_type_list.grid(row=0, column=0, padx=6, pady=6)
-        self._theme.register(ring_type_list)
-        for option in self._ring_type_options:
-            ring_type_list.insert("end", option)
-        self._ring_type_listbox = ring_type_list
-        default_ring_types = self._filter_defaults(filters.ring_types, self._ring_type_options)
-        allow_empty_rings = filters.ring_types is not None
-        self._select_defaults(
-            ring_type_list,
-            default_ring_types,
-            fallback=self.DEFAULT_RING_TYPE,
-            allow_empty=allow_empty_rings,
-        )
-        ring_type_list.bind("<<ListboxSelect>>", self._on_filters_changed, add="+")
-
-        min_hotspots_initial = filters.min_hotspots or self.DEFAULT_MIN_HOTSPOTS
-        min_hotspots_initial = max(1, int(min_hotspots_initial or self.DEFAULT_MIN_HOTSPOTS))
-        self._min_hotspots_var = tk.StringVar(master=self._toplevel, value=str(min_hotspots_initial))
-        min_hotspots_frame = tk.LabelFrame(left_controls_frame, text="Minimum Hotspots")
-        min_hotspots_frame.grid(row=1, column=1, sticky="ew", pady=(8, 0))
-        self._theme.register(min_hotspots_frame)
-        spinbox_kwargs = {
-            "from_": 1,
-            "to": 999,
-            "width": 6,
-            "textvariable": self._min_hotspots_var,
-            "increment": 1,
-        }
-        try:
-            min_hotspots_spin = ttk.Spinbox(min_hotspots_frame, **spinbox_kwargs)
-        except AttributeError:
-            min_hotspots_spin = tk.Spinbox(min_hotspots_frame, **spinbox_kwargs)
-        min_hotspots_spin.grid(row=0, column=0, padx=6, pady=6, sticky="w")
-        self._theme.register(min_hotspots_spin)
-        self._min_hotspots_var.trace_add("write", self._on_filters_changed)
-
-        signal_frame = tk.LabelFrame(layout_frame, text="Ring Signals")
-        signal_frame.grid(row=0, column=1, rowspan=2, sticky="nsew")
-        self._theme.register(signal_frame)
-
-        signal_list = tk.Listbox(
-            signal_frame,
-            selectmode="extended",
-            height=10,
-            exportselection=False,
-        )
-        signal_list.grid(row=0, column=0, sticky="nsew", padx=(6, 0), pady=6)
-        self._theme.register(signal_list)
-        signal_scroll = tk.Scrollbar(signal_frame, orient="vertical", command=signal_list.yview)
-        signal_scroll.grid(row=0, column=1, sticky="ns", pady=6, padx=(0, 6))
-        signal_list.configure(yscrollcommand=signal_scroll.set)
-        for option in self._ring_signal_options:
-            signal_list.insert("end", option)
-        self._signals_listbox = signal_list
-        default_signals = self._filter_defaults(filters.ring_signals, self._ring_signal_options)
-        allow_empty_signals = filters.ring_signals is not None
-        self._select_defaults(
-            signal_list,
-            default_signals,
-            fallback=self.DEFAULT_SIGNAL,
-            allow_empty=allow_empty_signals,
-        )
-        signal_list.bind("<<ListboxSelect>>", self._on_filters_changed, add="+")
-        signal_frame.columnconfigure(0, weight=1)
-
-        action_frame = tk.Frame(container, highlightthickness=0, bd=0)
-        action_frame.pack(fill="x", pady=(0, 8))
-        self._theme.register(action_frame)
-
-        search_button = ttk.Button(action_frame, text="Search", command=self._perform_search)
-        search_button.pack(side="left")
-
-        status_label = tk.Label(action_frame, textvariable=self._status_var, anchor="w", justify="left")
-        status_label.pack(side="left", fill="x", expand=True, padx=(12, 0))
-        self._theme.register(status_label)
-
-        results_frame = tk.Frame(container, highlightthickness=0, bd=0)
-        results_frame.pack(fill="both", expand=True)
-        self._theme.register(results_frame)
-        self._results_frame = results_frame
-
-        columns = ("copy", "system", "body", "ring", "type", "distance_ly", "distance_ls", "signals")
-        tree = ttk.Treeview(results_frame, columns=columns, show="headings")
-        tree.heading("copy", text="")
-        tree.heading("system", text="System")
-        tree.heading("body", text="Body")
-        tree.heading("ring", text="Ring")
-        tree.heading("type", text="Type")
-        tree.heading("distance_ly", text="Distance (LY)")
-        tree.heading("distance_ls", text="Dist2Arrival (LS)")
-        tree.heading("signals", text="Signals")
-
-        tree.column("copy", width=28, minwidth=28, anchor="center", stretch=False)
-        tree.column("system", width=140, minwidth=140, anchor="w", stretch=False)
-        tree.column("body", width=140, anchor="w")
-        tree.column("ring", width=160, anchor="w")
-        tree.column("type", width=120, anchor="w")
-        tree.column("distance_ly", width=110, anchor="e")
-        tree.column("distance_ls", width=110, anchor="e")
-        tree.column("signals", width=260, anchor="w")
-
-        try:
-            heading_font = tkfont.nametofont("TkHeadingFont")
-        except tk.TclError:
-            heading_font = tkfont.nametofont("TkDefaultFont")
-        label_widths = {
-            "body": "Body",
-            "ring": "Ring",
-            "type": "Type",
-            "distance_ly": "Distance (LY)",
-            "distance_ls": "Dist2Arrival (LS)",
-        }
-        padding = 16
-        for column, label in label_widths.items():
-            width = heading_font.measure(label) + padding
-            tree.column(column, width=width, minwidth=width, stretch=False)
-
-        tree_scroll = ttk.Scrollbar(results_frame, orient="vertical", command=tree.yview)
-        tree.configure(yscrollcommand=tree_scroll.set)
-        tree.pack(side="left", fill="both", expand=True)
-        tree_scroll.pack(side="right", fill="y")
-
-        self._results_tree = tree
-        pagination_frame = tk.Frame(container, highlightthickness=0, bd=0)
-        pagination_frame.pack(fill="x", pady=(6, 0))
-        self._theme.register(pagination_frame)
-        self._pagination_frame = pagination_frame
-        self._pagination_pack_options = {"fill": "x", "pady": (6, 0)}
-
-        self._page_label_var = tk.StringVar(master=self._toplevel, value="")
-        page_label = tk.Label(pagination_frame, textvariable=self._page_label_var, anchor="e")
-        page_label.pack(side="right", padx=(0, 8))
-        self._theme.register(page_label)
-
-        next_button = ttk.Button(pagination_frame, text="Next", command=self._goto_next_page, state="disabled")
-        next_button.pack(side="right")
-        self._theme.register(next_button)
-        self._next_page_button = next_button
-
-        prev_button = ttk.Button(pagination_frame, text="Previous", command=self._goto_previous_page, state="disabled")
-        prev_button.pack(side="right", padx=(0, 4))
-        self._theme.register(prev_button)
-        self._prev_page_button = prev_button
-
-        pagination_frame.pack_forget()
-
-        tree.bind("<ButtonRelease-1>", self._handle_result_click, add="+")
-        self._schedule_result_poll()
-        reserve_combo.bind("<<ComboboxSelected>>", self._on_filters_changed, add="+")
-        self._distance_min_var.trace_add("write", self._on_filters_changed)
-        self._distance_max_var.trace_add("write", self._on_filters_changed)
-        self._reference_system_var.trace_add("write", self._on_filters_changed)
-        self._on_filters_changed()
-
-    def _apply_metadata_update(
-        self,
-        ring_signals: Sequence[str],
-        ring_types: Sequence[str],
-        reserve_levels: Sequence[str],
-    ) -> None:
-        ring_signal_values = list(ring_signals) if ring_signals else list(self.FALLBACK_RING_SIGNALS)
-        ring_type_values = list(ring_types) if ring_types else list(self.FALLBACK_RING_TYPES)
-        reserve_values = list(reserve_levels) if reserve_levels else list(self.FALLBACK_RESERVE_LEVELS)
-
-        selection_changed = False
-
-        self._ring_signal_options = ring_signal_values
-        self._ring_type_options = ring_type_values
-        self._reserve_level_options = reserve_values
-
-        if self._signals_listbox and self._signals_listbox.winfo_exists():
-            previous_selection = self._get_listbox_selection(self._signals_listbox)
-            had_selection = bool(previous_selection)
-            filtered_selection = self._filter_defaults(previous_selection, ring_signal_values)
-            self._signals_listbox.delete(0, "end")
-            for option in ring_signal_values:
-                self._signals_listbox.insert("end", option)
-            if filtered_selection:
-                self._apply_listbox_selection(self._signals_listbox, ring_signal_values, filtered_selection)
-            elif not had_selection:
-                self._signals_listbox.selection_clear(0, "end")
-            elif ring_signal_values:
-                fallback_signal = self._resolve_single_default(None, ring_signal_values, self.DEFAULT_SIGNAL)
-                self._apply_listbox_selection(self._signals_listbox, ring_signal_values, [fallback_signal])
-            else:
-                self._signals_listbox.selection_clear(0, "end")
-            if self._get_listbox_selection(self._signals_listbox) != previous_selection:
-                selection_changed = True
-
-        if self._ring_type_listbox and self._ring_type_listbox.winfo_exists():
-            previous_types = self._get_listbox_selection(self._ring_type_listbox)
-            had_type_selection = bool(previous_types)
-            filtered_types = self._filter_defaults(previous_types, ring_type_values)
-            self._ring_type_listbox.delete(0, "end")
-            for option in ring_type_values:
-                self._ring_type_listbox.insert("end", option)
-            if filtered_types:
-                self._apply_listbox_selection(self._ring_type_listbox, ring_type_values, filtered_types)
-            elif not had_type_selection:
-                self._ring_type_listbox.selection_clear(0, "end")
-            elif ring_type_values:
-                fallback_type = self._resolve_single_default(None, ring_type_values, self.DEFAULT_RING_TYPE)
-                self._apply_listbox_selection(self._ring_type_listbox, ring_type_values, [fallback_type])
-            else:
-                self._ring_type_listbox.selection_clear(0, "end")
-            if self._get_listbox_selection(self._ring_type_listbox) != previous_types:
-                selection_changed = True
-
-        if self._reserve_combobox and self._reserve_combobox.winfo_exists() and self._reserve_var:
-            previous_reserve = self._reserve_var.get()
-            try:
-                self._reserve_combobox["values"] = reserve_values
-            except Exception:
-                pass
-
-            if reserve_values:
-                if previous_reserve not in reserve_values:
-                    new_reserve = self._resolve_single_default(
-                        [previous_reserve] if previous_reserve else None,
-                        reserve_values,
-                        self.DEFAULT_RESERVE,
-                    )
-                    if new_reserve not in reserve_values and reserve_values:
-                        new_reserve = reserve_values[0]
-                    if new_reserve in reserve_values:
-                        self._reserve_var.set(new_reserve)
-                        try:
-                            self._reserve_combobox.set(new_reserve)
-                        except Exception:
-                            pass
-                    else:
-                        self._reserve_var.set("")
-                        try:
-                            self._reserve_combobox.set("")
-                        except Exception:
-                            pass
-                    if previous_reserve != self._reserve_var.get():
-                        selection_changed = True
-                else:
-                    try:
-                        self._reserve_combobox.set(previous_reserve)
-                    except Exception:
-                        pass
-            else:
-                self._reserve_var.set("")
-                try:
-                    self._reserve_combobox.set("")
-                except Exception:
-                    pass
-                if previous_reserve:
-                    selection_changed = True
-
-        if selection_changed:
-            self._on_filters_changed()
-
-    # ------------------------------------------------------------------
-    # Helpers
-    # ------------------------------------------------------------------
-    def _schedule_initial_search(self) -> None:
-        if not self.is_open:
-            return
-        self._last_search_duration = None
-        self._set_search_status("Searching for hotspots...", include_duration=False)
-        self._search_job = self._toplevel.after(50, self._perform_search)
-
-    @staticmethod
-    def _sorted_unique(values: Sequence[str], fallback: Sequence[str], preserve_order: bool = False) -> List[str]:
-        cleaned = [value for value in values if isinstance(value, str) and value]
-        if not cleaned:
-            cleaned = list(fallback)
-        if preserve_order:
-            seen: set[str] = set()
-            ordered: List[str] = []
-            for value in cleaned:
-                if value in seen:
-                    continue
-                seen.add(value)
-                ordered.append(value)
-            return ordered
-        return sorted(set(cleaned), key=str.casefold)
-
-    @staticmethod
-    def _select_defaults(
-        listbox: Optional[tk.Listbox],
-        defaults: Sequence[str],
-        *,
-        fallback: Optional[str] = None,
-        allow_empty: bool = False,
-    ) -> None:
-        if not listbox:
-            return
-        options = listbox.get(0, "end")
-        selected = False
-        for default in defaults:
-            try:
-                index = options.index(default)
-            except ValueError:
-                continue
-            listbox.selection_set(index)
-            listbox.see(index)
-            selected = True
-
-        if selected:
-            return
-
-        if allow_empty:
-            listbox.selection_clear(0, "end")
-            return
-
-        if fallback and fallback in options:
-            try:
-                index = options.index(fallback)
-                listbox.selection_set(index)
-                listbox.see(index)
-                return
-            except ValueError:
-                pass
-
-        if options:
-            listbox.selection_set(0)
-
-    @staticmethod
-    def _format_distance(value: Optional[float], fallback: str) -> str:
-        if value is None:
-            return fallback
-        try:
-            return f"{float(value):g}"
-        except (TypeError, ValueError):
-            return fallback
-
-    @staticmethod
-    def _apply_listbox_selection(
-        listbox: tk.Listbox,
-        options: Sequence[str],
-        selection: Sequence[str],
-    ) -> None:
-        try:
-            listbox.selection_clear(0, "end")
-        except Exception:
-            return
-        option_list = list(options)
-        if not option_list:
-            return
-        for value in selection:
-            try:
-                index = option_list.index(value)
-            except ValueError:
-                continue
-            try:
-                listbox.selection_set(index)
-                listbox.see(index)
-            except Exception:
-                continue
-
-    @staticmethod
-    def _filter_defaults(candidates: Optional[Sequence[str]], options: Sequence[str]) -> List[str]:
-        if not candidates:
-            return []
-        filtered: List[str] = []
-        option_set = {opt for opt in options}
-        for candidate in candidates:
-            if candidate in option_set and candidate not in filtered:
-                filtered.append(candidate)
-        return filtered
-
-    @staticmethod
-    def _resolve_single_default(
-        candidates: Optional[Sequence[str]],
-        options: Sequence[str],
-        fallback: str,
-    ) -> str:
-        if candidates:
-            for candidate in candidates:
-                if candidate in options:
-                    return candidate
-        if fallback in options:
-            return fallback
-        return options[0] if options else fallback
-
-    @staticmethod
-    def _parse_float(value: str, fallback: float) -> float:
-        stripped = value.strip() if value else ""
-        if not stripped:
-            return fallback
-        return float(stripped)
-
-    @staticmethod
-    def _parse_optional_float(value: Optional[str]) -> Optional[float]:
-        stripped = value.strip() if value else ""
-        if not stripped:
-            return None
-        try:
-            return float(stripped)
-        except (TypeError, ValueError):
-            return None
-
-    @staticmethod
-    def _parse_min_hotspots(value: Optional[str], default: int) -> int:
-        stripped = value.strip() if value else ""
-        if not stripped:
-            return max(1, default)
-        try:
-            parsed = int(stripped)
-        except (TypeError, ValueError):
-            return max(1, default)
-        return max(1, parsed)
-
-    @staticmethod
-    def _get_listbox_selection(listbox: Optional[tk.Listbox]) -> List[str]:
-        if not listbox:
-            return []
-        selections: List[str] = []
-        try:
-            indices = listbox.curselection()
-        except Exception:
-            return []
-        for index in indices:
-            try:
-                value = listbox.get(index)
-            except Exception:
-                continue
-            if isinstance(value, str):
-                selections.append(value)
-        return selections
-
-    def _handle_reference_key_release(self, event: tk.Event) -> Optional[str]:
-        keysym = getattr(event, "keysym", "")
-        if keysym in {"Up", "Down", "Left", "Right", "Escape", "Return", "Tab"}:
-            if keysym == "Escape":
-                self._hide_reference_suggestions()
-            return None
-        self._queue_reference_suggestion_fetch()
-        return None
-
-    def _handle_reference_entry_down(self, event: tk.Event) -> Optional[str]:
-        if self._reference_suggestions_visible and self._reference_suggestions_listbox:
-            if self._reference_suggestions_listbox.size() > 0:
-                self._reference_suggestions_listbox.selection_clear(0, "end")
-                self._reference_suggestions_listbox.selection_set(0)
-                self._reference_suggestions_listbox.activate(0)
-                self._reference_suggestions_listbox.focus_set()
-                return "break"
-        return None
-
-    def _handle_reference_entry_return(self, _event: tk.Event) -> str:
-        self._reference_suggestions_suppressed = True
-        self._hide_reference_suggestions()
-        self._perform_search()
-        return "break"
-
-    def _handle_result_click(self, event: tk.Event) -> None:
-        tree = self._results_tree
-        if not tree or not tree.winfo_exists():
-            return
-
-        item_id = tree.identify_row(event.y)
-        if not item_id:
-            return
-        column = tree.identify_column(event.x)
-        if column != "#1":
-            return
-
-        values = tree.item(item_id, "values")
-        if not values or len(values) < 2:
-            return
-        system_name = values[1]
-        if not isinstance(system_name, str) or not system_name.strip():
-            return
-        self._copy_system_to_clipboard(system_name.strip())
-
-    def _queue_reference_suggestion_fetch(self) -> None:
-        if not self._reference_system_var or not self._toplevel:
-            return
-        query = self._reference_system_var.get().strip()
-        query_key = query.lower()
-        if query_key == self._reference_last_query:
-            if self._reference_suggestions_suppressed:
-                return
-            return
-        self._reference_suggestions_suppressed = False
-        self._reference_last_query = query_key
-        if self._reference_suggestion_job:
-            try:
-                self._toplevel.after_cancel(self._reference_suggestion_job)
-            except Exception:
-                pass
-        self._reference_suggestion_job = self._toplevel.after(200, lambda q=query: self._request_reference_suggestions(q))
-
-    def _request_reference_suggestions(self, query: str) -> None:
-        self._reference_suggestion_job = None
-        if not self.is_open:
-            return
-        trimmed = query.strip()
-        if len(trimmed) < 2:
-            self._update_reference_suggestions([])
-            return
-
-        token = self._controller.request_reference_suggestions(trimmed)
-        if token is None:
-            self._update_reference_suggestions([])
-            return
-
-        self._reference_suggestion_token = token
-        self._schedule_reference_suggestion_poll()
-
-    def _schedule_reference_suggestion_poll(self) -> None:
-        if not self._toplevel or not self._toplevel.winfo_exists():
-            return
-        if self._reference_suggestion_poll_job:
-            return
-        self._reference_suggestion_poll_job = self._toplevel.after(100, self._poll_reference_suggestions)
-
-    def _poll_reference_suggestions(self) -> None:
-        self._reference_suggestion_poll_job = None
-        if not self.is_open:
-            return
-
-        latest: Optional[List[str]] = None
-        while True:
-            item = self._controller.poll_reference_suggestions()
-            if not item:
-                break
-            token, suggestions = item
-            if token >= self._reference_suggestion_token:
-                latest = suggestions
-
-        if latest is not None:
-            self._update_reference_suggestions(latest)
-
-        if self._reference_suggestion_token:
-            self._schedule_reference_suggestion_poll()
-
-    def _update_reference_suggestions(self, suggestions: List[str]) -> None:
-        if not self._reference_suggestions_listbox:
-            return
-
-        self._reference_suggestions_listbox.delete(0, "end")
-        if not suggestions:
-            self._hide_reference_suggestions()
-            return
-
-        seen: set[str] = set()
-        for item in suggestions:
-            lowered = item.lower()
-            if lowered in seen:
-                continue
-            seen.add(lowered)
-            self._reference_suggestions_listbox.insert("end", item)
-
-        if self._reference_suggestions_listbox.size() > 0:
-            self._reference_suggestions_listbox.selection_clear(0, "end")
-            self._reference_suggestions_listbox.selection_set(0)
-            self._reference_suggestions_listbox.activate(0)
-
-        if not self._reference_suggestions_visible:
-            try:
-                self._reference_suggestions_listbox.grid(row=1, column=1, sticky="ew", pady=(0, 0))
-            except tk.TclError:
-                pass
-            self._reference_suggestions_visible = True
-
-    def _hide_reference_suggestions(self) -> None:
-        if self._reference_suggestions_listbox and self._reference_suggestions_visible:
-            try:
-                self._reference_suggestions_listbox.grid_remove()
-            except tk.TclError:
-                self._reference_suggestions_listbox.pack_forget()
-            self._reference_suggestions_listbox.selection_clear(0, "end")
-            self._reference_suggestions_visible = False
-
-    def _hide_reference_suggestions_event(self, _event: tk.Event) -> str:
-        self._hide_reference_suggestions()
-        if self._reference_entry:
-            self._reference_entry.focus_set()
-        return "break"
-
-    def _on_reference_suggestions_focus_out(self, _event: tk.Event) -> None:
-        if not self._toplevel or not self._toplevel.winfo_exists():
-            return
-        self._toplevel.after(150, self._hide_reference_suggestions)
-
-    def _apply_reference_suggestion_event(self, _event: tk.Event) -> str:
-        self._apply_reference_suggestion()
-        self._reference_last_query = self._reference_system_var.get().strip().lower() if self._reference_system_var else ""
-        self._reference_suggestions_suppressed = True
-        return "break"
-
-    def _apply_reference_suggestion(self) -> None:
-        if not self._reference_suggestions_listbox or not self._reference_system_var:
-            return
-        selection = self._reference_suggestions_listbox.curselection()
-        if not selection:
-            return
-        value = self._reference_suggestions_listbox.get(selection[0])
-        if not isinstance(value, str):
-            return
-        trimmed = value.strip()
-        lowered = trimmed.lower()
-        self._reference_last_query = lowered
-        self._reference_suggestions_suppressed = True
-        self._reference_system_var.set(trimmed)
-        self._perform_search()
-        self._hide_reference_suggestions()
-        if self._reference_entry:
-            self._reference_entry.focus_set()
-            self._reference_entry.icursor("end")
-
-    def _handle_suggestion_navigation(self, event: tk.Event) -> str:
-        if not self._reference_suggestions_listbox:
-            return "break"
-        size = self._reference_suggestions_listbox.size()
-        if size == 0:
-            return "break"
-        selection = self._reference_suggestions_listbox.curselection()
-        index = selection[0] if selection else -1
-        if event.keysym == "Up":
-            index = 0 if index <= 0 else index - 1
-        elif event.keysym == "Down":
-            index = 0 if index < 0 else min(size - 1, index + 1)
-        else:
-            return "break"
-        self._reference_suggestions_listbox.selection_clear(0, "end")
-        self._reference_suggestions_listbox.selection_set(index)
-        self._reference_suggestions_listbox.activate(index)
-        return "break"
-
-    def _collect_selections(self) -> Tuple[float, float, List[str], List[str], List[str], int]:
-        min_distance = self._parse_float(self._distance_min_var.get(), float(self.DEFAULT_DISTANCE_MIN))
-        max_distance = self._parse_float(self._distance_max_var.get(), float(self.DEFAULT_DISTANCE_MAX))
-
-        reserve_value = self._reserve_var.get().strip()
-        reserves = [reserve_value] if reserve_value else []
-
-        signal_list = self._signals_listbox
-        signals = []
-        if signal_list:
-            signals = [signal_list.get(index) for index in signal_list.curselection()]
-
-        ring_type_list = self._ring_type_listbox
-        ring_types = []
-        if ring_type_list:
-            ring_types = [ring_type_list.get(index) for index in ring_type_list.curselection()]
-
-        min_hotspots = self._parse_min_hotspots(
-            self._min_hotspots_var.get() if self._min_hotspots_var else None,
-            self.DEFAULT_MIN_HOTSPOTS,
-        )
-
-        return min_distance, max_distance, signals, reserves, ring_types, min_hotspots
-
-    def _set_search_status(self, message: str, *, include_duration: bool = True) -> None:
-        if not self._status_var:
-            return
-        if include_duration and self._last_search_duration is not None:
-            formatted = self._format_query_duration(self._last_search_duration)
-            if formatted:
-                message = f"{message} (Query {formatted})" if message else f"Query {formatted}"
-        self._status_var.set(message)
-
-    @staticmethod
-    def _format_query_duration(duration: float) -> str:
-        if duration < 0:
-            duration = 0.0
-        if duration < 1:
-            return f"{duration * 1000:.0f} ms"
-        if duration < 10:
-            return f"{duration:.2f} s"
-        if duration < 60:
-            return f"{duration:.1f} s"
-        minutes = int(duration // 60)
-        seconds = duration - minutes * 60
-        if minutes and seconds >= 1:
-            return f"{minutes}m {seconds:.0f}s"
-        if minutes:
-            return f"{minutes}m"
-        return f"{duration:.1f} s"
-
-    def _finalize_search_duration(self) -> Optional[float]:
-        if self._search_started_at is None:
-            return self._last_search_duration
-        elapsed = max(0.0, time.perf_counter() - self._search_started_at)
-        self._last_search_duration = elapsed
-        self._search_started_at = None
-        return elapsed
-
-    def _set_pagination_visible(self, visible: bool) -> None:
-        frame = self._pagination_frame
-        if not frame:
-            return
-        managed = frame.winfo_manager()
-        if visible:
-            options = self._pagination_pack_options or {"fill": "x", "pady": (6, 0)}
-            if managed != "pack":
-                frame.pack(**options)
-        else:
-            if managed:
-                frame.pack_forget()
-            if self._page_label_var:
-                self._page_label_var.set("")
-
-    def _set_pagination_buttons_state(self, prev_enabled: bool, next_enabled: bool) -> None:
-        if self._prev_page_button:
-            self._prev_page_button.configure(state="normal" if prev_enabled else "disabled")
-        if self._next_page_button:
-            self._next_page_button.configure(state="normal" if next_enabled else "disabled")
-
-    def _is_search_in_progress(self) -> bool:
-        return self._active_search_token is not None
-
-    def _apply_pagination_button_state(self) -> None:
-        buttons_enabled = not self._is_search_in_progress()
-        self._set_pagination_buttons_state(
-            self._pagination_has_prev and buttons_enabled,
-            self._pagination_has_next and buttons_enabled,
-        )
-        self._set_pagination_visible(self._pagination_has_prev or self._pagination_has_next)
-
-    def _update_pagination_controls(self, result: HotspotSearchResult) -> None:
-        params = self._active_params or self._last_successful_params
-        if not params:
-            self._pagination_has_prev = False
-            self._pagination_has_next = False
-            self._set_pagination_visible(False)
-            return
-
-        limit = max(1, int(params.limit or self.RESULTS_PER_PAGE))
-        page_index = max(0, int(params.page))
-        entries_count = len(result.entries)
-        total = int(result.total_count or 0)
-
-        self._last_results_count = entries_count
-        self._last_result_total = total
-
-        has_prev = page_index > 0
-        if total > 0:
-            has_next = (page_index + 1) * limit < total
-        else:
-            has_next = entries_count >= limit
-
-        self._pagination_has_prev = has_prev
-        self._pagination_has_next = has_next
-
-        if self._page_label_var:
-            if not (has_prev or has_next):
-                self._page_label_var.set("")
-            elif total > 0:
-                total_pages = max(1, (total + limit - 1) // limit)
-                self._page_label_var.set(f"Page {page_index + 1} of {total_pages}")
-            else:
-                self._page_label_var.set(f"Page {page_index + 1}")
-
-        self._apply_pagination_button_state()
-
-    def _goto_previous_page(self) -> None:
-        if self._is_search_in_progress():
-            return
-        params = self._last_successful_params
-        if not params:
-            return
-        target_page = max(0, int(params.page) - 1)
-        if target_page == params.page:
-            return
-        self._request_page(target_page)
-
-    def _goto_next_page(self) -> None:
-        if self._is_search_in_progress():
-            return
-        params = self._last_successful_params
-        if not params:
-            return
-        limit = max(1, int(params.limit or self.RESULTS_PER_PAGE))
-        total = self._last_result_total
-        entries_count = self._last_results_count
-        next_page = int(params.page) + 1
-        if total > 0 and next_page * limit >= total:
-            return
-        if total <= 0 and entries_count < limit:
-            return
-        self._request_page(next_page)
-
-    def _request_page(self, target_page: int) -> None:
-        params = self._last_successful_params
-        if not params:
-            return
-        target = max(0, target_page)
-        new_params = replace(params, page=target)
-        self._start_search(new_params)
-
-    def _on_filters_changed(self, *_: object) -> None:
-        distance_min_text = self._distance_min_var.get() if self._distance_min_var else ""
-        distance_max_text = self._distance_max_var.get() if self._distance_max_var else ""
-        reserve_value = self._reserve_var.get().strip() if self._reserve_var else ""
-        reserves = [reserve_value] if reserve_value else []
-        ring_types = self._get_listbox_selection(self._ring_type_listbox)
-        ring_signals = self._get_listbox_selection(self._signals_listbox)
-        min_hotspots = self._parse_min_hotspots(
-            self._min_hotspots_var.get() if self._min_hotspots_var else None,
-            self.DEFAULT_MIN_HOTSPOTS,
-        )
-
-        self._controller.persist_filters_from_ui(
-            distance_min_text,
-            distance_max_text,
-            reserves,
-            ring_types,
-            ring_signals,
-            min_hotspots,
-        )
-
-        self._queue_reference_suggestion_fetch()
-
-    # ------------------------------------------------------------------
-    # Search + render
-    # ------------------------------------------------------------------
-    def _perform_search(self) -> None:
-        self._search_job = None
-        if not self.is_open:
-            return
-
-        try:
-            min_distance, max_distance, signals, reserves, ring_types, min_hotspots = self._collect_selections()
-        except ValueError as exc:
-            self._set_search_status(f"Invalid input: {exc}", include_duration=False)
-            return
-
-        reference_input = self._reference_system_var.get().strip() if self._reference_system_var else ""
-        self._controller.persist_filters_from_ui(
-            self._distance_min_var.get() if self._distance_min_var else "",
-            self._distance_max_var.get() if self._distance_max_var else "",
-            reserves,
-            ring_types,
-            signals,
-            min_hotspots,
-        )
-        fallback_system = reference_input or self._controller.get_current_system() or ""
-        if not fallback_system:
-            self._set_search_status(
-                "Reference system unknown. Enter a system name to search for hotspots.",
-                include_duration=False,
-            )
-            return
-
-        params = HotspotSearchParams(
-            distance_min=float(min_distance),
-            distance_max=float(max_distance),
-            ring_signals=tuple(signals),
-            reserve_levels=tuple(reserves),
-            ring_types=tuple(ring_types),
-            min_hotspots=int(min_hotspots),
-            reference_text=reference_input,
-            page=0,
-            limit=self.RESULTS_PER_PAGE,
-        )
-        self._start_search(params)
-
-    def _start_search(self, params: HotspotSearchParams) -> None:
-        if not self.is_open:
-            return
-
-        self._active_params = params
-        self._last_results_count = 0
-        self._set_pagination_buttons_state(False, False)
-        self._schedule_result_poll()
-
-        reference_text = (params.reference_text or "").strip()
-        display_reference = reference_text or self._controller.get_current_system() or "Unknown system"
-
-        self._hide_reference_suggestions()
-
-        result = self._controller.begin_search(params, display_reference)
-        self._last_search_duration = None
-        self._set_search_status(result.status, include_duration=False)
-
-        if not result.started:
-            self._apply_pagination_button_state()
-            return
-
-        self._active_search_token = result.token
-        self._search_started_at = time.perf_counter()
-
-        tree = self._results_tree
-        if tree:
-            for item in tree.get_children():
-                tree.delete(item)
-
-        if self._toplevel:
-            try:
-                self._toplevel.update_idletasks()
-            except Exception:
-                pass
-        self._apply_pagination_button_state()
-
-    def _render_results(self, result: HotspotSearchResult) -> None:
-        tree = self._results_tree
-        if not tree:
-            return
-
-        params = self._active_params
-        if params:
-            self._last_successful_params = params
-
-        for item in tree.get_children():
-            tree.delete(item)
-
-        entries = list(result.entries)
-        system_labels: List[str] = []
-        signals_labels: List[str] = []
-        ring_labels: List[str] = []
-        type_labels: List[str] = []
-        for entry in entries:
-            signals_text = ", ".join(
-                f"{signal.name} ({signal.count})" if signal.count else signal.name for signal in entry.signals
-            )
-            if not signals_text:
-                signals_text = "—"
-            signals_labels.append(signals_text)
-            system_display = entry.system_name or "—"
-            system_labels.append(system_display)
-            body_display = entry.body_name or "—"
-            if entry.system_name and entry.body_name:
-                system = entry.system_name.strip()
-                body = entry.body_name.strip()
-                if system and body.lower().startswith(system.lower()):
-                    trimmed_body = body[len(system) :].lstrip(" -")
-                    if trimmed_body:
-                        body_display = trimmed_body
-            if not body_display or body_display == entry.body_name:
-                body_display = entry.body_name or "—"
-            ring_display = entry.ring_name or "—"
-            if entry.body_name and entry.ring_name:
-                body = entry.body_name.strip()
-                ring = entry.ring_name.strip()
-                if body and ring.lower().startswith(body.lower()):
-                    trimmed = ring[len(body) :].lstrip(" -")
-                    if trimmed:
-                        ring_display = trimmed
-            if not ring_display or ring_display == entry.ring_name:
-                ring_display = entry.ring_name or "—"
-            ring_labels.append(ring_display or "—")
-            type_labels.append(entry.ring_type or "—")
-            tree.insert(
-                "",
-                "end",
-                values=(
-                    "📋",
-                    system_display,
-                    body_display,
-                    ring_display,
-                    entry.ring_type or "—",
-                    f"{entry.distance_ly:.2f}",
-                    f"{entry.distance_ls:.0f}",
-                    signals_text,
-                ),
-            )
-
-        if entries:
-            try:
-                item_font_name = tree.cget("font")
-            except tk.TclError:
-                item_font_name = ""
-            try:
-                item_font = (
-                    tkfont.nametofont(item_font_name)
-                    if item_font_name
-                    else tkfont.nametofont("TkDefaultFont")
-                )
-            except tk.TclError:
-                item_font = None
-
-            try:
-                heading_font = tkfont.nametofont("TkHeadingFont")
-            except tk.TclError:
-                heading_font = None
-
-            system_width = 0
-            if item_font:
-                max_width = max(item_font.measure(label) for label in (*system_labels, "System"))
-                system_width = max(140, max_width + 16)
-                tree.column("system", width=system_width, minwidth=system_width, stretch=False)
-                signals_width = max(item_font.measure(label) for label in (*signals_labels, "Signals"))
-                ring_width = max(item_font.measure(label) for label in (*ring_labels, "Ring"))
-                type_width = max(item_font.measure(label) for label in (*type_labels, "Type"))
-            else:
-                system_width = 0
-                signals_width = 0
-                ring_width = 0
-                type_width = 0
-
-            header_width = heading_font.measure("Signals") if heading_font else signals_width
-            target_signal_width = max(header_width, signals_width) + 16
-            current_config = tree.column("signals")
-            current_width = current_config.get("width", 0) if isinstance(current_config, dict) else 0
-            current_min = current_config.get("minwidth", 0) if isinstance(current_config, dict) else 0
-            effective_width = max(target_signal_width, current_width, current_min)
-            if effective_width > 0:
-                tree.column("signals", width=effective_width, minwidth=effective_width, stretch=False)
-
-            def _resize_column(column: str, content_width: int, header_text: str) -> None:
-                header_w = heading_font.measure(header_text) if heading_font else content_width
-                target = max(header_w, content_width) + 16
-                config = tree.column(column)
-                current_w = config.get("width", 0) if isinstance(config, dict) else 0
-                current_min_w = config.get("minwidth", 0) if isinstance(config, dict) else 0
-                effective = max(target, current_w, current_min_w)
-                if effective > 0:
-                    tree.column(column, width=effective, minwidth=effective, stretch=False)
-
-            if ring_width:
-                _resize_column("ring", ring_width, "Ring")
-            if type_width:
-                _resize_column("type", type_width, "Type")
-
-        self._update_pagination_controls(result)
-        self._resize_to_fit_results()
-
-        if not entries:
-            self._set_search_status("No hotspots matched the selected filters.")
-            return
-
-        status_parts = [f"Displaying {len(entries)} hotspot(s)"]
-        if result.total_count > len(entries):
-            status_parts.append(f"of {result.total_count} total matches")
-        if result.reference_system:
-            status_parts.append(f"near {result.reference_system}")
-        self._set_search_status("; ".join(status_parts))
-
-    def _handle_search_outcome(self, token: int, outcome: tuple[str, object]) -> None:
-        if not self.is_open:
-            return
-
-        if self._active_search_token is not None and token != self._active_search_token:
-            return
-
-        kind, payload = outcome
-        if kind == "success":
-            resolved_reference: Optional[str] = None
-            result_obj: Optional[HotspotSearchResult] = None
-            if isinstance(payload, tuple) and len(payload) == 2:
-                candidate_result, candidate_reference = payload
-                if isinstance(candidate_result, HotspotSearchResult):
-                    result_obj = candidate_result
-                if isinstance(candidate_reference, str) and candidate_reference:
-                    resolved_reference = candidate_reference
-            elif isinstance(payload, HotspotSearchResult):
-                result_obj = payload
-
-            if result_obj is None:
-                self._finalize_search_duration()
-                _log.warning("Unexpected search payload type: %r", type(payload))
-            else:
-                self._finalize_search_duration()
-                if resolved_reference:
-                    if (
-                        self._reference_system_var
-                        and self._reference_system_var.get().strip() != resolved_reference
-                    ):
-                        lowered = resolved_reference.strip().lower()
-                        self._reference_last_query = lowered
-                        self._reference_suggestions_suppressed = True
-                        self._reference_system_var.set(resolved_reference)
-                self._render_results(result_obj)
-        elif kind in {"value_error", "runtime_error"}:
-            message = str(payload) if payload else "An unexpected error occurred while searching for hotspots."
-            self._finalize_search_duration()
-            self._set_search_status(message)
-        else:
-            self._finalize_search_duration()
-            self._set_search_status("An unexpected error occurred while searching for hotspots.")
-
-        pending = self._controller.on_search_complete()
-        self._active_search_token = None
-        self._apply_pagination_button_state()
-        if pending is not None:
-            self._start_search(pending)
-
-    def _resize_to_fit_results(self) -> None:
-        if not self._toplevel or not self._results_tree:
-            return
-        try:
-            self._toplevel.update_idletasks()
-            if self._results_tree.winfo_exists():
-                self._results_tree.update_idletasks()
-            widths: List[int] = []
-            if self._results_frame and self._results_frame.winfo_exists():
-                widths.append(self._results_frame.winfo_reqwidth())
-            if self._hotspot_controls_frame and self._hotspot_controls_frame.winfo_exists():
-                widths.append(self._hotspot_controls_frame.winfo_reqwidth())
-            if self._hotspot_container and self._hotspot_container.winfo_exists():
-                widths.append(self._hotspot_container.winfo_reqwidth())
-            if self._results_tree and self._results_tree.winfo_exists():
-                total_columns = 0
-                for column in self._results_tree["columns"]:
-                    config = self._results_tree.column(column)
-                    if isinstance(config, dict):
-                        total_columns += config.get("width", 0)
-                if total_columns:
-                    widths.append(total_columns + 24)
-            if not widths:
-                widths.append(self._results_tree.winfo_reqwidth())
-            padding = 24  # container has padx=12 on each side
-            desired_width = max(widths) + padding
-            current_width = self._toplevel.winfo_width()
-            if current_width <= 1:
-                current_width = self._toplevel.winfo_reqwidth()
-            current_height = self._toplevel.winfo_height()
-            if current_height <= 1:
-                current_height = self._toplevel.winfo_reqheight()
-            desired_height = self._toplevel.winfo_reqheight()
-            if desired_height <= 1:
-                desired_height = current_height
-            target_width = max(current_width, int(desired_width))
-            target_height = max(current_height, int(desired_height))
-            self._toplevel.geometry(f"{target_width}x{target_height}")
-        except Exception:
-            pass
-
-    def _copy_system_to_clipboard(self, system_name: str) -> None:
-        if not self._toplevel or not system_name:
-            return
-        try:
-            self._toplevel.clipboard_clear()
-            self._toplevel.clipboard_append(system_name)
-            self._status_var.set(f"Copied '{system_name}' to clipboard")
-        except Exception:
-            _log.exception("Failed to copy system name to clipboard")
-
-    def _schedule_result_poll(self) -> None:
-        if not self._toplevel or not self._toplevel.winfo_exists():
-            return
-        if self._result_poll_job:
-            return
-        self._result_poll_job = self._toplevel.after(100, self._poll_search_results)
-
-    def _poll_search_results(self) -> None:
-        self._result_poll_job = None
-        if not self.is_open:
-            return
-
-        while True:
-            item = self._controller.poll_search_results()
-            if not item:
-                break
-            token, outcome = item
-            self._handle_search_outcome(token, outcome)
-
-        self._schedule_result_poll()
-
-
-__all__ = [
-    "HotspotSearchParams",
-    "HotspotSavedFilters",
-    "SearchStartResult",
-    "HotspotSearchController",
-    "HotspotSearchWindow",
-]
diff --git a/mining_ui/main_mining_ui.py b/mining_ui/main_mining_ui.py
deleted file mode 100644
index cee8468..0000000
--- a/mining_ui/main_mining_ui.py
+++ /dev/null
@@ -1,1885 +0,0 @@
-"""Tkinter UI for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-import logging
-import queue
-import random
-import threading
-from collections import Counter
-from dataclasses import dataclass
-from datetime import datetime, timezone
-from pathlib import Path
-from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple
-
-try:
-    import tkinter as tk
-    from tkinter import ttk
-    import tkinter.font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-from tooltip import WidgetTooltip
-from debugging import apply_frame_debugging, collect_frames
-from state import MiningState, compute_percentage_stats, update_rpm, resolve_commodity_display_name
-from integrations.mining_inara import InaraClient
-from integrations.spansh_hotspots import (
-    HotspotSearchResult,
-    RingHotspot,
-    SpanshHotspotClient,
-)
-from integrations.discord_image_manager import DiscordImageManager
-from integrations.edmcoverlay import determine_rpm_color
-from preferences import (
-    clamp_bin_size,
-    clamp_positive_int,
-    clamp_rate_interval,
-    clamp_session_retention,
-    clamp_overlay_coordinate,
-    clamp_overlay_interval,
-)
-from logging_utils import get_logger
-from edmc_mining_analytics_version import (
-    PLUGIN_VERSION,
-    PLUGIN_REPO_URL,
-    display_version,
-    is_newer_version,
-)
-from mining_ui.components.top_bar import build_top_bar
-from mining_ui.components.details_bar import build_details_bar
-from mining_ui.components.commodities_table import build_commodities_section
-from mining_ui.theme_adapter import ThemeAdapter
-from mining_ui.preferences import build_preferences as build_preferences_ui
-from mining_ui.histograms import (
-    close_histogram_window as _hist_close_window,
-    close_histogram_windows as _hist_close_windows,
-    draw_histogram as _hist_draw,
-    open_histogram_window as _hist_open,
-    recompute_histograms as _hist_recompute,
-    refresh_histogram_windows as _hist_refresh,
-)
-from mining_ui.hotspot_search_window import HotspotSearchController, HotspotSearchWindow
-
-_log = get_logger("ui")
-
-NON_METAL_WARNING_COLOR = "#ff4d4d"
-NON_METAL_WARNING_TEXT = " (Warning: Non-Metallic ring)"
-
-
-class edmcmaMiningUI:
-    """Encapsulates widget construction and refresh logic."""
-
-    # Draws helpful borders around frames for debugging layout issues
-    _DEBUG_DRAW_FRAMES = False
-
-    def __init__(
-        self,
-        state: MiningState,
-        inara: InaraClient,
-        hotspot_client: Optional[SpanshHotspotClient],
-        on_reset: Callable[[], None],
-        on_pause_changed: Optional[Callable[[bool, str, datetime], None]] = None,
-        on_reset_inferred_capacities: Optional[Callable[[], None]] = None,
-        on_test_webhook: Optional[Callable[[], None]] = None,
-        on_settings_changed: Optional[Callable[[], None]] = None,
-    ) -> None:
-        self._state = state
-        self._inara = inara
-        self._hotspot_client = hotspot_client
-        self._on_reset = on_reset
-        self._pause_callback = on_pause_changed
-        self._reset_capacities_callback = on_reset_inferred_capacities
-        self._test_webhook_callback = on_test_webhook
-        self._on_settings_changed = on_settings_changed
-        self._theme = ThemeAdapter()
-
-        self._discord_image_manager = DiscordImageManager(self._state)
-
-        self._frame: Optional[tk.Widget] = None
-        self._status_var: Optional[tk.StringVar] = None
-        self._reserve_var: Optional[tk.StringVar] = None
-        self._summary_var: Optional[tk.StringVar] = None
-        self._summary_label: Optional[tk.Label] = None
-        self._summary_tooltip: Optional[WidgetTooltip] = None
-        self._summary_inferred_bounds: Optional[Tuple[int, int, int, int]] = None
-        self._reserve_line: Optional[tk.Frame] = None
-        self._reserve_label: Optional[tk.Label] = None
-        self._reserve_warning_label: Optional[tk.Label] = None
-        self._rpm_var: Optional[tk.StringVar] = None
-        self._rpm_label: Optional[tk.Label] = None
-        self._rpm_title_label: Optional[tk.Label] = None
-        self._rpm_tooltip: Optional[WidgetTooltip] = None
-        self._rpm_font: Optional[tkfont.Font] = None
-        self._rpm_frame: Optional[tk.Frame] = None
-        self._rpm_display_value: float = 0.0
-        self._rpm_target_value: float = 0.0
-        self._rpm_animation_after: Optional[str] = None
-        self._pause_btn: Optional[tk.Button] = None
-        self._commodities_headers: list[tk.Label] = []
-        self._commodities_rows: list[list[tk.Label]] = []
-        self._commodities_header_tooltips: list[WidgetTooltip] = []
-        self._materials_header: Optional[tk.Frame] = None
-        self._materials_frame: Optional[tk.Frame] = None
-        self._materials_text: Optional[tk.Label] = None
-        self._total_tph_var: Optional[tk.StringVar] = None
-        self._total_tph_font: Optional[tkfont.Font] = None
-        self._content_widgets: Sequence[tk.Widget] = ()
-        self._version_label: Optional[tk.Label] = None
-        self._version_font: Optional[tkfont.Font] = None
-        self._show_commodities_var: Optional[tk.BooleanVar] = None
-        self._show_materials_var: Optional[tk.BooleanVar] = None
-        self._commodities_header: Optional[tk.Frame] = None
-        self._materials_header: Optional[tk.Frame] = None
-        self._commodities_frame: Optional[tk.Frame] = None
-        self._commodities_grid: Optional[Dict[str, Any]] = None
-        self._materials_grid: Optional[Dict[str, Any]] = None
-        self._commodity_columns: Sequence[Dict[str, Any]] = (
-            {
-                "key": "commodity",
-                "label": "Commodity",
-                "anchor": "w",
-                "sticky": "w",
-                "weight": 4,
-            },
-            {
-                "key": "present",
-                "label": "#",
-                "anchor": "e",
-                "sticky": "e",
-                "weight": 1,
-            },
-            {
-                "key": "percent",
-                "label": "%",
-                "anchor": "e",
-                "sticky": "e",
-                "weight": 1,
-            },
-            {
-                "key": "total",
-                "label": "Total",
-                "anchor": "e",
-                "sticky": "e",
-                "weight": 1,
-            },
-            {
-                "key": "range",
-                "label": "%Range",
-                "anchor": "e",
-                "sticky": "e",
-                "weight": 2,
-            },
-            {
-                "key": "tph",
-                "label": "Tons/hr",
-                "anchor": "e",
-                "sticky": "e",
-                "weight": 1,
-            },
-        )
-        self._materials_columns: Sequence[Dict[str, Any]] = ()
-        self._hotspot_controller: Optional[HotspotSearchController] = None
-        self._hotspot_window: Optional[HotspotSearchWindow] = None
-        self._hotspot_button: Optional[tk.Button] = None
-        self._hotspot_icon: Optional[tk.PhotoImage] = None
-
-        self._prefs_bin_var: Optional[tk.IntVar] = None
-        self._prefs_rate_var: Optional[tk.IntVar] = None
-        self._prefs_inara_mode_var: Optional[tk.IntVar] = None
-        self._prefs_inara_carriers_var: Optional[tk.BooleanVar] = None
-        self._prefs_inara_surface_var: Optional[tk.BooleanVar] = None
-        self._prefs_auto_unpause_var: Optional[tk.BooleanVar] = None
-        self._prefs_session_logging_var: Optional[tk.BooleanVar] = None
-        self._prefs_session_retention_var: Optional[tk.IntVar] = None
-        self._prefs_refinement_window_var: Optional[tk.IntVar] = None
-        self._prefs_rpm_red_var: Optional[tk.IntVar] = None
-        self._prefs_rpm_yellow_var: Optional[tk.IntVar] = None
-        self._prefs_rpm_green_var: Optional[tk.IntVar] = None
-        self._prefs_webhook_var: Optional[tk.StringVar] = None
-        self._prefs_send_summary_var: Optional[tk.BooleanVar] = None
-        self._prefs_send_reset_summary_var: Optional[tk.BooleanVar] = None
-        self._prefs_warn_non_metallic_var: Optional[tk.BooleanVar] = None
-        self._prefs_overlay_enabled_var: Optional[tk.BooleanVar] = None
-        self._prefs_overlay_x_var: Optional[tk.IntVar] = None
-        self._prefs_overlay_y_var: Optional[tk.IntVar] = None
-        self._prefs_overlay_interval_var: Optional[tk.IntVar] = None
-        self._reset_capacities_btn: Optional[ttk.Button] = None
-        self._send_summary_cb: Optional[ttk.Checkbutton] = None
-        self._send_reset_summary_cb: Optional[ttk.Checkbutton] = None
-        self._test_webhook_btn: Optional[ttk.Button] = None
-        self._session_path_feedback: Optional[tk.StringVar] = None
-        self._session_path_feedback_after: Optional[str] = None
-        self._overlay_controls: list[tk.Widget] = []
-        self._overlay_hint_label: Optional[tk.Label] = None
-        self._discord_images_tree: Optional[ttk.Treeview] = None
-        self._discord_image_ship_var: Optional[tk.StringVar] = None
-        self._discord_image_url_var: Optional[tk.StringVar] = None
-
-        self._hotspot_container: Optional[tk.Frame] = None
-        self._hotspot_controls_frame: Optional[tk.Frame] = None
-        self._results_frame: Optional[tk.Frame] = None
-        self._updating_bin_var = False
-        self._updating_rate_var = False
-        self._updating_inara_mode_var = False
-        self._updating_inara_carriers_var = False
-        self._updating_inara_surface_var = False
-        self._updating_session_logging_var = False
-        self._updating_session_retention_var = False
-        self._updating_refinement_window_var = False
-        self._updating_rpm_vars = False
-        self._updating_webhook_var = False
-        self._updating_send_summary_var = False
-        self._updating_send_reset_summary_var = False
-        self._updating_warn_non_metallic_var = False
-        self._updating_overlay_enabled_var = False
-        self._updating_overlay_x_var = False
-        self._updating_overlay_y_var = False
-        self._updating_overlay_interval_var = False
-
-        self._rate_update_job: Optional[str] = None
-        self._content_collapsed = False
-        self._hist_windows: Dict[str, tk.Toplevel] = {}
-        self._hist_canvases: Dict[str, tk.Canvas] = {}
-        self._details_visible = False
-        self._last_is_mining: Optional[bool] = None
-        self._rpm_update_job: Optional[str] = None
-
-    # ------------------------------------------------------------------
-    # Public API
-    # ------------------------------------------------------------------
-    def build(self, parent: tk.Widget) -> tk.Frame:
-        border = 1 if self._DEBUG_DRAW_FRAMES else 0
-        relief = tk.SOLID if border else tk.FLAT
-        frame = tk.Frame(parent, highlightthickness=border, bd=border, relief=relief)
-        self._frame = frame
-        self._theme.register(frame)
-        frame.columnconfigure(0, weight=1)
-
-        version_text = display_version(PLUGIN_VERSION)
-        plugin_dir = (
-            Path(self._state.plugin_dir)
-            if getattr(self._state, "plugin_dir", None)
-            else None
-        )
-        top_widgets = build_top_bar(
-            frame,
-            self._theme,
-            border=border,
-            relief=relief,
-            plugin_dir=plugin_dir,
-            repo_url=PLUGIN_REPO_URL,
-            version_text=version_text,
-            on_hotspot=self._handle_hotspot_button,
-            on_toggle_details=self._toggle_details,
-            warning_color=NON_METAL_WARNING_COLOR,
-        )
-        self._status_var = top_widgets.status_var
-        self._reserve_var = top_widgets.reserve_var
-        self._reserve_label = top_widgets.reserve_label
-        self._reserve_warning_label = top_widgets.reserve_warning_label
-        self._reserve_line = top_widgets.reserve_line
-        self._version_label = top_widgets.version_label
-        self._version_font = top_widgets.version_font
-        self._hotspot_button = top_widgets.hotspot_button
-        self._hotspot_icon = top_widgets.hotspot_icon
-        self._hotspot_tooltip = top_widgets.hotspot_tooltip
-        self._details_toggle = top_widgets.details_toggle
-
-        details_widgets = build_details_bar(
-            frame,
-            self._theme,
-            border=border,
-            relief=relief,
-            hover_predicate=self._is_pointer_over_inferred,
-        )
-        self._details_bar = details_widgets.frame
-        self._summary_var = details_widgets.summary_var
-        self._summary_label = details_widgets.summary_label
-        self._summary_tooltip = details_widgets.summary_tooltip
-        self._rpm_frame = details_widgets.rpm_frame
-        self._rpm_var = details_widgets.rpm_var
-        self._rpm_label = details_widgets.rpm_label
-        self._rpm_title_label = details_widgets.rpm_title_label
-        self._rpm_tooltip = details_widgets.rpm_tooltip
-        self._rpm_font = details_widgets.rpm_font
-
-        commodities_widgets = build_commodities_section(
-            frame,
-            self._theme,
-            columns=self._commodity_columns,
-            on_toggle=self._on_toggle_commodities,
-            header_style=self._schedule_header_style,
-            initial_visible=self._state.show_mined_commodities,
-        )
-        self._commodities_header = commodities_widgets.header_frame
-        self._show_commodities_var = commodities_widgets.toggle_var
-        self._commodities_frame = commodities_widgets.table_frame
-        self._commodities_grid = commodities_widgets.grid_config
-        self._commodities_headers = commodities_widgets.headers
-        self._commodities_rows = []
-        self._initialize_commodities_header_tooltips()
-
-        total_container = tk.Frame(frame, highlightthickness=0, bd=0)
-        total_container.grid(row=2, column=0, sticky="w", padx=4, pady=(0, 6))
-        self._theme.register(total_container)
-
-        self._total_tph_var = tk.StringVar(master=total_container, value="Total Tons/hr: -")
-        total_label = tk.Label(
-            total_container,
-            textvariable=self._total_tph_var,
-            anchor="w",
-        )
-        try:
-            base_font = tkfont.nametofont(total_label.cget("font"))
-            self._total_tph_font = tkfont.Font(font=base_font)
-            self._total_tph_font.configure(weight="bold")
-            total_label.configure(font=self._total_tph_font)
-        except tk.TclError:
-            self._total_tph_font = None
-        total_label.pack(side="left")
-        self._theme.register(total_label)
-
-        button_bar = tk.Frame(frame, highlightthickness=0, bd=0)
-        button_bar.grid(row=2, column=0, sticky="e", padx=4, pady=(0, 6))
-        self._theme.register(button_bar)
-
-        pause_btn = tk.Button(button_bar, text="Pause", command=self._toggle_pause, cursor="hand2")
-        self._theme.style_button(pause_btn)
-        pause_btn.grid(row=0, column=0, padx=(0, 4), pady=0)
-        self._pause_btn = pause_btn
-
-        reset_btn = tk.Button(button_bar, text="Reset", command=self._on_reset, cursor="hand2")
-        self._theme.style_button(reset_btn)
-        reset_btn.grid(row=0, column=1, padx=0, pady=0)
-
-        self._materials_header = self._build_materials_section(frame)
-
-        frame.columnconfigure(0, weight=1)
-        frame.rowconfigure(4, weight=1)
-        frame.rowconfigure(6, weight=0)
-
-        self._content_widgets = (
-            self._details_bar,
-            total_container,
-            button_bar,
-            self._commodities_header,
-            self._commodities_frame,
-            self._materials_header,
-            self._materials_frame,
-        )
-
-        self._update_pause_button()
-
-        self._apply_initial_visibility()
-        self._apply_table_visibility()
-
-        self._update_rpm_indicator()
-        # Ensure RPM continues to evaluate over time, even without events
-        self._schedule_rpm_update()
-        if self._DEBUG_DRAW_FRAMES:
-            frames = collect_frames(frame, include_root=True)
-            frame.after_idle(lambda fr=frames: apply_frame_debugging(fr))
-
-        return frame
-
-    def _schedule_rpm_update(self) -> None:
-        frame = self._frame
-        if frame is None or not frame.winfo_exists():
-            return
-        # Avoid multiple scheduled jobs
-        if self._rpm_update_job is not None:
-            return
-        # Always keep RPM evaluated on a timer so it decays after the window
-        self._rpm_update_job = frame.after(1000, self._on_rpm_update_tick)
-
-    def _cancel_rpm_update(self) -> None:
-        frame = self._frame
-        if self._rpm_update_job and frame and frame.winfo_exists():
-            try:
-                frame.after_cancel(self._rpm_update_job)
-            except Exception:
-                pass
-        self._rpm_update_job = None
-
-    def _on_rpm_update_tick(self) -> None:
-        # Clear the handle first to allow rescheduling even if exceptions occur
-        self._rpm_update_job = None
-        # Respect pause if the user paused updates
-        if not self._state.is_paused:
-            self._update_rpm_indicator()
-        # Reschedule if the UI is still alive
-        self._schedule_rpm_update()
-
-    def update_version_label(
-        self,
-        current_version: str,
-        latest_version: Optional[str],
-        update_ready: bool,
-    ) -> None:
-        label = self._version_label
-        if label is None or not getattr(label, "winfo_exists", lambda: False)():
-            return
-        text = display_version(current_version)
-        if latest_version:
-            if is_newer_version(latest_version, current_version):
-                if update_ready:
-                    text = f"{text} (restart to update)"
-                else:
-                    text = f"{text} (a newer version exists)"
-            elif is_newer_version(current_version, latest_version):
-                text = f"{text} (development)"
-        label.configure(text=text)
-
-    def refresh(self) -> None:
-        self._update_pause_button()
-        self._refresh_status_line()
-        self._populate_tables()
-        self._update_overlay_controls()
-
-    def _on_auto_unpause_change(self, *_: object) -> None:
-        if self._prefs_auto_unpause_var is None:
-            return
-        try:
-            value = bool(self._prefs_auto_unpause_var.get())
-        except (tk.TclError, ValueError):
-            return
-        self._state.auto_unpause_on_event = value
-
-    def _on_warn_non_metallic_change(self, *_: object) -> None:
-        if (
-            self._prefs_warn_non_metallic_var is None
-            or self._updating_warn_non_metallic_var
-        ):
-            return
-        try:
-            value = bool(self._prefs_warn_non_metallic_var.get())
-        except (tk.TclError, ValueError):
-            return
-        if value == self._state.warn_on_non_metallic_ring:
-            return
-        self._state.warn_on_non_metallic_ring = value
-        self._notify_settings_changed()
-        self._refresh_status_line()
-
-    def _on_overlay_enabled_change(self, *_: object) -> None:
-        if self._prefs_overlay_enabled_var is None or self._updating_overlay_enabled_var:
-            return
-        try:
-            value = bool(self._prefs_overlay_enabled_var.get())
-        except (tk.TclError, ValueError):
-            return
-        if value == self._state.overlay_enabled:
-            return
-        self._state.overlay_enabled = value
-        self._notify_settings_changed()
-
-    def _on_overlay_anchor_x_change(self, *_: object) -> None:
-        if self._prefs_overlay_x_var is None or self._updating_overlay_x_var:
-            return
-        try:
-            raw_value = int(self._prefs_overlay_x_var.get())
-        except (tk.TclError, TypeError, ValueError):
-            return
-        clamped = clamp_overlay_coordinate(raw_value, self._state.overlay_anchor_x)
-        if clamped == self._state.overlay_anchor_x:
-            return
-        self._state.overlay_anchor_x = clamped
-        self._updating_overlay_x_var = True
-        self._prefs_overlay_x_var.set(clamped)
-        self._updating_overlay_x_var = False
-        self._notify_settings_changed()
-
-    def _on_overlay_anchor_y_change(self, *_: object) -> None:
-        if self._prefs_overlay_y_var is None or self._updating_overlay_y_var:
-            return
-        try:
-            raw_value = int(self._prefs_overlay_y_var.get())
-        except (tk.TclError, TypeError, ValueError):
-            return
-        clamped = clamp_overlay_coordinate(raw_value, self._state.overlay_anchor_y)
-        if clamped == self._state.overlay_anchor_y:
-            return
-        self._state.overlay_anchor_y = clamped
-        self._updating_overlay_y_var = True
-        self._prefs_overlay_y_var.set(clamped)
-        self._updating_overlay_y_var = False
-        self._notify_settings_changed()
-
-    def _on_overlay_interval_change(self, *_: object) -> None:
-        if self._prefs_overlay_interval_var is None or self._updating_overlay_interval_var:
-            return
-        try:
-            raw_value = int(self._prefs_overlay_interval_var.get())
-        except (tk.TclError, TypeError, ValueError):
-            return
-        clamped = clamp_overlay_interval(raw_value, self._state.overlay_refresh_interval_ms)
-        if clamped == self._state.overlay_refresh_interval_ms:
-            return
-        self._state.overlay_refresh_interval_ms = clamped
-        self._updating_overlay_interval_var = True
-        self._prefs_overlay_interval_var.set(clamped)
-        self._updating_overlay_interval_var = False
-        self._notify_settings_changed()
-
-    def _update_overlay_controls(self) -> None:
-        controls = tuple(self._overlay_controls)
-        available = self._state.overlay_available
-        desired_state = tk.NORMAL if available else tk.DISABLED
-        for widget in controls:
-            if widget is None:
-                continue
-            try:
-                widget.configure(state=desired_state)
-            except tk.TclError:
-                continue
-        hint = self._overlay_hint_label
-        if hint is not None:
-            try:
-                if available:
-                    hint.configure(text="")
-                    hint.grid_remove()
-                else:
-                    hint.configure(
-                        text="EDMCOverlay plugin not detected. Install it to enable in-game metrics."
-                    )
-                    hint.grid(row=4, column=0, columnspan=2, sticky="w", pady=(6, 4))
-            except tk.TclError:
-                pass
-
-    def _on_session_logging_change(self, *_: object) -> None:
-        if (
-            self._prefs_session_logging_var is None
-            or self._updating_session_logging_var
-        ):
-            return
-        try:
-            value = bool(self._prefs_session_logging_var.get())
-        except (tk.TclError, ValueError):
-            return
-        if value == self._state.session_logging_enabled:
-            return
-        self._state.session_logging_enabled = value
-
-    def _on_session_retention_change(self, *_: object) -> None:
-        if (
-            self._prefs_session_retention_var is None
-            or self._updating_session_retention_var
-        ):
-            return
-        try:
-            value = int(self._prefs_session_retention_var.get())
-        except (tk.TclError, ValueError, TypeError):
-            return
-        limit = clamp_session_retention(value)
-        if limit == self._state.session_log_retention:
-            return
-        self._state.session_log_retention = limit
-        if self._prefs_session_retention_var.get() != limit:
-            self._updating_session_retention_var = True
-            self._prefs_session_retention_var.set(limit)
-            self._updating_session_retention_var = False
-
-    def _copy_session_log_path(self) -> None:
-        frame = self._frame
-        if frame is None:
-            return
-        plugin_dir = self._state.plugin_dir
-        if plugin_dir is None:
-            self._update_session_path_feedback("Plugin folder unavailable")
-            _log.warning("Unable to copy session log path; plugin directory unknown")
-            return
-
-        target = (plugin_dir / "session_data").resolve()
-        try:
-            frame.clipboard_clear()
-            frame.clipboard_append(str(target))
-            frame.update_idletasks()
-        except Exception:
-            self._update_session_path_feedback("Copy failed")
-            _log.exception("Failed to copy session log directory to clipboard")
-            return
-
-        self._update_session_path_feedback("Copied folder path")
-
-    def _update_session_path_feedback(self, message: str, *, clear_after: int = 3000) -> None:
-        var = self._session_path_feedback
-        frame = self._frame
-        if var is None or frame is None:
-            return
-
-        var.set(message)
-        if self._session_path_feedback_after is not None:
-            try:
-                frame.after_cancel(self._session_path_feedback_after)
-            except Exception:
-                pass
-            self._session_path_feedback_after = None
-
-        if message:
-            self._session_path_feedback_after = frame.after(
-                clear_after,
-                self._clear_session_path_feedback,
-            )
-
-    def _clear_session_path_feedback(self) -> None:
-        self._session_path_feedback_after = None
-        if self._session_path_feedback is not None:
-            self._session_path_feedback.set("")
-
-    def _on_reset_inferred_capacities(self) -> None:
-        callback = self._reset_capacities_callback
-        if not callback:
-            return
-        try:
-            callback()
-        except Exception:
-            _log.exception("Failed to reset inferred cargo capacities")
-
-    def _on_webhook_change(self, *_: object) -> None:
-        if self._prefs_webhook_var is None or self._updating_webhook_var:
-            return
-        value = self._prefs_webhook_var.get()
-        trimmed = value.strip() if isinstance(value, str) else ""
-        self._state.discord_webhook_url = trimmed
-        if not trimmed and self._state.send_summary_to_discord:
-            self._state.send_summary_to_discord = False
-            if self._prefs_send_summary_var is not None:
-                self._updating_send_summary_var = True
-                self._prefs_send_summary_var.set(False)
-                self._updating_send_summary_var = False
-        self._update_discord_controls()
-
-    def _on_send_summary_change(self, *_: object) -> None:
-        if self._prefs_send_summary_var is None or self._updating_send_summary_var:
-            return
-        try:
-            value = bool(self._prefs_send_summary_var.get())
-        except (tk.TclError, ValueError):
-            return
-        if value and not self._state.discord_webhook_url:
-            self._updating_send_summary_var = True
-            self._prefs_send_summary_var.set(False)
-            self._updating_send_summary_var = False
-            self._state.send_summary_to_discord = False
-            return
-        self._state.send_summary_to_discord = value
-        self._update_discord_controls()
-
-    def _on_send_reset_summary_change(self, *_: object) -> None:
-        if (
-            self._prefs_send_reset_summary_var is None
-            or self._updating_send_reset_summary_var
-        ):
-            return
-        try:
-            value = bool(self._prefs_send_reset_summary_var.get())
-        except (tk.TclError, ValueError):
-            return
-        if value and not self._state.discord_webhook_url:
-            self._updating_send_reset_summary_var = True
-            self._prefs_send_reset_summary_var.set(False)
-            self._updating_send_reset_summary_var = False
-            self._state.send_reset_summary = False
-            return
-        self._state.send_reset_summary = value
-        self._update_discord_controls()
-
-    def _on_test_webhook(self) -> None:
-        callback = self._test_webhook_callback
-        if not callback:
-            return
-        try:
-            callback()
-        except ValueError as exc:
-            _log.warning("Test webhook failed: %s", exc)
-        except Exception:
-            _log.exception("Failed to invoke webhook test")
-
-    def _update_discord_controls(self) -> None:
-        has_url = bool(self._state.discord_webhook_url.strip())
-        if not has_url and self._state.send_summary_to_discord:
-            self._state.send_summary_to_discord = False
-            if self._prefs_send_summary_var is not None:
-                self._updating_send_summary_var = True
-                self._prefs_send_summary_var.set(False)
-                self._updating_send_summary_var = False
-        elif has_url and self._prefs_send_summary_var is not None:
-            self._updating_send_summary_var = True
-            self._prefs_send_summary_var.set(bool(self._state.send_summary_to_discord))
-            self._updating_send_summary_var = False
-        if not has_url and self._state.send_reset_summary:
-            self._state.send_reset_summary = False
-            if self._prefs_send_reset_summary_var is not None:
-                self._updating_send_reset_summary_var = True
-                self._prefs_send_reset_summary_var.set(False)
-                self._updating_send_reset_summary_var = False
-        elif has_url and self._prefs_send_reset_summary_var is not None:
-            self._updating_send_reset_summary_var = True
-            self._prefs_send_reset_summary_var.set(bool(self._state.send_reset_summary))
-            self._updating_send_reset_summary_var = False
-        if self._send_summary_cb is not None:
-            try:
-                self._send_summary_cb.configure(state=tk.NORMAL if has_url else tk.DISABLED)
-            except tk.TclError:
-                pass
-        if self._send_reset_summary_cb is not None:
-            try:
-                self._send_reset_summary_cb.configure(state=tk.NORMAL if has_url else tk.DISABLED)
-            except tk.TclError:
-                pass
-        if self._test_webhook_btn is not None:
-            try:
-                self._test_webhook_btn.configure(state=tk.NORMAL if has_url else tk.DISABLED)
-            except tk.TclError:
-                pass
-
-    def _refresh_discord_image_list(self) -> None:
-        tree = self._discord_images_tree
-        if tree is None:
-            return
-        for item in tree.get_children():
-            tree.delete(item)
-        entries = self._discord_image_manager.list_images()
-        for idx, (ship, url) in enumerate(entries):
-            display_ship = ship if ship else "Any"
-            tree.insert("", "end", iid=str(idx), values=(display_ship, url))
-
-    def _on_discord_image_add(self) -> None:
-        if not self._discord_image_url_var:
-            return
-        url = self._discord_image_url_var.get().strip()
-        if not url:
-            return
-        ship = self._discord_image_ship_var.get().strip() if self._discord_image_ship_var else ""
-        self._discord_image_manager.add_image(ship, url)
-        if self._discord_image_ship_var:
-            self._discord_image_ship_var.set("")
-        if self._discord_image_url_var:
-            self._discord_image_url_var.set("")
-        self._refresh_discord_image_list()
-        if self._on_settings_changed:
-            try:
-                self._on_settings_changed()
-            except Exception:
-                _log.exception("Failed to propagate settings change after adding Discord image")
-
-    def _on_discord_image_delete(self) -> None:
-        tree = self._discord_images_tree
-        if tree is None:
-            return
-        selection = tree.selection()
-        if not selection:
-            return
-        indices: List[int] = []
-        for item in selection:
-            try:
-                indices.append(int(item))
-            except ValueError:
-                continue
-        if not indices:
-            return
-        self._discord_image_manager.remove_indices(indices)
-        self._refresh_discord_image_list()
-        if self._on_settings_changed:
-            try:
-                self._on_settings_changed()
-            except Exception:
-                _log.exception("Failed to propagate settings change after removing Discord image")
-
-    def schedule_rate_update(self) -> None:
-        frame = self._frame
-        if frame is None or not frame.winfo_exists():
-            return
-
-        if not self._state.is_mining or self._state.is_paused:
-            self.cancel_rate_update()
-            return
-
-        self.cancel_rate_update()
-        interval = clamp_rate_interval(self._state.rate_interval_seconds)
-        jitter = random.uniform(-0.2, 0.2) * interval
-        delay_ms = max(1000, int((interval + jitter) * 1000))
-        self._rate_update_job = frame.after(delay_ms, self._on_rate_update_tick)
-
-    def cancel_rate_update(self) -> None:
-        frame = self._frame
-        if self._rate_update_job and frame and frame.winfo_exists():
-            try:
-                frame.after_cancel(self._rate_update_job)
-            except Exception:
-                pass
-        self._rate_update_job = None
-
-    def _handle_hotspot_button(self) -> None:
-        if not self._hotspot_client:
-            _log.debug("Hotspot client not available; skipping search window request.")
-            return
-
-        frame = self._frame
-        if frame is None or not frame.winfo_exists():
-            return
-
-        if self._hotspot_controller is None:
-            self._hotspot_controller = HotspotSearchController(self._state, self._hotspot_client)
-
-        window = self._hotspot_window
-        if window and window.is_open:
-            window.focus()
-            return
-
-        self._hotspot_window = HotspotSearchWindow(
-            parent=frame,
-            theme=self._theme,
-            controller=self._hotspot_controller,
-            on_close=self._on_hotspot_window_closed,
-        )
-
-    def _on_hotspot_window_closed(self, window: HotspotSearchWindow) -> None:
-        if self._hotspot_window is window:
-            self._hotspot_window = None
-
-    def _toggle_details(self) -> None:
-        self._details_visible = not self._details_visible
-        self._sync_details_visibility()
-
-    def _apply_initial_visibility(self) -> None:
-        self._details_visible = bool(self._state.is_mining)
-        self._last_is_mining = self._state.is_mining
-        self._sync_details_visibility()
-
-    def _sync_details_visibility(self) -> None:
-        visible = self._details_visible
-        for widget in self._content_widgets:
-            if visible:
-                widget.grid()
-            else:
-                widget.grid_remove()
-        if visible:
-            self._apply_table_visibility()
-        if self._details_toggle:
-            label = "Hide Details" if visible else "Show Details"
-            try:
-                self._details_toggle.configure(text=label)
-            except Exception:
-                pass
-
-    def _apply_table_visibility(self) -> None:
-        self._apply_commodities_visibility()
-        self._apply_materials_visibility()
-
-    def _apply_commodities_visibility(self) -> None:
-        frame = self._commodities_frame
-        if frame is None:
-            return
-        if not self._details_visible:
-            frame.grid_remove()
-            return
-        should_show = self._bool_from_var(self._show_commodities_var, default=True)
-        if should_show:
-            self._restore_grid(frame, self._commodities_grid)
-        else:
-            frame.grid_remove()
-
-    def _apply_materials_visibility(self) -> None:
-        frame = self._materials_frame
-        if frame is None:
-            return
-        if not self._details_visible:
-            frame.grid_remove()
-            return
-        should_show = self._bool_from_var(self._show_materials_var, default=True)
-        if should_show:
-            self._restore_grid(frame, self._materials_grid)
-        else:
-            frame.grid_remove()
-
-    def _notify_settings_changed(self) -> None:
-        callback = self._on_settings_changed
-        if callback is None:
-            return
-        try:
-            callback()
-        except Exception:
-            _log.exception("Failed to persist UI settings")
-
-    def _on_toggle_commodities(self) -> None:
-        self._state.show_mined_commodities = self._bool_from_var(
-            self._show_commodities_var, default=True
-        )
-        self._apply_commodities_visibility()
-        self._notify_settings_changed()
-
-    def _on_toggle_materials(self) -> None:
-        self._state.show_materials_collected = self._bool_from_var(
-            self._show_materials_var, default=True
-        )
-        self._apply_materials_visibility()
-        self._notify_settings_changed()
-
-    def _restore_grid(self, widget: tk.Widget, grid_options: Optional[Dict[str, Any]]) -> None:
-        if grid_options is None:
-            widget.grid()
-            return
-        widget.grid(**grid_options)
-
-    @staticmethod
-    def _bool_from_var(var: Optional[tk.BooleanVar], default: bool) -> bool:
-        if var is None:
-            return default
-        try:
-            return bool(var.get())
-        except (tk.TclError, ValueError):
-            return default
-
-    def build_preferences(self, parent: tk.Widget) -> tk.Widget:
-        return build_preferences_ui(self, parent)
-
-
-    def get_root(self) -> Optional[tk.Widget]:
-        return self._frame
-
-    def clear_transient_widgets(self, *, close_histograms: bool = True) -> None:
-        if close_histograms:
-            self.close_histogram_windows()
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _refresh_status_line(self) -> None:
-        status_var = self._status_var
-        summary_var = self._summary_var
-        if status_var is None or summary_var is None:
-            return
-
-        if self._state.is_mining:
-            if self._state.mining_location:
-                status_base = f"You're mining {self._state.mining_location}"
-            else:
-                status_base = "You're mining!"
-        else:
-            status_base = "Not mining"
-
-        prefix = "[PAUSED] " if self._state.is_paused else ""
-        status_text = f"{prefix}{status_base}" if prefix else status_base
-
-        summary_lines = self._status_summary_lines()
-
-        reserve_text = ""
-        warning_text = ""
-        if self._state.is_mining:
-            reserve_text = self._format_edsm_info()
-            warning_text = self._non_metal_warning_text()
-
-        status_var.set(status_text)
-        reserve_var = self._reserve_var
-        if reserve_var is not None:
-            reserve_var.set(reserve_text)
-        reserve_line = self._reserve_line
-        if reserve_line is not None:
-            if reserve_text:
-                reserve_line.grid()
-            else:
-                reserve_line.grid_remove()
-        warning_label = self._reserve_warning_label
-        if warning_label is not None:
-            warning_label.configure(text=warning_text, foreground=NON_METAL_WARNING_COLOR)
-        summary_var.set("\n".join(summary_lines))
-        self._update_summary_tooltip()
-        self._update_rpm_indicator()
-
-        if self._last_is_mining is None or self._last_is_mining != self._state.is_mining:
-            self._details_visible = bool(self._state.is_mining)
-            self._sync_details_visibility()
-            # Align RPM timer with mining activity
-            if self._state.is_mining and not self._state.is_paused:
-                self._schedule_rpm_update()
-            else:
-                self._cancel_rpm_update()
-        self._last_is_mining = self._state.is_mining
-
-    def _status_summary_lines(self) -> list[str]:
-        lines: list[str] = []
-        if self._state.mining_start:
-            if self._state.mining_end and not self._state.is_mining:
-                elapsed = self._calculate_elapsed_seconds(self._state.mining_start, self._state.mining_end)
-                lines.append(f"Elapsed: {self._format_duration(elapsed)}")
-            else:
-                start_dt = self._ensure_aware(self._state.mining_start).astimezone(timezone.utc)
-                lines.append(f"Started: {start_dt.strftime('%Y-%m-%d %H:%M:%S UTC')}")
-        else:
-            label = "Elapsed" if self._state.mining_end and not self._state.is_mining else "Started"
-            lines.append(f"{label}: --")
-
-        lines.append(
-            f"Prospected: {self._state.prospected_count} | Already mined: {self._state.already_mined_count} | Dupes: {self._state.duplicate_prospected}"
-        )
-
-        lost = max(0, self._state.prospector_launched_count - self._state.prospected_count)
-        content_line = ""
-        if self._state.prospect_content_counts:
-            content_line = " | Content: " + ", ".join(
-                f"{key[0]}:{self._state.prospect_content_counts.get(key, 0)}"
-                for key in ("High", "Medium", "Low")
-            )
-        lines.append(
-            f"Prospectors: Launched: {self._state.prospector_launched_count} | Lost: {lost}{content_line}"
-        )
-
-        limpets = (
-            f"Limpets remaining: {self._state.limpets_remaining}"
-            if self._state.limpets_remaining is not None
-            else None
-        )
-        drones = f"Collectors launched: {self._state.collection_drones_launched}"
-        abandoned = (
-            f"Limpets abandoned: {self._state.abandoned_limpets}"
-            if self._state.abandoned_limpets > 0
-            else None
-        )
-        third = " | ".join(x for x in [limpets, drones, abandoned] if x)
-        if third:
-            lines.append(third)
-
-        if not (self._state.cargo_totals or self._state.cargo_additions):
-            lines.append("No cargo data yet")
-
-        mined_cargo = max(0, self._state.current_cargo_tonnage)
-        limpets_onboard = self._state.limpets_remaining if self._state.limpets_remaining is not None else 0
-        total_cargo = mined_cargo + max(0, limpets_onboard)
-        capacity = self._state.cargo_capacity
-        if capacity is not None and capacity > 0:
-            capacity_text = f"{capacity}t"
-            if self._state.cargo_capacity_is_inferred:
-                capacity_text = f"{capacity_text} (Inferred)"
-            remaining = max(0, capacity - total_cargo)
-            percent_full = ((capacity - remaining) / capacity) * 100.0
-            summary = (
-                f"Cargo: {total_cargo}t | Capacity: {capacity_text} | Remaining: {remaining}t | {percent_full:.1f}% full"
-            )
-            lines.append(summary)
-        else:
-            remaining_label = "unknown"
-            lines.append(
-                f"Cargo: {total_cargo}t | Capacity: unknown | Remaining: {remaining_label} | % full: unknown"
-            )
-
-        return lines
-
-    def _format_edsm_info(self) -> str:
-        reserve = (self._state.edsm_reserve_level or "").strip()
-        ring_type = (self._state.edsm_ring_type or "").strip()
-        parts = [value for value in (reserve, ring_type) if value]
-        return " ".join(parts)
-
-    def _non_metal_warning_text(self) -> str:
-        if not (self._state.warn_on_non_metallic_ring and self._state.is_mining):
-            return ""
-        ring_type = (self._state.edsm_ring_type or "").strip()
-        if not ring_type:
-            return ""
-        if "metallic" in ring_type.lower():
-            return ""
-        return NON_METAL_WARNING_TEXT
-
-    def _update_summary_tooltip(self) -> None:
-        tooltip = self._summary_tooltip
-        if tooltip is None:
-            return
-        bounds: Optional[Tuple[int, int, int, int]] = None
-        text: Optional[str] = None
-        if self._state.cargo_capacity_is_inferred and self._state.cargo_capacity:
-            summary_label = self._summary_label
-            summary_text = self._summary_var.get() if self._summary_var is not None else None
-            if summary_label and summary_text:
-                bounds = self._compute_inferred_bounds(summary_label, summary_text)
-            text = (
-                "The plugin can't yet determine the cargo capacity. Try swapping ships, or filling your hold completely full of limpets."
-            )
-        tooltip.set_text(text)
-        self._summary_inferred_bounds = bounds
-
-    def _compute_inferred_bounds(self, label: tk.Label, text: str) -> Optional[Tuple[int, int, int, int]]:
-        target = "(Inferred)"
-        index = text.find(target)
-        if index == -1:
-            return None
-        prefix = text[:index]
-        lines = prefix.split("\n")
-        line_index = max(0, len(lines) - 1)
-        preceding = lines[-1] if lines else ""
-        font = tkfont.nametofont(label.cget("font"))
-        line_height = font.metrics("linespace")
-
-        def _to_int(value: str) -> int:
-            try:
-                return int(float(value))
-            except (TypeError, ValueError):
-                return 0
-
-        pad_x = _to_int(label.cget("padx"))
-        pad_y = _to_int(label.cget("pady"))
-        border = _to_int(label.cget("borderwidth"))
-        highlight = _to_int(label.cget("highlightthickness"))
-
-        x_base = pad_x + border + highlight
-        y_base = pad_y + border + highlight
-
-        x_start = x_base + font.measure(preceding)
-        x_end = x_start + font.measure(target)
-        y_start = y_base + line_index * line_height
-        y_end = y_start + line_height
-        return (int(x_start), int(y_start), int(x_end), int(y_end))
-
-    def _is_pointer_over_inferred(self, x: int, y: int) -> bool:
-        bounds = self._summary_inferred_bounds
-        if not bounds:
-            return False
-        x1, y1, x2, y2 = bounds
-        return x1 <= x <= x2 and y1 <= y <= y2
-
-    def _update_rpm_indicator(self) -> None:
-        rpm_label = self._rpm_label
-        rpm_var = self._rpm_var
-        if rpm_label is None or rpm_var is None:
-            return
-
-        now = datetime.now(timezone.utc)
-        rpm = update_rpm(self._state, now)
-        self._start_rpm_animation(rpm)
-
-        tooltip = self._rpm_tooltip
-        if tooltip is not None:
-            lookback = max(1, int(self._state.refinement_lookback_seconds or 1))
-            tooltip.set_text(
-                (
-                    f"Refinements per minute over the last {lookback} seconds.\n"
-                    f"Session max RPM: {self._state.max_rpm:.1f}"
-                )
-            )
-
-    def _determine_rpm_color(self, rpm: float) -> str:
-        default_color = self._theme.default_text_color()
-        return determine_rpm_color(self._state, rpm, default=default_color)
-
-    def _start_rpm_animation(self, target_rpm: float) -> None:
-        self._rpm_target_value = target_rpm
-        if self._frame is None:
-            return
-
-        if self._rpm_animation_after is not None:
-            try:
-                self._frame.after_cancel(self._rpm_animation_after)
-            except Exception:
-                pass
-            self._rpm_animation_after = None
-
-        if abs(self._rpm_display_value - target_rpm) < 0.05:
-            self._set_rpm_display(target_rpm)
-            return
-
-        self._schedule_rpm_step()
-
-    def _schedule_rpm_step(self) -> None:
-        frame = self._frame
-        if frame is None:
-            return
-        self._rpm_animation_after = frame.after(50, self._animate_rpm_step)
-
-    def _animate_rpm_step(self) -> None:
-        target_rpm = self._rpm_target_value
-        current_display = self._rpm_display_value
-
-        delta = target_rpm - current_display
-        if abs(delta) < 0.05:
-            self._set_rpm_display(target_rpm)
-            self._rpm_animation_after = None
-            return
-
-        step = 0.2 if delta > 0 else -0.2
-        next_value = round(current_display + step, 1)
-        self._set_rpm_display(next_value)
-        self._schedule_rpm_step()
-
-    def _set_rpm_display(self, value: float) -> None:
-        self._rpm_display_value = value
-        rpm_var = self._rpm_var
-        if rpm_var is not None:
-            rpm_var.set(f"{value:.1f}")
-
-        color = self._determine_rpm_color(value)
-        self._state.rpm_display_color = color
-        if self._rpm_label is not None:
-            try:
-                self._rpm_label.configure(foreground=color)
-            except tk.TclError:
-                pass
-
-    def _populate_tables(self) -> None:
-        commodities_parent = self._commodities_frame
-        if commodities_parent and getattr(commodities_parent, "winfo_exists", lambda: False)():
-            self._populate_commodities_table()
-
-        materials_label = self._materials_text
-        if materials_label and getattr(materials_label, "winfo_exists", lambda: False)():
-            self._populate_materials_table()
-
-        if self._total_tph_var is not None:
-            total_rate = self._compute_total_tph()
-            total_amount = sum(self._state.cargo_additions.values())
-            if total_rate is None:
-                self._total_tph_var.set("Total Tons/hr: -")
-            else:
-                duration = 0.0
-                if self._state.mining_start:
-                    start_time = self._ensure_aware(self._state.mining_start)
-                    end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-                    duration = max(0.0, (end_time - start_time).total_seconds())
-                duration_str = self._format_duration(duration)
-                self._total_tph_var.set(
-                    f"Total Tons/hr: {self._format_rate(total_rate)} ({total_amount}t over {duration_str})"
-                )
-
-        self._refresh_histogram_windows()
-
-    def _ensure_commodity_row(self, row_index: int) -> list[tk.Label]:
-        parent = self._commodities_frame
-        if parent is None or not getattr(parent, "winfo_exists", lambda: False)():
-            raise RuntimeError("Commodities frame is not available")
-
-        while len(self._commodities_rows) <= row_index:
-            grid_row = len(self._commodities_rows) + 1
-            row_labels: list[tk.Label] = []
-            for col_index, column in enumerate(self._commodity_columns):
-                label = tk.Label(
-                    parent,
-                    text="",
-                    anchor=column["anchor"],
-                    justify=tk.LEFT,
-                )
-                label.grid(
-                    row=grid_row,
-                    column=col_index,
-                    sticky=column["sticky"],
-                    padx=(0, 6),
-                    pady=(0, 1),
-                )
-                label.grid_remove()
-                self._theme.register(label)
-                row_labels.append(label)
-            self._commodities_rows.append(row_labels)
-        return self._commodities_rows[row_index]
-
-    def _apply_label_style(
-        self,
-        label: tk.Label,
-        *,
-        text: str,
-        foreground: Optional[str] = None,
-        cursor: str = "",
-        clickable: bool = False,
-    ) -> None:
-        label.configure(text=text)
-        try:
-            bg = label.master.cget("background")
-            label.configure(background=bg)
-        except tk.TclError:
-            pass
-        # Always set a foreground: use provided color or theme default.
-        effective_fg = foreground if foreground is not None else self._theme.default_text_color()
-        try:
-            label.configure(foreground=effective_fg)
-        except tk.TclError:
-            pass
-        if cursor:
-            label.configure(cursor=cursor)
-        else:
-            label.configure(cursor="hand2" if clickable else "")
-
-    def _schedule_header_style(self, label: tk.Label) -> None:
-        def _apply() -> None:
-            try:
-                base = tkfont.nametofont("TkDefaultFont")
-                actual = base.actual()
-                size = actual.get("size", 10)
-                if isinstance(size, str):
-                    size = int(size)
-                size = abs(int(size)) or 10
-                font_obj = tkfont.Font(
-                    family=actual.get("family", "TkDefaultFont"),
-                    size=size,
-                    weight="bold",
-                    underline=1,
-                    slant=actual.get("slant", "roman"),
-                    overstrike=actual.get("overstrike", 0),
-                )
-                label.configure(font=font_obj)
-                setattr(label, "_edmcma_header_font", font_obj)
-            except (tk.TclError, ValueError):
-                pass
-
-        label.after_idle(_apply)
-        label.bind("<<ThemeChanged>>", lambda _e: label.after_idle(_apply), add="+")
-        try:
-            base = tkfont.nametofont("TkDefaultFont")
-            actual = base.actual()
-            size = actual.get("size", 10)
-            if isinstance(size, str):
-                size = int(size)
-            size = abs(int(size))
-            font_tuple = (
-                actual.get("family", "TkDefaultFont"),
-                size,
-                "bold",
-            )
-            label.configure(font=font_tuple)
-            label.bind("<<ThemeChanged>>", lambda _e, lbl=label: self._apply_header_style(lbl), add="+")
-        except (tk.TclError, ValueError):
-            pass
-
-    def _initialize_commodities_header_tooltips(self) -> None:
-        tooltip_texts = {
-            "present": "Number of prospecting samples that reported this commodity during the current session.",
-            "percent": "Percentage of prospected asteroids that contained this commodity.",
-            "total": "Tons of this commodity currently in your cargo hold.",
-            "range": "Observed % yield range from prospecting samples, including minimum, average, and maximum values.",
-            "tph": "Estimated tons per hour mined for this commodity.",
-        }
-        self._commodities_header_tooltips = []
-        for header, column in zip(self._commodities_headers, self._commodity_columns):
-            text = tooltip_texts.get(column.get("key"))
-            if not text:
-                continue
-            self._commodities_header_tooltips.append(WidgetTooltip(header, text=text))
-
-    def _build_materials_section(self, parent: tk.Widget) -> tk.Frame:
-        header_frame = tk.Frame(parent, highlightthickness=0, bd=0)
-        header_frame.grid(row=5, column=0, sticky="w", padx=4)
-        self._theme.register(header_frame)
-
-        title = tk.Label(
-            header_frame,
-            text="Materials Collected",
-            font=(None, 9, "bold"),
-            anchor="w",
-        )
-        title.pack(side="left")
-        self._theme.register(title)
-
-        toggle_var = tk.BooleanVar(master=parent, value=self._state.show_materials_collected)
-        toggle = tk.Checkbutton(
-            header_frame,
-            variable=toggle_var,
-            command=self._on_toggle_materials,
-        )
-        toggle.pack(side="left", padx=(6, 0))
-        self._theme.register(toggle)
-        self._theme.style_checkbox(toggle)
-        self._show_materials_var = toggle_var
-
-        frame = tk.Frame(parent, highlightthickness=0, bd=0)
-        grid_config = {
-            "row": 6,
-            "column": 0,
-            "sticky": "w",
-            "padx": 4,
-            "pady": (2, 6),
-        }
-        frame.grid(**grid_config)
-        self._theme.register(frame)
-
-        text_label = tk.Label(frame, text="", anchor="w", justify=tk.LEFT, wraplength=520)
-        text_label.pack(fill="x")
-        self._theme.register(text_label)
-
-        self._materials_frame = frame
-        self._materials_grid = grid_config
-        self._materials_text = text_label
-
-        return header_frame
-
-    def _populate_commodities_table(self) -> None:
-        rows = sorted(
-            name
-            for name in set(self._state.cargo_totals) | set(self._state.cargo_additions)
-            if self._state.cargo_additions.get(name, 0) > 0
-        )
-
-        link_fg = self._theme.link_color()
-
-        if not rows:
-            row_labels = self._ensure_commodity_row(0)
-            for col_index, label in enumerate(row_labels):
-                if col_index == 0:
-                    self._apply_label_style(label, text="No mined commodities")
-                    label.grid()
-                    label.unbind("<Button-1>")
-                else:
-                    label.grid_remove()
-                    label.unbind("<Button-1>")
-            # Hide any leftover rows beyond index 0
-            for idx in range(1, len(self._commodities_rows)):
-                for label in self._commodities_rows[idx]:
-                    label.grid_remove()
-                    label.unbind("<Button-1>")
-            return
-
-        present_counts = {k: len(v) for k, v in self._state.prospected_samples.items()}
-        total_asteroids = self._state.prospected_count if self._state.prospected_count > 0 else 1
-
-        for row_index, commodity in enumerate(rows):
-            labels = self._ensure_commodity_row(row_index)
-            for label in labels:
-                label.grid()
-
-            present = present_counts.get(commodity, 0)
-            percent = (present / total_asteroids) * 100 if total_asteroids else 0.0
-            range_label = self._format_range_label(commodity)
-            tph = self._format_tph(commodity)
-
-            total_amount = self._state.cargo_totals.get(commodity, 0)
-            values = (
-                self._truncate_text(self._format_cargo_name(commodity), 23),
-                f"{present:,d}" if present else "0",
-                f"{percent:.1f}%",
-                f"{total_amount:,}t" if total_amount else "0t",
-                range_label,
-                tph if tph else "-",
-            )
-
-            for col_index, column in enumerate(self._commodity_columns):
-                label = labels[col_index]
-                text = values[col_index]
-                clickable = False
-                foreground: Optional[str] = None
-
-                if column["key"] == "commodity":
-                    has_link = (
-                        self._state.current_system is not None
-                        and commodity.lower() in self._inara.commodity_map
-                    )
-                    clickable = has_link
-                    foreground = link_fg if has_link else None
-                    if has_link:
-                        label.bind("<Button-1>", lambda _evt, name=commodity: self._inara.open_link(name))
-                    else:
-                        label.unbind("<Button-1>")
-                elif column["key"] == "range" and range_label:
-                    clickable = True
-                    foreground = link_fg
-                    label.bind(
-                        "<Button-1>",
-                        lambda _evt, name=commodity: self.open_histogram_window(name),
-                    )
-                else:
-                    label.unbind("<Button-1>")
-
-                self._apply_label_style(
-                    label,
-                    text=text,
-                    foreground=foreground,
-                    cursor="hand2" if clickable else "",
-                    clickable=clickable,
-                )
-
-        # Hide remaining rows beyond populated ones
-        for idx in range(len(rows), len(self._commodities_rows)):
-            for label in self._commodities_rows[idx]:
-                label.grid_remove()
-                label.unbind("<Button-1>")
-
-        # Display totals row similar to BGS-Tally
-    def _populate_materials_table(self) -> None:
-        label = self._materials_text
-        if label is None:
-            return
-
-        if not self._state.materials_collected:
-            text = "No materials collected yet"
-        else:
-            parts: list[str] = []
-            for name, count in sorted(self._state.materials_collected.items()):
-                display = resolve_commodity_display_name(self._state, name)
-                parts.append(f"{display} x{count}")
-            text = ", ".join(parts)
-
-        try:
-            label.configure(text=text)
-        except tk.TclError:
-            pass
-
-    # ------------------------------------------------------------------
-    # Preference callbacks
-    # ------------------------------------------------------------------
-    def _on_histogram_bin_change(self, *_: object) -> None:
-        if self._prefs_bin_var is None or self._updating_bin_var:
-            return
-        try:
-            value = int(self._prefs_bin_var.get())
-        except (TypeError, ValueError, tk.TclError):
-            return
-        size = clamp_bin_size(value)
-        if size == self._state.histogram_bin_size:
-            return
-        self._state.histogram_bin_size = size
-        if self._prefs_bin_var.get() != size:
-            self._updating_bin_var = True
-            self._prefs_bin_var.set(size)
-            self._updating_bin_var = False
-        self._recompute_histograms()
-        self.refresh()
-
-    def _on_rate_interval_change(self, *_: object) -> None:
-        if self._prefs_rate_var is None or self._updating_rate_var:
-            return
-        try:
-            value = int(self._prefs_rate_var.get())
-        except (TypeError, ValueError, tk.TclError):
-            return
-        interval = clamp_rate_interval(value)
-        if interval == self._state.rate_interval_seconds:
-            return
-        self._state.rate_interval_seconds = interval
-        if self._prefs_rate_var.get() != interval:
-            self._updating_rate_var = True
-            self._prefs_rate_var.set(interval)
-            self._updating_rate_var = False
-        self.schedule_rate_update()
-
-    def _on_refinement_window_change(self, *_: object) -> None:
-        if (
-            self._prefs_refinement_window_var is None
-            or self._updating_refinement_window_var
-        ):
-            return
-        try:
-            value = int(self._prefs_refinement_window_var.get())
-        except (TypeError, ValueError, tk.TclError):
-            return
-        window = clamp_positive_int(value, self._state.refinement_lookback_seconds, maximum=3600)
-        if window == self._state.refinement_lookback_seconds:
-            return
-        self._state.refinement_lookback_seconds = window
-        if self._prefs_refinement_window_var.get() != window:
-            self._updating_refinement_window_var = True
-            self._prefs_refinement_window_var.set(window)
-            self._updating_refinement_window_var = False
-        update_rpm(self._state)
-        self._update_rpm_indicator()
-
-    def _on_rpm_threshold_change(self, *_: object) -> None:
-        if (
-            self._prefs_rpm_red_var is None
-            or self._prefs_rpm_yellow_var is None
-            or self._prefs_rpm_green_var is None
-            or self._updating_rpm_vars
-        ):
-            return
-        try:
-            red_value = int(self._prefs_rpm_red_var.get())
-            yellow_value = int(self._prefs_rpm_yellow_var.get())
-            green_value = int(self._prefs_rpm_green_var.get())
-        except (TypeError, ValueError, tk.TclError):
-            return
-
-        red = clamp_positive_int(red_value, self._state.rpm_threshold_red)
-        yellow = clamp_positive_int(yellow_value, self._state.rpm_threshold_yellow)
-        green = clamp_positive_int(green_value, self._state.rpm_threshold_green)
-
-        if red > yellow:
-            yellow = red
-        if yellow > green:
-            green = yellow
-
-        changed = (
-            red != self._state.rpm_threshold_red
-            or yellow != self._state.rpm_threshold_yellow
-            or green != self._state.rpm_threshold_green
-        )
-
-        self._state.rpm_threshold_red = red
-        self._state.rpm_threshold_yellow = yellow
-        self._state.rpm_threshold_green = green
-
-        self._updating_rpm_vars = True
-        self._prefs_rpm_red_var.set(red)
-        self._prefs_rpm_yellow_var.set(yellow)
-        self._prefs_rpm_green_var.set(green)
-        self._updating_rpm_vars = False
-
-        if changed:
-            self._update_rpm_indicator()
-
-    def _on_inara_mode_change(self, *_: object) -> None:
-        if self._prefs_inara_mode_var is None or self._updating_inara_mode_var:
-            return
-        try:
-            value = int(self._prefs_inara_mode_var.get())
-        except (TypeError, ValueError, tk.TclError):
-            return
-        self._inara.set_search_mode(value)
-        if self._prefs_inara_mode_var.get() != self._state.inara_settings.search_mode:
-            self._updating_inara_mode_var = True
-            self._prefs_inara_mode_var.set(self._state.inara_settings.search_mode)
-            self._updating_inara_mode_var = False
-        self._populate_tables()
-
-    def _on_inara_carriers_change(self, *_: object) -> None:
-        if self._prefs_inara_carriers_var is None or self._updating_inara_carriers_var:
-            return
-        try:
-            value = bool(self._prefs_inara_carriers_var.get())
-        except (tk.TclError, ValueError):
-            return
-        self._inara.set_include_carriers(value)
-        if bool(self._prefs_inara_carriers_var.get()) != self._state.inara_settings.include_carriers:
-            self._updating_inara_carriers_var = True
-            self._prefs_inara_carriers_var.set(self._state.inara_settings.include_carriers)
-            self._updating_inara_carriers_var = False
-        self._populate_tables()
-
-    def _on_inara_surface_change(self, *_: object) -> None:
-        if self._prefs_inara_surface_var is None or self._updating_inara_surface_var:
-            return
-        try:
-            value = bool(self._prefs_inara_surface_var.get())
-        except (tk.TclError, ValueError):
-            return
-        self._inara.set_include_surface(value)
-        if bool(self._prefs_inara_surface_var.get()) != self._state.inara_settings.include_surface:
-            self._updating_inara_surface_var = True
-            self._prefs_inara_surface_var.set(self._state.inara_settings.include_surface)
-            self._updating_inara_surface_var = False
-        self._populate_tables()
-
-    # ------------------------------------------------------------------
-    # Event handlers
-    # ------------------------------------------------------------------
-    def _on_reset(self) -> None:
-        self._on_reset()
-
-    def _toggle_pause(self) -> None:
-        self.set_paused(not self._state.is_paused, source="manual")
-
-    def set_paused(self, paused: bool, *, source: str = "manual") -> None:
-        target = bool(paused)
-        if target == self._state.is_paused:
-            self._update_pause_button()
-            self._refresh_status_line()
-            self._update_summary_tooltip()
-            return
-        self._state.is_paused = target
-        if self._pause_callback:
-            try:
-                self._pause_callback(target, source, datetime.now(timezone.utc))
-            except Exception:
-                _log.exception("Failed to notify pause state change")
-        if target:
-            self.cancel_rate_update()
-            self._cancel_rpm_update()
-        else:
-            # Always keep RPM timer active when not paused
-            self._schedule_rpm_update()
-            if self._state.is_mining:
-                self.schedule_rate_update()
-        self._update_pause_button()
-        self._refresh_status_line()
-        self._update_summary_tooltip()
-
-    def is_paused(self) -> bool:
-        return self._state.is_paused
-
-    def _update_pause_button(self) -> None:
-        button = self._pause_btn
-        if not button:
-            return
-        label = "Resume" if self._state.is_paused else "Pause"
-        try:
-            button.configure(text=label)
-        except tk.TclError:
-            pass
-
-    def _on_rate_update_tick(self) -> None:
-        self._rate_update_job = None
-        if self._state.is_paused:
-            return
-        frame = self._frame
-        if frame and frame.winfo_exists():
-            self.refresh()
-        self.schedule_rate_update()
-
-    # ------------------------------------------------------------------
-    # Utility helpers
-    # ------------------------------------------------------------------
-    def _format_cargo_name(self, name: str) -> str:
-        mapping = getattr(self._state, "commodity_display_names", {})
-        display = mapping.get(name.lower())
-        if display:
-            return display
-        return name.replace("_", " ").title()
-
-    def _compute_tph(self, commodity: str) -> Optional[float]:
-        start = self._state.commodity_start_times.get(commodity)
-        if not start:
-            return None
-        start = self._ensure_aware(start)
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        elapsed_hours = (end_time - start).total_seconds() / 3600.0
-        if elapsed_hours <= 0:
-            return None
-        amount = self._state.cargo_additions.get(commodity, 0)
-        if amount <= 0:
-            return None
-        return amount / elapsed_hours
-
-    def _format_tph(self, commodity: str) -> str:
-        rate = self._compute_tph(commodity)
-        if rate is None:
-            return ""
-        return self._format_rate(rate)
-
-    @staticmethod
-    def _truncate_text(text: str, maximum: int) -> str:
-        if len(text) <= maximum:
-            return text
-        if maximum <= 1:
-            return text[:maximum]
-        return text[: maximum - 1] + "…"
-
-    def _make_tph_tooltip(self, commodity: str) -> Optional[str]:
-        rate = self._compute_tph(commodity)
-        start = self._state.commodity_start_times.get(commodity)
-        amount = self._state.cargo_additions.get(commodity, 0)
-        if rate is None or start is None or amount <= 0:
-            return None
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        duration = max(0.0, (end_time - self._ensure_aware(start)).total_seconds())
-        return f"{amount}t over {self._format_duration(duration)}"
-
-    def _format_range_label(self, commodity: str) -> str:
-        if commodity not in self._state.harvested_commodities:
-            return ""
-        samples = self._state.prospected_samples.get(commodity)
-        if not samples:
-            return ""
-        numeric_samples: list[float] = []
-        for value in samples:
-            try:
-                numeric_samples.append(float(value))
-            except (TypeError, ValueError):
-                continue
-        if not numeric_samples:
-            return ""
-        if len(numeric_samples) == 1:
-            return f"{numeric_samples[0]:.1f}%"
-        stats = compute_percentage_stats(numeric_samples)
-        if not stats:
-            return ""
-        low, avg, high = stats
-        return f"{low:.1f}%-{avg:.1f}%-{high:.1f}%"
-
-    def _compute_total_tph(self) -> Optional[float]:
-        if not self._state.mining_start:
-            return None
-        total_amount = sum(amount for amount in self._state.cargo_additions.values() if amount > 0)
-        if total_amount <= 0:
-            return None
-        start_time = self._ensure_aware(self._state.mining_start)
-        end_time = self._ensure_aware(self._state.mining_end or datetime.now(timezone.utc))
-        elapsed_hours = (end_time - start_time).total_seconds() / 3600.0
-        if elapsed_hours <= 0:
-            return None
-        return total_amount / elapsed_hours
-
-    @staticmethod
-    def _format_rate(rate: float) -> str:
-        if rate >= 10:
-            return f"{rate:.0f}"
-        if rate >= 1:
-            return f"{rate:.1f}"
-        return f"{rate:.2f}"
-
-    @staticmethod
-    def _format_duration(seconds: float) -> str:
-        total_seconds = max(0, int(seconds))
-        hours, remainder = divmod(total_seconds, 3600)
-        minutes, secs = divmod(remainder, 60)
-        if hours:
-            return f"{hours}h {minutes}m {secs}s"
-        if minutes:
-            return f"{minutes}m {secs}s"
-        return f"{secs}s"
-
-    @staticmethod
-    def _ensure_aware(value: datetime) -> datetime:
-        if value.tzinfo is None:
-            return value.replace(tzinfo=timezone.utc)
-        return value
-
-    @staticmethod
-    def _calculate_elapsed_seconds(start: datetime, end: datetime) -> float:
-        start_time = edmcmaMiningUI._ensure_aware(start)
-        end_time = edmcmaMiningUI._ensure_aware(end)
-        return max(0.0, (end_time - start_time).total_seconds())
-
-    @staticmethod
-    def _format_bin_label(bin_index: int, size: int) -> str:
-        start = bin_index * size
-        end = min(start + size, 100)
-        return f"{int(start)}-{int(end)}%"
-
-    def open_histogram_window(self, commodity: str) -> None:
-        _hist_open(self, commodity)
-        if window and window.winfo_exists():
-            canvas = self._hist_canvases.get(commodity)
-            if canvas and canvas.winfo_exists():
-                self._draw_histogram(canvas, commodity)
-            window.lift()
-            return
-
-        parent = self._frame
-        if parent is None:
-            return
-
-        top = tk.Toplevel(parent)
-        self._theme.register(top)
-        top.title(f"{self._format_cargo_name(commodity)} histogram")
-        canvas = tk.Canvas(
-            top,
-            width=360,
-            height=200,
-            background=self._theme.table_background_color(),
-            highlightthickness=0,
-        )
-        canvas.pack(fill="both", expand=True)
-        self._theme.register(canvas)
-        top.bind(
-            "<Configure>",
-            lambda event, c=commodity, cv=canvas: self._draw_histogram(cv, c),
-        )
-        if not hasattr(canvas, "_theme_change_bound"):
-            canvas.bind(
-                "<<ThemeChanged>>",
-                lambda _evt, c=commodity, cv=canvas: self._draw_histogram(cv, c),
-                add="+",
-            )
-            canvas._theme_change_bound = True
-        self._draw_histogram(canvas, commodity, counter)
-        top.protocol("WM_DELETE_WINDOW", lambda c=commodity: self._close_histogram_window(c))
-        self._hist_windows[commodity] = top
-        self._hist_canvases[commodity] = canvas
-
-    def close_histogram_windows(self) -> None:
-        _hist_close_windows(self)
-
-    def _close_histogram_window(self, commodity: str) -> None:
-        _hist_close_window(self, commodity)
-
-    def _draw_histogram(self, canvas: tk.Canvas, commodity: str, counter: Optional[Counter[int]] = None) -> None:
-        _hist_draw(self, canvas, commodity, counter)
-
-    def _refresh_histogram_windows(self) -> None:
-        _hist_refresh(self)
-
-
-    def _recompute_histograms(self) -> None:
-        _hist_recompute(self)
diff --git a/mining_ui/preferences.py b/mining_ui/preferences.py
deleted file mode 100644
index 6aa3c58..0000000
--- a/mining_ui/preferences.py
+++ /dev/null
@@ -1,286 +0,0 @@
-"""Preferences pane construction for EDMC Mining Analytics UI."""
-
-from __future__ import annotations
-
-import webbrowser
-from typing import TYPE_CHECKING
-
-try:
-    import tkinter as tk
-    from tkinter import ttk, font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-if TYPE_CHECKING:  # pragma: no cover
-    from .main_mining_ui import edmcmaMiningUI
-
-from edmc_mining_analytics_version import PLUGIN_REPO_URL, PLUGIN_VERSION, display_version
-from .preferences_discord import create_discord_section
-from .preferences_inara import create_inara_section
-from .preferences_overlay import create_overlay_section
-
-
-def build_preferences(ui: "edmcmaMiningUI", parent: tk.Widget) -> tk.Widget:
-    frame = tk.Frame(parent, highlightthickness=0, bd=0)
-
-    section_heading_font = tkfont.nametofont("TkDefaultFont").copy()
-    section_heading_font.configure(weight="bold")
-
-    header = tk.Frame(frame, highlightthickness=0, bd=0)
-    header.grid(row=0, column=0, sticky="ew", padx=10, pady=(10, 4))
-    header.columnconfigure(0, weight=1)
-
-    title = tk.Label(header, text="EDMC Mining Analytics", anchor="w", font=("TkDefaultFont", 10, "bold"))
-    title.grid(row=0, column=0, sticky="w")
-
-    version_text = display_version(PLUGIN_VERSION)
-    version_label = tk.Label(
-        header,
-        text=version_text,
-        anchor="e",
-        cursor="hand2",
-        font=("TkDefaultFont", 9, "underline"),
-    )
-    version_label.grid(row=0, column=1, sticky="e")
-    version_label.configure(foreground="#1e90ff")
-    version_label.bind("<Button-1>", lambda _evt: webbrowser.open(PLUGIN_REPO_URL))
-
-    frame.columnconfigure(0, weight=1)
-    frame.columnconfigure(1, weight=1)
-
-    general_frame = tk.LabelFrame(frame, text="General", font=section_heading_font)
-    general_frame.grid(row=1, column=0, sticky="nsew", padx=(10, 5), pady=(0, 10))
-    general_frame.columnconfigure(0, weight=0)
-    general_frame.columnconfigure(1, weight=1)
-
-    ui._prefs_bin_var = tk.IntVar(master=general_frame, value=ui._state.histogram_bin_size)
-    ui._prefs_bin_var.trace_add("write", ui._on_histogram_bin_change)
-    bin_spin = ttk.Spinbox(
-        general_frame,
-        from_=1,
-        to=100,
-        textvariable=ui._prefs_bin_var,
-        width=6,
-    )
-    bin_spin.grid(row=0, column=0, sticky="w", pady=(4, 2))
-
-    bin_label = tk.Label(
-        general_frame,
-        text="Prospecting histogram bin size (%)",
-        anchor="w",
-    )
-    bin_label.grid(row=0, column=0, sticky="w", padx=(80, 0), pady=(4, 2))
-
-    rate_label = tk.Label(
-        general_frame,
-        text="Tons/hour auto-update interval (seconds)",
-        anchor="w",
-    )
-    rate_label.grid(row=1, column=0, sticky="w", padx=(80, 0), pady=(0, 2))
-
-    ui._prefs_rate_var = tk.IntVar(master=general_frame, value=ui._state.rate_interval_seconds)
-    ui._prefs_rate_var.trace_add("write", ui._on_rate_interval_change)
-    rate_spin = ttk.Spinbox(
-        general_frame,
-        from_=5,
-        to=3600,
-        increment=5,
-        textvariable=ui._prefs_rate_var,
-        width=6,
-    )
-    rate_spin.grid(row=1, column=0, sticky="w", pady=(0, 2))
-
-    ui._prefs_auto_unpause_var = tk.BooleanVar(
-        master=general_frame, value=ui._state.auto_unpause_on_event
-    )
-    ui._prefs_auto_unpause_var.trace_add("write", ui._on_auto_unpause_change)
-    auto_unpause_cb = ttk.Checkbutton(
-        general_frame,
-        text="Mining event automatically un-pauses the plugin",
-        variable=ui._prefs_auto_unpause_var,
-    )
-    auto_unpause_cb.grid(row=2, column=0, columnspan=2, sticky="w", pady=(8, 4))
-
-    ui._prefs_warn_non_metallic_var = tk.BooleanVar(
-        master=general_frame,
-        value=ui._state.warn_on_non_metallic_ring,
-    )
-    ui._prefs_warn_non_metallic_var.trace_add("write", ui._on_warn_non_metallic_change)
-    warn_non_metallic_cb = ttk.Checkbutton(
-        general_frame,
-        text="Warn on non-metallic rings (helpful when laser mining platinum)",
-        variable=ui._prefs_warn_non_metallic_var,
-    )
-    warn_non_metallic_cb.grid(row=3, column=0, columnspan=2, sticky="w", pady=(0, 6))
-
-    reset_cap_btn = ttk.Button(
-        general_frame,
-        text="Reset inferred cargo estimates",
-        command=ui._on_reset_inferred_capacities,
-    )
-    reset_cap_btn.grid(row=4, column=0, sticky="w", pady=(0, 4))
-    ui._reset_capacities_btn = reset_cap_btn
-
-    overlay_frame = create_overlay_section(ui, frame, section_heading_font)
-    overlay_frame.grid(row=1, column=1, sticky="nsew", padx=(5, 10), pady=(0, 10))
-
-    refinement_frame = tk.LabelFrame(frame, text="Refinement Session Logging", font=section_heading_font)
-    refinement_frame.grid(row=2, column=0, sticky="nsew", padx=(10, 5), pady=(0, 10))
-    refinement_frame.columnconfigure(0, weight=1)
-
-    refinement_desc = tk.Label(
-        refinement_frame,
-        text=(
-            "Historical refinement windows control how far back we capture and average "
-            "mining performance for rate calculations."
-        ),
-        anchor="w",
-        justify="left",
-        wraplength=400,
-    )
-    refinement_desc.grid(row=0, column=0, sticky="w", pady=(4, 4))
-
-    ui._prefs_refinement_window_var = tk.IntVar(
-        master=refinement_frame, value=ui._state.refinement_lookback_seconds
-    )
-    ui._prefs_refinement_window_var.trace_add("write", ui._on_refinement_window_change)
-    refinement_window_container = tk.Frame(refinement_frame, highlightthickness=0, bd=0)
-    refinement_window_container.grid(row=1, column=0, sticky="w", pady=(0, 4))
-
-    ttk.Spinbox(
-        refinement_window_container,
-        from_=5,
-        to=240,
-        increment=5,
-        textvariable=ui._prefs_refinement_window_var,
-        width=6,
-    ).grid(row=0, column=0, sticky="w")
-
-    refinement_seconds_label = tk.Label(
-        refinement_window_container,
-        text="seconds",
-        anchor="w",
-    )
-    refinement_seconds_label.grid(row=0, column=1, sticky="w", padx=(8, 0))
-
-    thresholds_container = tk.Frame(refinement_frame, highlightthickness=0, bd=0)
-    thresholds_container.grid(row=2, column=0, sticky="ew", pady=(6, 4))
-    thresholds_container.columnconfigure((0, 1, 2), weight=1)
-
-    thresholds_desc = tk.Label(
-        thresholds_container,
-        text="RPM thresholds control when the RPM card changes colour.",
-        anchor="w",
-    )
-    thresholds_desc.grid(row=0, column=0, columnspan=3, sticky="w", pady=(0, 4))
-
-    ui._prefs_rpm_red_var = tk.IntVar(master=thresholds_container, value=ui._state.rpm_threshold_red)
-    ui._prefs_rpm_red_var.trace_add("write", ui._on_rpm_threshold_change)
-    red_label = tk.Label(thresholds_container, text="Red threshold")
-    red_label.grid(row=1, column=0, sticky="w")
-    ttk.Spinbox(
-        thresholds_container,
-        from_=1,
-        to=500,
-        textvariable=ui._prefs_rpm_red_var,
-        width=6,
-    ).grid(row=2, column=0, sticky="w")
-
-    ui._prefs_rpm_yellow_var = tk.IntVar(master=thresholds_container, value=ui._state.rpm_threshold_yellow)
-    ui._prefs_rpm_yellow_var.trace_add("write", ui._on_rpm_threshold_change)
-    yellow_label = tk.Label(thresholds_container, text="Yellow threshold")
-    yellow_label.grid(row=1, column=1, sticky="w")
-    ttk.Spinbox(
-        thresholds_container,
-        from_=1,
-        to=500,
-        textvariable=ui._prefs_rpm_yellow_var,
-        width=6,
-    ).grid(row=2, column=1, sticky="w")
-
-    ui._prefs_rpm_green_var = tk.IntVar(master=thresholds_container, value=ui._state.rpm_threshold_green)
-    ui._prefs_rpm_green_var.trace_add("write", ui._on_rpm_threshold_change)
-    green_label = tk.Label(thresholds_container, text="Green threshold")
-    green_label.grid(row=1, column=2, sticky="w")
-    ttk.Spinbox(
-        thresholds_container,
-        from_=1,
-        to=500,
-        textvariable=ui._prefs_rpm_green_var,
-        width=6,
-    ).grid(row=2, column=2, sticky="w")
-
-    logging_frame = tk.LabelFrame(frame, text="Session Logging", font=section_heading_font)
-    logging_frame.grid(row=2, column=1, sticky="nsew", padx=(5, 10), pady=(0, 10))
-    logging_frame.columnconfigure(0, weight=1)
-
-    logging_desc = tk.Label(
-        logging_frame,
-        text="Persist session data for post-run analysis and Discord summaries.",
-        anchor="w",
-        justify="left",
-        wraplength=400,
-    )
-    logging_desc.grid(row=0, column=0, sticky="w", pady=(4, 4))
-
-    ui._prefs_session_logging_var = tk.BooleanVar(
-        master=logging_frame,
-        value=ui._state.session_logging_enabled,
-    )
-    ui._prefs_session_logging_var.trace_add("write", ui._on_session_logging_change)
-    session_logging_cb = ttk.Checkbutton(
-        logging_frame,
-        text="Enable session logging",
-        variable=ui._prefs_session_logging_var,
-    )
-    session_logging_cb.grid(row=1, column=0, sticky="w", pady=(0, 4))
-    ui._send_summary_cb = session_logging_cb
-
-    retention_container = tk.Frame(logging_frame, highlightthickness=0, bd=0)
-    retention_container.grid(row=2, column=0, sticky="w", pady=(4, 0))
-
-    ui._prefs_session_retention_var = tk.IntVar(
-        master=retention_container, value=ui._state.session_log_retention
-    )
-    ui._prefs_session_retention_var.trace_add("write", ui._on_session_retention_change)
-    retention_spin = ttk.Spinbox(
-        retention_container,
-        from_=1,
-        to=500,
-        increment=1,
-        width=6,
-        textvariable=ui._prefs_session_retention_var,
-    )
-    retention_spin.grid(row=0, column=0, sticky="w", padx=(0, 8))
-
-    retention_label = tk.Label(retention_container, text="Sessions to retain")
-    retention_label.grid(row=0, column=1, sticky="w")
-
-    session_path_container = tk.Frame(logging_frame, highlightthickness=0, bd=0)
-    session_path_container.grid(row=3, column=0, sticky="w", pady=(6, 10))
-
-    copy_session_path_btn = ttk.Button(
-        session_path_container,
-        text="Copy session log folder location",
-        command=ui._copy_session_log_path,
-    )
-    copy_session_path_btn.grid(row=0, column=0, sticky="w")
-
-    ui._session_path_feedback = tk.StringVar(master=session_path_container, value="")
-    session_path_feedback_label = tk.Label(
-        session_path_container,
-        textvariable=ui._session_path_feedback,
-        anchor="w",
-    )
-    session_path_feedback_label.grid(row=0, column=1, sticky="w", padx=(8, 0))
-
-    discord_frame = create_discord_section(ui, frame, section_heading_font)
-    discord_frame.grid(row=3, column=0, sticky="nsew", padx=(10, 5), pady=(0, 10))
-
-    inara_frame = create_inara_section(ui, frame, section_heading_font)
-    inara_frame.grid(row=3, column=1, sticky="nsew", padx=(5, 10), pady=(0, 10))
-
-    return frame
-
-
-__all__ = ["build_preferences"]
diff --git a/mining_ui/preferences_discord.py b/mining_ui/preferences_discord.py
deleted file mode 100644
index 87cb2f1..0000000
--- a/mining_ui/preferences_discord.py
+++ /dev/null
@@ -1,142 +0,0 @@
-"""Discord preferences section for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-try:
-    import tkinter as tk
-    from tkinter import ttk, font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-if TYPE_CHECKING:  # pragma: no cover
-    from .main_mining_ui import edmcmaMiningUI
-
-
-def create_discord_section(
-    ui: "edmcmaMiningUI",
-    parent: tk.Widget,
-    heading_font: tkfont.Font,
-) -> tk.LabelFrame:
-    """Build and return the Discord summary preferences section."""
-
-    frame = tk.LabelFrame(parent, text="Discord summary", font=heading_font)
-    frame.columnconfigure(0, weight=1)
-
-    ui._prefs_send_summary_var = tk.BooleanVar(
-        master=frame,
-        value=ui._state.send_summary_to_discord,
-    )
-    ui._prefs_send_summary_var.trace_add("write", ui._on_send_summary_change)
-    send_summary_cb = ttk.Checkbutton(
-        frame,
-        text="Send session summary to Discord",
-        variable=ui._prefs_send_summary_var,
-    )
-    send_summary_cb.grid(row=0, column=0, sticky="w", pady=(4, 4))
-    ui._send_summary_cb = send_summary_cb
-
-    webhook_label = tk.Label(
-        frame,
-        text="Discord webhook URL",
-        anchor="w",
-    )
-    webhook_label.grid(row=1, column=0, sticky="w", pady=(0, 2))
-
-    ui._prefs_webhook_var = tk.StringVar(master=frame)
-    ui._updating_webhook_var = True
-    ui._prefs_webhook_var.set(ui._state.discord_webhook_url)
-    ui._updating_webhook_var = False
-    ui._prefs_webhook_var.trace_add("write", ui._on_webhook_change)
-    webhook_entry = ttk.Entry(
-        frame,
-        textvariable=ui._prefs_webhook_var,
-        width=60,
-    )
-    webhook_entry.grid(row=2, column=0, sticky="ew", pady=(0, 6))
-
-    images_label = tk.Label(
-        frame,
-        text="Discord images (optional, leave ship blank for Any)",
-        anchor="w",
-    )
-    images_label.grid(row=3, column=0, sticky="w", pady=(0, 2))
-
-    images_container = tk.Frame(frame, highlightthickness=0, bd=0)
-    images_container.grid(row=4, column=0, sticky="nsew", pady=(0, 6))
-    images_container.columnconfigure(0, weight=1)
-    images_container.rowconfigure(0, weight=1)
-
-    ui._discord_image_ship_var = tk.StringVar(master=frame, value="")
-    ui._discord_image_url_var = tk.StringVar(master=frame, value="")
-
-    images_tree = ttk.Treeview(
-        images_container,
-        columns=("ship", "url"),
-        show="headings",
-        height=4,
-    )
-    images_tree.heading("ship", text="Ship")
-    images_tree.heading("url", text="Image URL")
-    images_tree.column("ship", width=120, anchor="w")
-    images_tree.column("url", anchor="w")
-    images_tree.grid(row=0, column=0, columnspan=3, sticky="nsew")
-
-    images_scroll = ttk.Scrollbar(images_container, orient="vertical", command=images_tree.yview)
-    images_scroll.grid(row=0, column=3, sticky="ns", padx=(4, 0))
-    images_tree.configure(yscrollcommand=images_scroll.set)
-
-    form = tk.Frame(images_container, highlightthickness=0, bd=0)
-    form.grid(row=1, column=0, columnspan=3, sticky="ew", pady=(4, 0))
-    form.columnconfigure(1, weight=1)
-
-    ship_label = tk.Label(form, text="Ship name", anchor="w")
-    ship_label.grid(row=0, column=0, sticky="w", padx=(0, 8))
-    ship_entry = ttk.Entry(form, textvariable=ui._discord_image_ship_var, width=20)
-    ship_entry.grid(row=0, column=1, sticky="ew", padx=(0, 8))
-
-    url_label = tk.Label(form, text="Image URL", anchor="w")
-    url_label.grid(row=1, column=0, sticky="w", padx=(0, 8), pady=(4, 0))
-    url_entry = ttk.Entry(form, textvariable=ui._discord_image_url_var, width=50)
-    url_entry.grid(row=1, column=1, sticky="ew", pady=(4, 0), padx=(0, 8))
-
-    button_frame = tk.Frame(form, highlightthickness=0, bd=0)
-    button_frame.grid(row=0, column=2, rowspan=2, sticky="ns")
-
-    add_button = ttk.Button(button_frame, text="Add", command=ui._on_discord_image_add)
-    add_button.grid(row=0, column=0, sticky="ew", pady=(0, 4))
-
-    remove_button = ttk.Button(button_frame, text="Delete selected", command=ui._on_discord_image_delete)
-    remove_button.grid(row=1, column=0, sticky="ew")
-
-    ui._discord_images_tree = images_tree
-    ui._refresh_discord_image_list()
-
-    ui._prefs_send_reset_summary_var = tk.BooleanVar(
-        master=frame,
-        value=ui._state.send_reset_summary,
-    )
-    ui._prefs_send_reset_summary_var.trace_add("write", ui._on_send_reset_summary_change)
-    send_reset_summary_cb = ttk.Checkbutton(
-        frame,
-        text="Send Discord summary when resetting session",
-        variable=ui._prefs_send_reset_summary_var,
-    )
-    send_reset_summary_cb.grid(row=5, column=0, sticky="w", pady=(0, 4))
-    ui._send_reset_summary_cb = send_reset_summary_cb
-
-    test_btn = ttk.Button(
-        frame,
-        text="Test webhook",
-        command=ui._on_test_webhook,
-    )
-    test_btn.grid(row=6, column=0, sticky="w", pady=(0, 6))
-    ui._test_webhook_btn = test_btn
-
-    ui._update_discord_controls()
-
-    return frame
-
-
-__all__ = ["create_discord_section"]
diff --git a/mining_ui/preferences_inara.py b/mining_ui/preferences_inara.py
deleted file mode 100644
index bf6c52c..0000000
--- a/mining_ui/preferences_inara.py
+++ /dev/null
@@ -1,77 +0,0 @@
-"""Inara preferences section for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-try:
-    import tkinter as tk
-    from tkinter import ttk, font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-if TYPE_CHECKING:  # pragma: no cover
-    from .main_mining_ui import edmcmaMiningUI
-
-
-def create_inara_section(
-    ui: "edmcmaMiningUI",
-    parent: tk.Widget,
-    heading_font: tkfont.Font,
-) -> tk.LabelFrame:
-    """Build and return the Inara link preferences section."""
-
-    frame = tk.LabelFrame(parent, text="Inara Links", font=heading_font)
-    frame.columnconfigure(0, weight=1)
-
-    inara_desc = tk.Label(
-        frame,
-        text="Configure how commodity hyperlinks open Inara searches.",
-        anchor="w",
-        justify="left",
-        wraplength=380,
-    )
-    inara_desc.grid(row=0, column=0, sticky="w", pady=(4, 6))
-
-    ui._prefs_inara_mode_var = tk.IntVar(master=frame, value=ui._state.inara_settings.search_mode)
-    ui._prefs_inara_mode_var.trace_add("write", ui._on_inara_mode_change)
-    mode_container = tk.Frame(frame, highlightthickness=0, bd=0)
-    mode_container.grid(row=1, column=0, sticky="w", pady=(0, 6))
-
-    ttk.Radiobutton(
-        mode_container,
-        text="Best price search",
-        value=1,
-        variable=ui._prefs_inara_mode_var,
-    ).grid(row=0, column=0, sticky="w", padx=(0, 12))
-    ttk.Radiobutton(
-        mode_container,
-        text="Distance search",
-        value=3,
-        variable=ui._prefs_inara_mode_var,
-    ).grid(row=0, column=1, sticky="w")
-
-    ui._prefs_inara_carriers_var = tk.BooleanVar(
-        master=frame, value=ui._state.inara_settings.include_carriers
-    )
-    ui._prefs_inara_carriers_var.trace_add("write", ui._on_inara_carriers_change)
-    ttk.Checkbutton(
-        frame,
-        text="Include fleet carriers in results",
-        variable=ui._prefs_inara_carriers_var,
-    ).grid(row=2, column=0, sticky="w", pady=(0, 4))
-
-    ui._prefs_inara_surface_var = tk.BooleanVar(
-        master=frame, value=ui._state.inara_settings.include_surface
-    )
-    ui._prefs_inara_surface_var.trace_add("write", ui._on_inara_surface_change)
-    ttk.Checkbutton(
-        frame,
-        text="Include surface stations in results",
-        variable=ui._prefs_inara_surface_var,
-    ).grid(row=3, column=0, sticky="w", pady=(0, 4))
-
-    return frame
-
-
-__all__ = ["create_inara_section"]
diff --git a/mining_ui/preferences_overlay.py b/mining_ui/preferences_overlay.py
deleted file mode 100644
index 9c7add3..0000000
--- a/mining_ui/preferences_overlay.py
+++ /dev/null
@@ -1,115 +0,0 @@
-"""Overlay preferences section for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-try:
-    import tkinter as tk
-    from tkinter import ttk, font as tkfont
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-from integrations.edmcoverlay import is_overlay_available
-
-if TYPE_CHECKING:  # pragma: no cover
-    from .main_mining_ui import edmcmaMiningUI
-
-
-def create_overlay_section(
-    ui: "edmcmaMiningUI",
-    parent: tk.Widget,
-    heading_font: tkfont.Font,
-) -> tk.LabelFrame:
-    """Build and return the overlay settings section."""
-
-    ui._state.overlay_available = is_overlay_available()
-
-    frame = tk.LabelFrame(parent, text="Overlay", font=heading_font)
-    frame.columnconfigure(0, weight=0)
-    frame.columnconfigure(1, weight=1)
-
-    ui._prefs_overlay_enabled_var = tk.BooleanVar(
-        master=frame,
-        value=ui._state.overlay_enabled,
-    )
-    ui._prefs_overlay_enabled_var.trace_add("write", ui._on_overlay_enabled_change)
-    overlay_enable_cb = ttk.Checkbutton(
-        frame,
-        text="Enable EDMCOverlay metrics",
-        variable=ui._prefs_overlay_enabled_var,
-    )
-    overlay_enable_cb.grid(row=0, column=0, columnspan=2, sticky="w", pady=(6, 4))
-
-    x_label = tk.Label(
-        frame,
-        text="Anchor X (px from left)",
-        anchor="w",
-    )
-    x_label.grid(row=1, column=1, sticky="w", padx=(8, 0))
-
-    ui._prefs_overlay_x_var = tk.IntVar(master=frame, value=ui._state.overlay_anchor_x)
-    ui._prefs_overlay_x_var.trace_add("write", ui._on_overlay_anchor_x_change)
-    overlay_x_spin = ttk.Spinbox(
-        frame,
-        from_=0,
-        to=4000,
-        textvariable=ui._prefs_overlay_x_var,
-        width=6,
-    )
-    overlay_x_spin.grid(row=1, column=0, sticky="w", padx=(0, 8))
-
-    y_label = tk.Label(
-        frame,
-        text="Anchor Y (px from top)",
-        anchor="w",
-    )
-    y_label.grid(row=2, column=1, sticky="w", padx=(8, 0), pady=(0, 2))
-
-    ui._prefs_overlay_y_var = tk.IntVar(master=frame, value=ui._state.overlay_anchor_y)
-    ui._prefs_overlay_y_var.trace_add("write", ui._on_overlay_anchor_y_change)
-    overlay_y_spin = ttk.Spinbox(
-        frame,
-        from_=0,
-        to=4000,
-        textvariable=ui._prefs_overlay_y_var,
-        width=6,
-    )
-    overlay_y_spin.grid(row=2, column=0, sticky="w", padx=(0, 8), pady=(0, 2))
-
-    overlay_hint = tk.Label(
-        frame,
-        text="",
-        anchor="w",
-        justify="left",
-        wraplength=380,
-    )
-    overlay_hint.grid(row=4, column=0, columnspan=2, sticky="w", pady=(6, 4))
-
-    interval_label = tk.Label(
-        frame,
-        text="Refresh interval (milliseconds)",
-        anchor="w",
-    )
-    interval_label.grid(row=3, column=1, sticky="w", padx=(8, 0), pady=(0, 2))
-
-    ui._prefs_overlay_interval_var = tk.IntVar(
-        master=frame,
-        value=ui._state.overlay_refresh_interval_ms,
-    )
-    ui._prefs_overlay_interval_var.trace_add("write", ui._on_overlay_interval_change)
-    overlay_interval_spin = ttk.Spinbox(
-        frame,
-        from_=200,
-        to=60000,
-        increment=100,
-        textvariable=ui._prefs_overlay_interval_var,
-        width=6,
-    )
-    overlay_interval_spin.grid(row=3, column=0, sticky="w", padx=(0, 8), pady=(0, 2))
-
-    ui._overlay_controls = [overlay_enable_cb, overlay_x_spin, overlay_y_spin, overlay_interval_spin]
-    ui._overlay_hint_label = overlay_hint
-    ui._update_overlay_controls()
-
-    return frame
diff --git a/mining_ui/theme_adapter.py b/mining_ui/theme_adapter.py
deleted file mode 100644
index db89e42..0000000
--- a/mining_ui/theme_adapter.py
+++ /dev/null
@@ -1,349 +0,0 @@
-"""Theme utilities for EDMC Mining Analytics UI."""
-
-from __future__ import annotations
-
-try:
-    import tkinter as tk
-    from tkinter import ttk
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-try:  # pragma: no cover - theme only exists inside EDMC runtime
-    from theme import theme as edmc_theme  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    edmc_theme = None  # type: ignore[assignment]
-
-try:  # pragma: no cover - config only available inside EDMC
-    from config import config as edmc_config  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    edmc_config = None  # type: ignore[assignment]
-
-
-class ThemeAdapter:
-    """Bridge EDMC's theme helper with plain Tk widgets."""
-
-    def __init__(self) -> None:
-        self._style = ttk.Style()
-        self._theme = edmc_theme
-        self._config = edmc_config
-        self._is_dark_theme = False
-        if self._config is not None:
-            try:
-                self._is_dark_theme = bool(self._config.get_int("theme") == 1)  # type: ignore[arg-type]
-            except Exception:
-                self._is_dark_theme = False
-
-        dark_text = None
-        if self._config is not None and self._is_dark_theme:
-            try:
-                dark_text = self._config.get_str("dark_text")  # type: ignore[arg-type]
-            except Exception:
-                dark_text = None
-        if not dark_text:
-            dark_text = "#f5f5f5"
-
-        if self._is_dark_theme:
-            self._fallback_panel_bg = "#000000"
-            self._fallback_text_fg = dark_text
-            self._fallback_table_bg = "#000000"
-            self._fallback_table_stripe = "#121212"
-            self._fallback_table_header_bg = "#000000"
-            self._fallback_table_header_fg = dark_text
-            self._fallback_table_header_hover = "#1a1a1a"
-            self._fallback_button_bg = "#f19a29"
-            self._fallback_button_fg = "#1a1005"
-            self._fallback_button_active = "#ffb84a"
-            self._fallback_button_border = "#ffc266"
-            self._fallback_link_fg = "#268bd2"
-        else:
-            self._fallback_panel_bg = "#0d0d0d"
-            self._fallback_text_fg = "#f4bb60"
-            self._fallback_table_bg = "#19100a"
-            self._fallback_table_stripe = "#23160d"
-            self._fallback_table_header_bg = "#3b2514"
-            self._fallback_table_header_fg = "#f6e3c0"
-            self._fallback_table_header_hover = "#4a2f19"
-            self._fallback_button_bg = "#f19a29"
-            self._fallback_button_fg = "#1a1005"
-            self._fallback_button_active = "#ffb84a"
-            self._fallback_button_border = "#ffc266"
-            self._fallback_link_fg = "#0645ad"
-
-    @property
-    def is_dark_theme(self) -> bool:
-        return self._is_dark_theme
-
-    def register(self, widget: tk.Widget) -> None:
-        if self._theme is not None:
-            try:
-                self._theme.register(widget)
-                return
-            except Exception:
-                pass
-
-        background = self.get_background_color(widget)
-        try:
-            widget.configure(background=background)
-        except tk.TclError:
-            pass
-        for option in ("fg", "foreground"):
-            try:
-                widget.configure(**{option: self.default_text_color()})
-                break
-            except tk.TclError:
-                continue
-
-    def default_text_color(self) -> str:
-        """Return the appropriate default text color.
-
-        - On dark theme: use the plugin's fallback text color to ensure
-          readable contrast regardless of EDMC style lookups.
-        - On light/default theme: prefer the ttk style's label foreground or
-          the system text color so we match EDMC's native appearance (black).
-        """
-        if not self._is_dark_theme:
-            try:
-                val = self._style.lookup("TLabel", "foreground")
-            except tk.TclError:
-                val = None
-            if val:
-                return val
-            return "SystemWindowText"
-        return self._fallback_text_fg
-
-    def treeview_style(self) -> str:
-        """Return a style name for Treeviews used by this plugin.
-
-        - Uses a plugin-scoped style so we don't clobber EDMC's global styles.
-        - In light theme, avoid overriding background/foreground so EDMC's
-          default theme remains readable.
-        - In dark theme, explicitly set colors for readability.
-        """
-        style_name = "EDMCMA.Treeview"
-        heading_name = f"{style_name}.Heading"
-
-        # Ensure the style objects exist but keep them inheriting defaults
-        # unless we're on dark theme.
-        try:
-            self._style.configure(style_name, rowheight=22)
-        except tk.TclError:
-            pass
-
-        header_font = (
-            self._style.lookup("Treeview.Heading", "font") or ("TkDefaultFont", 9, "bold")
-        )
-
-        if self._is_dark_theme:
-            background = self.table_background_color()
-            foreground = self.table_foreground_color()
-            header_bg = self.table_header_background_color()
-            header_fg = self.table_header_foreground_color()
-            header_hover = self.table_header_hover_color()
-            selected_bg = self.button_active_background_color()
-            selected_fg = self.button_foreground_color()
-
-            # Configure our scoped style with explicit dark colors
-            self._style.configure(
-                style_name,
-                background=background,
-                fieldbackground=background,
-                foreground=foreground,
-                bordercolor=header_bg,
-                borderwidth=0,
-                relief=tk.FLAT,
-                highlightthickness=0,
-            )
-            self._style.map(
-                style_name,
-                background=[("selected", selected_bg)],
-                foreground=[("selected", selected_fg)],
-            )
-            self._style.configure(
-                heading_name,
-                background=header_bg,
-                foreground=header_fg,
-                relief="flat",
-                borderwidth=0,
-                font=header_font,
-            )
-            self._style.map(
-                heading_name,
-                background=[("active", header_hover)],
-                foreground=[("active", header_fg)],
-            )
-        else:
-            # Light theme: inherit EDMC defaults; only set font to keep header tidy.
-            try:
-                self._style.configure(heading_name, font=header_font)
-            except tk.TclError:
-                pass
-
-        return style_name
-
-    def table_background_color(self) -> str:
-        # Prefer existing theme value; fall back to a safe default for our palettes.
-        val = None
-        try:
-            val = self._style.lookup("Treeview", "background")
-        except tk.TclError:
-            val = None
-        if not val:
-            try:
-                val = self._style.lookup("TFrame", "background")
-            except tk.TclError:
-                val = None
-        if val:
-            return val
-        # If no style-provided value, prefer a neutral system default on light theme
-        # to avoid unreadable contrasts.
-        if not self._is_dark_theme:
-            return "SystemWindow"
-        return self._fallback_table_bg
-
-    def table_foreground_color(self) -> str:
-        try:
-            val = self._style.lookup("Treeview", "foreground")
-        except tk.TclError:
-            val = None
-        if not val:
-            try:
-                val = self._style.lookup("TLabel", "foreground")
-            except tk.TclError:
-                val = None
-        if val:
-            return val
-        if not self._is_dark_theme:
-            return "SystemWindowText"
-        return self._fallback_table_header_fg
-
-    def table_stripe_color(self) -> str:
-        # Derive a subtle stripe from the base background. On light theme,
-        # keep contrast very low to avoid heavy dark rows.
-        base = self.table_background_color()
-        factor = 1.08 if self._is_dark_theme else 0.98
-        adjusted = self._tint_color(base, factor)
-        if adjusted:
-            return adjusted
-        return self._fallback_table_stripe
-
-    def table_header_background_color(self) -> str:
-        return self._fallback_table_header_bg
-
-    def table_header_foreground_color(self) -> str:
-        return self._fallback_table_header_fg
-
-    def table_header_hover_color(self) -> str:
-        return self._fallback_table_header_hover
-
-    def button_background_color(self) -> str:
-        return self._fallback_button_bg
-
-    def button_foreground_color(self) -> str:
-        return self._fallback_button_fg
-
-    def button_active_background_color(self) -> str:
-        return self._fallback_button_active
-
-    def button_border_color(self) -> str:
-        return self._fallback_button_border
-
-    def link_color(self) -> str:
-        return self._fallback_link_fg
-
-    def panel_background_color(self) -> str:
-        return self._fallback_panel_bg
-
-    def highlight_text_color(self) -> str:
-        if self._is_dark_theme:
-            return "#000000"
-        return "#ffffff"
-
-    def get_background_color(self, widget: tk.Widget) -> str:
-        style_name = widget.winfo_class()
-        for option in ("background", "fieldbackground"):
-            try:
-                color = self._style.lookup(style_name, option)
-            except tk.TclError:
-                color = None
-            if color:
-                return color
-        try:
-            color = widget.cget("background")  # type: ignore[call-overload]
-        except tk.TclError:
-            color = None
-        if color and color not in {"SystemButtonFace", "SystemWindowBodyColor", "SystemWindow", ""}:
-            return color
-        return self._fallback_panel_bg
-
-    def style_button(self, button: tk.Button) -> None:
-        self.register(button)
-        if self._is_dark_theme:
-            try:
-                button.configure(
-                    background=self.button_background_color(),
-                    foreground=self.button_foreground_color(),
-                    activebackground=self.button_active_background_color(),
-                    activeforeground=self.button_foreground_color(),
-                    highlightthickness=1,
-                    highlightbackground=self.button_border_color(),
-                    highlightcolor=self.button_border_color(),
-                    bd=0,
-                    relief=tk.FLAT,
-                    padx=12,
-                    pady=4,
-                )
-            except tk.TclError:
-                pass
-        else:
-            try:
-                button.configure(
-                    background="SystemButtonFace",
-                    foreground="#000000",
-                    activebackground="SystemButtonFace",
-                    activeforeground="#000000",
-                    relief=tk.RAISED,
-                    bd=2,
-                    highlightthickness=0,
-                    padx=12,
-                    pady=4,
-                )
-            except tk.TclError:
-                pass
-
-    def style_checkbox(self, checkbox: tk.Checkbutton) -> None:
-        self.register(checkbox)
-        if not self._is_dark_theme:
-            return
-        background = self.panel_background_color()
-        try:
-            checkbox.configure(
-                background=background,
-                activebackground=background,
-                selectcolor=background,
-                highlightbackground=background,
-                highlightcolor=background,
-                highlightthickness=0,
-                bd=0,
-                relief=tk.FLAT,
-                indicatoron=True,
-            )
-        except tk.TclError:
-            pass
-
-    @staticmethod
-    def _tint_color(color: str, factor: float) -> str | None:
-        if not isinstance(color, str) or not color.startswith("#") or len(color) != 7:
-            return None
-        try:
-            r = int(color[1:3], 16)
-            g = int(color[3:5], 16)
-            b = int(color[5:7], 16)
-        except ValueError:
-            return None
-        r = max(0, min(255, int(r * factor)))
-        g = max(0, min(255, int(g * factor)))
-        b = max(0, min(255, int(b * factor)))
-        return f"#{r:02x}{g:02x}{b:02x}"
-
-
-__all__ = ["ThemeAdapter"]
diff --git a/plugin.py b/plugin.py
deleted file mode 100644
index a964046..0000000
--- a/plugin.py
+++ /dev/null
@@ -1,567 +0,0 @@
-"""Core orchestration for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-import logging
-import threading
-from datetime import datetime, timezone
-from pathlib import Path
-from typing import Optional
-
-import requests
-
-from http_client import get_shared_session
-try:
-    import tkinter as tk
-    from tkinter import ttk
-except ImportError as exc:  # pragma: no cover - EDMC always provides tkinter
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-try:
-    import myNotebook as nb  # type: ignore[import]
-except ImportError:  # pragma: no cover - EDMC loads this in production
-    nb = None  # type: ignore[assignment]
-
-try:
-    from config import appname  # type: ignore[import]
-except ImportError:  # pragma: no cover
-    appname = "EDMarketConnector"  # type: ignore[assignment]
-
-from integrations.mining_inara import InaraClient
-from integrations.mining_edsm import EdsmClient
-from integrations.spansh_hotspots import SpanshHotspotClient
-from integrations.edmcoverlay import EdmcOverlayHelper
-from journal import JournalProcessor
-from preferences import PreferencesManager
-from session_recorder import SessionRecorder
-from state import MiningState, reset_mining_state
-from logging_utils import get_logger, set_log_level
-from edmc_mining_analytics_version import (
-    PLUGIN_VERSION,
-    is_newer_version,
-    normalize_version,
-)
-from mining_analytics_ui import edmcmaMiningUI
-from update_manager import UpdateManager
-
-
-PLUGIN_NAME = "EDMC Mining Analytics"
-GITHUB_RELEASES_API = (
-    "https://api.github.com/repos/SweetJonnySauce/EDMC-Mining-Analytics/releases/latest"
-)
-GITHUB_TAGS_API = "https://api.github.com/repos/SweetJonnySauce/EDMC-Mining-Analytics/tags?per_page=1"
-
-
-def _coerce_log_level(value: object) -> Optional[int]:
-    if isinstance(value, int):
-        return value
-    if isinstance(value, str):
-        candidate = value.strip()
-        if not candidate:
-            return None
-        if candidate.isdigit():
-            try:
-                return int(candidate)
-            except ValueError:
-                return None
-        upper = candidate.upper()
-        return logging._nameToLevel.get(upper)  # type: ignore[attr-defined]
-    return None
-
-
-def _resolve_edmc_log_level() -> int:
-    base_logger = logging.getLogger(appname) if appname else logging.getLogger()
-    fallback = base_logger.getEffectiveLevel()
-    try:
-        from config import config  # type: ignore[import]
-    except ImportError:
-        config = None  # type: ignore[assignment]
-
-    if config is None:
-        return fallback
-
-    candidates = ("loglevel", "log_level", "logging_level")
-    getters = ("getint", "get", "get_str")
-
-    for key in candidates:
-        for getter_name in getters:
-            getter = getattr(config, getter_name, None)
-            if getter is None:
-                continue
-            try:
-                raw_value = getter(key)
-            except Exception:
-                continue
-            level = _coerce_log_level(raw_value)
-            if level is not None:
-                return level
-    return fallback
-
-
-set_log_level(_resolve_edmc_log_level())
-_log = get_logger()
-
-
-class MiningAnalyticsPlugin:
-    """Coordinates state, UI, preferences, and journal processing."""
-
-    def __init__(self) -> None:
-        self.state = MiningState()
-        self.preferences = PreferencesManager()
-        self.inara = InaraClient(self.state)
-        self.spansh = SpanshHotspotClient(self.state)
-        self.edsm = EdsmClient(self.state, self._schedule_ui_refresh)
-        self.session_recorder = SessionRecorder(self.state)
-        self.overlay_helper = EdmcOverlayHelper(self.state)
-        self.overlay_helper.refresh_availability()
-        self.update_manager: Optional[UpdateManager] = None
-        self._overlay_refresh_job: Optional[str] = None
-        self._overlay_enabled_last: bool = False
-        self._version_thread: Optional[threading.Thread] = None
-        self.ui = edmcmaMiningUI(
-            self.state,
-            self.inara,
-            self.spansh,
-            self._handle_reset_request,
-            on_pause_changed=self._handle_pause_change,
-            on_reset_inferred_capacities=self._handle_reset_inferred_capacities,
-            on_test_webhook=self._handle_test_webhook,
-            on_settings_changed=self._on_ui_settings_changed,
-        )
-        self.journal = JournalProcessor(
-            self.state,
-            refresh_ui=self._refresh_ui_safe,
-            on_session_start=self._on_session_start,
-            on_session_end=self._on_session_end,
-            persist_inferred_capacities=self._persist_inferred_capacities,
-            notify_mining_activity=self._handle_mining_activity,
-            session_recorder=self.session_recorder,
-            edsm_client=self.edsm,
-        )
-
-        self.plugin_dir: Optional[Path] = None
-        self._latest_version: Optional[str] = None
-        self._update_ready_version: Optional[str] = None
-        self._version_check_started = False
-
-    # ------------------------------------------------------------------
-    # EDMC lifecycle hooks
-    # ------------------------------------------------------------------
-    def plugin_start(self, plugin_dir: str) -> str:
-        self.plugin_dir = Path(plugin_dir)
-        self.state.plugin_dir = self.plugin_dir
-        self._sync_logger_level()
-        _log.info("Starting %s v%s", PLUGIN_NAME, PLUGIN_VERSION)
-        self.preferences.load(self.state)
-        self.overlay_helper.refresh_availability()
-        self._overlay_enabled_last = self.state.overlay_enabled
-        if self.state.overlay_enabled:
-            self.overlay_helper.trigger_preview(duration_seconds=5)
-        self.inara.load_mapping(self.plugin_dir / "commodity_links.json")
-        self._ensure_version_check()
-
-        try:
-            self.update_manager = UpdateManager(
-                self.plugin_dir,
-                on_update_ready=self._handle_update_ready,
-            )
-            self.update_manager.start()
-        except Exception:
-            _log.exception("Failed to start auto-update manager")
-
-        return PLUGIN_NAME
-
-    def plugin_app(self, parent: tk.Widget) -> tk.Frame:
-        frame = self.ui.build(parent)
-        self._refresh_ui_safe()
-        self.ui.update_version_label(
-            PLUGIN_VERSION,
-            self._latest_version,
-            self._update_ready_version is not None,
-        )
-        self.ui.schedule_rate_update()
-        return frame
-
-    def plugin_prefs(
-        self,
-        parent: tk.Widget,
-        cmdr: Optional[str] = None,
-        is_beta: bool = False,
-    ) -> tk.Widget:
-        if nb is not None:
-            container: tk.Widget = nb.Frame(parent)
-        else:
-            container = ttk.Frame(parent)
-        prefs = self.ui.build_preferences(container)
-        prefs.grid(row=0, column=0, sticky="nsew")
-        container.columnconfigure(0, weight=1)
-        container.rowconfigure(0, weight=1)
-        if cmdr:
-            self.state.cmdr_name = cmdr
-        return container
-
-    def plugin_stop(self) -> None:
-        _log.info("Stopping %s", PLUGIN_NAME)
-        if self.update_manager:
-            try:
-                self.update_manager.stop()
-            except Exception:
-                _log.exception("Failed to stop update manager")
-        self._wait_for_version_thread()
-        self._persist_preferences()
-        self.ui.cancel_rate_update()
-        self.ui.close_histogram_windows()
-        self._cancel_overlay_refresh()
-        self.overlay_helper.clear_preview()
-        reset_mining_state(self.state)
-        self._refresh_ui_safe()
-
-    def handle_journal_entry(
-        self,
-        entry: dict,
-        shared_state: Optional[dict] = None,
-        cmdr: Optional[str] = None,
-    ) -> None:
-        self._update_commander(entry, shared_state, cmdr)
-        self.journal.handle_entry(entry, shared_state)
-
-    def prefs_changed(self, cmdr: Optional[str], is_beta: bool) -> None:
-        self._sync_logger_level()
-        self.preferences.save(self.state)
-        if cmdr:
-            self.state.cmdr_name = cmdr
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _handle_reset_request(self) -> None:
-        now = datetime.now(timezone.utc)
-        state = self.state
-
-        session_was_active = bool(state.mining_start or state.is_mining)
-        if session_was_active:
-            state.is_mining = False
-            state.mining_end = now
-            if self.session_recorder:
-                try:
-                    self.session_recorder.end_session(
-                        now,
-                        reason="manual reset",
-                        reset=True,
-                        force_summary=state.send_reset_summary,
-                    )
-                except Exception:
-                    _log.exception("Failed to finalize mining session during reset")
-            self._on_session_end()
-        else:
-            self.ui.cancel_rate_update()
-
-        reset_mining_state(state)
-        self.ui.clear_transient_widgets()
-        self.ui.set_paused(False, source="system")
-        self._refresh_ui_safe()
-
-    def _refresh_ui_safe(self) -> None:
-        try:
-            self.ui.refresh()
-        except Exception:
-            _log.exception("Failed to refresh Mining Analytics UI")
-        self._refresh_overlay_now()
-        self._schedule_overlay_refresh()
-
-    def _refresh_overlay_now(self) -> None:
-        try:
-            self.overlay_helper.refresh_availability()
-            self.overlay_helper.push_metrics()
-        except Exception:
-            _log.exception("Failed to update EDMCOverlay metrics")
-
-    def _schedule_overlay_refresh(self) -> None:
-        if self._overlay_refresh_job is not None:
-            return
-        if not self._should_refresh_overlay():
-            return
-        frame = self.ui.get_root()
-        if frame is None or not frame.winfo_exists():
-            return
-        interval_ms = max(200, int(self.state.overlay_refresh_interval_ms or 1000))
-        delay_ms = interval_ms
-        preview_remaining = self.overlay_helper.preview_seconds_remaining()
-        if preview_remaining is not None and preview_remaining > 0:
-            preview_delay = int(preview_remaining * 1000) + 200
-            delay_ms = min(delay_ms, max(200, preview_delay))
-        self._overlay_refresh_job = frame.after(delay_ms, self._overlay_tick)
-
-    def _cancel_overlay_refresh(self) -> None:
-        if self._overlay_refresh_job is None:
-            return
-        frame = self.ui.get_root()
-        if frame and frame.winfo_exists():
-            try:
-                frame.after_cancel(self._overlay_refresh_job)
-            except Exception:
-                pass
-        self._overlay_refresh_job = None
-
-    def _overlay_tick(self) -> None:
-        self._overlay_refresh_job = None
-        self._refresh_overlay_now()
-        if self._should_refresh_overlay():
-            self._schedule_overlay_refresh()
-
-    def _should_refresh_overlay(self) -> bool:
-        if not self.state.overlay_enabled:
-            return False
-        if self.state.is_mining and bool(self.state.overlay_available):
-            return True
-        if self.overlay_helper.is_preview_active() and bool(self.state.overlay_available):
-            return True
-        return False
-
-    def _schedule_ui_refresh(self) -> None:
-        frame = self.ui.get_root()
-        if frame is not None and frame.winfo_exists():
-            try:
-                frame.after(0, self._refresh_ui_safe)
-                return
-            except Exception:
-                pass
-        self._refresh_ui_safe()
-
-    def _persist_preferences(self) -> None:
-        try:
-            self.preferences.save(self.state)
-        except Exception:
-            _log.exception("Failed to persist plugin preferences")
-
-    def _on_ui_settings_changed(self) -> None:
-        self._persist_preferences()
-        was_enabled = self._overlay_enabled_last
-        self._overlay_enabled_last = self.state.overlay_enabled
-        if self.state.overlay_enabled and not was_enabled:
-            self.overlay_helper.trigger_preview(duration_seconds=5)
-        elif not self.state.overlay_enabled and was_enabled:
-            self.overlay_helper.clear_preview()
-        self._cancel_overlay_refresh()
-        self._refresh_overlay_now()
-        self._schedule_overlay_refresh()
-
-    def _on_session_start(self) -> None:
-        self.ui.schedule_rate_update()
-        self.overlay_helper.clear_preview()
-        self._cancel_overlay_refresh()
-        self._refresh_overlay_now()
-        self._schedule_overlay_refresh()
-
-    def _on_session_end(self) -> None:
-        self.ui.cancel_rate_update()
-        self._cancel_overlay_refresh()
-        self._refresh_ui_safe()
-        self._persist_inferred_capacities()
-
-    def _sync_logger_level(self) -> None:
-        try:
-            set_log_level(_resolve_edmc_log_level())
-        except Exception:
-            pass
-
-    def _persist_inferred_capacities(self) -> None:
-        try:
-            self.preferences.save_inferred_capacities(self.state)
-        except Exception:
-            _log.exception("Failed to persist inferred cargo capacities")
-
-    def _handle_mining_activity(self, reason: str) -> None:
-        if not self.state.auto_unpause_on_event or not self.state.is_paused:
-            return
-        _log.debug("Mining activity detected (%s); auto-resuming paused updates", reason)
-        try:
-            self.ui.set_paused(False, source="auto")
-        except Exception:
-            _log.exception("Failed to auto-resume after %s", reason)
-
-    def _handle_pause_change(self, paused: bool, source: str, timestamp: datetime) -> None:
-        try:
-            self.session_recorder.record_pause(timestamp, paused=paused, source=source)
-        except Exception:
-            _log.exception("Failed to record pause state change")
-
-    def _handle_reset_inferred_capacities(self) -> None:
-        _log.info("Resetting inferred cargo capacities at user request")
-        self.preferences.reset_inferred_capacities(self.state)
-        if self.state.cargo_capacity_is_inferred:
-            self.state.cargo_capacity = None
-            self.state.cargo_capacity_is_inferred = False
-        self._refresh_ui_safe()
-
-    def _handle_test_webhook(self) -> None:
-        try:
-            _log.info("Dispatching Discord webhook test message")
-            self.session_recorder.send_test_message()
-        except ValueError as exc:
-            _log.warning("Discord webhook test skipped: %s", exc)
-        except Exception:
-            _log.exception("Failed to send Discord webhook test message")
-
-    def _update_commander(
-        self,
-        entry: Optional[dict],
-        shared_state: Optional[dict],
-        cmdr: Optional[str],
-    ) -> None:
-        commander: Optional[str] = cmdr
-        if isinstance(entry, dict):
-            commander = commander or entry.get("Cmdr") or entry.get("Commander")
-            if not commander:
-                user = entry.get("UserName")
-                if isinstance(user, str) and user.strip():
-                    commander = user
-        if not commander and isinstance(shared_state, dict):
-            commander = shared_state.get("Cmdr") or shared_state.get("Commander")
-        if commander:
-            commander_str = str(commander).strip()
-            if commander_str:
-                self.state.cmdr_name = commander_str
-
-    # ------------------------------------------------------------------
-    # Version checking
-    # ------------------------------------------------------------------
-    def _ensure_version_check(self) -> None:
-        if self._version_check_started:
-            thread = self._version_thread
-            if thread and thread.is_alive():
-                return
-        self._version_check_started = True
-        thread = threading.Thread(target=self._check_for_updates, name="EDMCMiningVersion", daemon=False)
-        self._version_thread = thread
-        thread.start()
-
-    def _wait_for_version_thread(self, timeout: float = 5.0) -> None:
-        thread = self._version_thread
-        if thread and thread.is_alive():
-            try:
-                thread.join(timeout)
-            except Exception:
-                _log.exception("Failed while waiting for version check thread")
-            if thread.is_alive():
-                _log.debug("Version check thread still running after stop timeout")
-                return
-        self._version_thread = None
-
-    def _fetch_latest_tag(self) -> Optional[str]:
-        session = get_shared_session()
-        try:
-            response = session.get(GITHUB_TAGS_API, timeout=5)
-            response.raise_for_status()
-        except requests.RequestException as exc:
-            _log.debug("Tag lookup failed: %s", exc)
-            return None
-
-        try:
-            payload = response.json()
-        except ValueError:
-            _log.debug("Tag lookup response was not valid JSON")
-            return None
-
-        if not isinstance(payload, list) or not payload:
-            return None
-        tag_payload = payload[0]
-        tag = tag_payload.get("name") or tag_payload.get("ref")
-        if isinstance(tag, str) and tag.startswith("refs/tags/"):
-            tag = tag.split("/", 2)[-1]
-        return tag if isinstance(tag, str) else None
-
-    def _check_for_updates(self) -> None:
-        session = get_shared_session()
-        try:
-            response = session.get(GITHUB_RELEASES_API, timeout=5)
-            response.raise_for_status()
-        except requests.HTTPError as exc:
-            status = exc.response.status_code if exc.response is not None else "unknown"
-            if status == 404:
-                _log.debug("GitHub releases endpoint returned 404; falling back to tags")
-                latest = self._fetch_latest_tag()
-                if latest:
-                    self._handle_latest_version(latest)
-                else:
-                    _log.debug("Version check fallback to tags did not return any versions")
-                return
-            _log.debug("Version check failed with HTTP status %s: %s", status, exc)
-            return
-        except requests.RequestException as exc:
-            _log.debug("Version check failed: %s", exc)
-            return
-        else:
-            try:
-                payload = response.json()
-            except ValueError:
-                _log.debug("Version check response was not valid JSON")
-                return
-
-            latest = payload.get("tag_name") or payload.get("name")
-            if not latest:
-                _log.debug("Version check succeeded but no tag information was found")
-                return
-
-            self._handle_latest_version(latest)
-        finally:
-            self._version_thread = None
-
-    def _log_version_status(self) -> None:
-        if not self._latest_version:
-            return
-        if is_newer_version(self._latest_version, PLUGIN_VERSION):
-            _log.info(
-                "A newer version of %s is available: %s (current %s)",
-                PLUGIN_NAME,
-                self._latest_version,
-                PLUGIN_VERSION,
-            )
-        elif is_newer_version(PLUGIN_VERSION, self._latest_version):
-            _log.debug(
-                "%s is ahead of the published version %s (local %s)",
-                PLUGIN_NAME,
-                self._latest_version,
-                PLUGIN_VERSION,
-            )
-        else:
-            _log.debug("%s is up to date (version %s)", PLUGIN_NAME, PLUGIN_VERSION)
-        self._schedule_version_label_update()
-
-    def _schedule_version_label_update(self) -> None:
-        root = self.ui.get_root()
-        if root and getattr(root, "after", None):
-            root.after(
-                0,
-                lambda: self.ui.update_version_label(
-                    PLUGIN_VERSION,
-                    self._latest_version,
-                    self._update_ready_version is not None,
-                ),
-            )
-
-    def _handle_latest_version(self, latest: str) -> None:
-        latest_value = normalize_version(latest) or latest.strip()
-        self._latest_version = latest_value
-
-        if not is_newer_version(latest_value, PLUGIN_VERSION):
-            self._update_ready_version = None
-        elif (
-            self._update_ready_version is not None
-            and self._update_ready_version != latest_value
-        ):
-            self._update_ready_version = None
-
-        self._log_version_status()
-
-    def _handle_update_ready(self, version: str) -> None:
-        ready_version = normalize_version(version) or version.strip()
-        self._update_ready_version = ready_version or None
-
-        if ready_version and (
-            self._latest_version is None
-            or is_newer_version(ready_version, self._latest_version)
-        ):
-            self._latest_version = ready_version
-
-        self._schedule_version_label_update()
diff --git a/preferences.py b/preferences.py
deleted file mode 100644
index 42e0b45..0000000
--- a/preferences.py
+++ /dev/null
@@ -1,536 +0,0 @@
-"""Preference loading and persistence for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-import json
-import logging
-from typing import Dict, List, Optional, Sequence
-
-try:
-    from config import config  # type: ignore[import]
-except ImportError:  # pragma: no cover - only available inside EDMC
-    config = None  # type: ignore[assignment]
-
-from state import MiningState
-from logging_utils import get_logger
-
-
-_log = get_logger("preferences")
-
-
-def clamp_bin_size(value: int) -> int:
-    try:
-        size = int(value)
-    except (TypeError, ValueError):
-        size = 10
-    return max(1, min(100, size))
-
-
-def clamp_rate_interval(value: int) -> int:
-    try:
-        interval = int(value)
-    except (TypeError, ValueError):
-        interval = 30
-    return max(5, min(3600, interval))
-
-
-def clamp_session_retention(value: int) -> int:
-    try:
-        limit = int(value)
-    except (TypeError, ValueError):
-        limit = 30
-    return max(1, min(500, limit))
-
-
-def clamp_positive_int(value: int, default: int, maximum: int = 10_000) -> int:
-    try:
-        result = int(value)
-    except (TypeError, ValueError):
-        result = default
-    return max(1, min(maximum, result))
-
-
-def clamp_overlay_coordinate(value: int, default: int) -> int:
-    try:
-        result = int(value)
-    except (TypeError, ValueError):
-        result = default
-    return max(0, min(4000, result))
-
-
-def clamp_overlay_interval(value: int, default: int) -> int:
-    try:
-        result = int(value)
-    except (TypeError, ValueError):
-        result = default
-    return max(200, min(60_000, result))
-
-
-class PreferencesManager:
-    """Loads and persists user preferences via EDMC's config object."""
-
-    def load(self, state: MiningState) -> None:
-        if config is None:
-            state.histogram_bin_size = 10
-            state.rate_interval_seconds = 30
-            state.inara_settings.search_mode = 1
-            state.inara_settings.include_carriers = True
-            state.inara_settings.include_surface = True
-            state.inferred_capacity_map = {}
-            state.auto_unpause_on_event = True
-            state.session_logging_enabled = False
-            state.session_log_retention = 30
-            state.discord_webhook_url = ""
-            state.send_summary_to_discord = False
-            state.send_reset_summary = False
-            state.discord_images = []
-            state.refinement_lookback_seconds = 10
-            state.rpm_threshold_red = 1
-            state.rpm_threshold_yellow = 20
-            state.rpm_threshold_green = 40
-            state.overlay_enabled = False
-            state.overlay_anchor_x = 40
-            state.overlay_anchor_y = 120
-            state.overlay_refresh_interval_ms = 1000
-            return
-
-        state.histogram_bin_size = clamp_bin_size(self._get_int("edmc_mining_histogram_bin", 10))
-        state.rate_interval_seconds = clamp_rate_interval(self._get_int("edmc_mining_rate_interval", 30))
-
-        search_mode = self._get_int("edmc_mining_inara_search_mode", 1)
-        state.inara_settings.search_mode = 3 if search_mode == 3 else 1
-
-        include_carriers = self._get_int("edmc_mining_inara_include_carriers", 1)
-        state.inara_settings.include_carriers = bool(include_carriers)
-
-        include_surface = self._get_int("edmc_mining_inara_include_surface", 1)
-        state.inara_settings.include_surface = bool(include_surface)
-
-        state.inferred_capacity_map = self._load_inferred_capacities()
-        state.auto_unpause_on_event = bool(self._get_int("edmc_mining_auto_unpause", 1))
-        state.session_logging_enabled = bool(self._get_int("edmc_mining_session_logging", 0))
-        state.session_log_retention = clamp_session_retention(
-            self._get_int("edmc_mining_session_retention", 30)
-        )
-        state.discord_webhook_url = self._get_str("edmc_mining_discord_webhook", "").strip()
-        state.send_summary_to_discord = bool(self._get_int("edmc_mining_discord_summary", 0))
-        state.send_reset_summary = bool(self._get_int("edmc_mining_discord_reset_summary", 0))
-        state.discord_images = self._load_discord_images("edmc_mining_discord_images")
-        legacy_image = self._get_optional_str("edmc_mining_discord_image")
-        if legacy_image:
-            state.discord_images.append(("", legacy_image))
-        state.discord_image_cycle = {}
-        state.show_mined_commodities = bool(
-            self._get_int("edmc_mining_show_commodities", int(state.show_mined_commodities))
-        )
-        state.show_materials_collected = bool(
-            self._get_int("edmc_mining_show_materials", int(state.show_materials_collected))
-        )
-        state.warn_on_non_metallic_ring = bool(
-            self._get_int(
-                "edmc_mining_warn_non_metallic",
-                int(state.warn_on_non_metallic_ring),
-            )
-        )
-        state.refinement_lookback_seconds = clamp_positive_int(
-            self._get_int("edmc_mining_refinement_window", state.refinement_lookback_seconds),
-            state.refinement_lookback_seconds,
-            maximum=3600,
-        )
-
-        raw_red_threshold = self._get_int("edmc_mining_rpm_red", state.rpm_threshold_red)
-        if raw_red_threshold == 10:  # migrate legacy default to the new baseline
-            raw_red_threshold = 1
-        state.rpm_threshold_red = clamp_positive_int(
-            raw_red_threshold,
-            1,
-            maximum=10_000,
-        )
-        state.rpm_threshold_yellow = clamp_positive_int(
-            self._get_int("edmc_mining_rpm_yellow", state.rpm_threshold_yellow),
-            state.rpm_threshold_yellow,
-            maximum=10_000,
-        )
-
-        raw_green_threshold = self._get_int("edmc_mining_rpm_green", state.rpm_threshold_green)
-        if raw_green_threshold == 30:  # migrate legacy default to new baseline
-            raw_green_threshold = 40
-        state.rpm_threshold_green = clamp_positive_int(
-            raw_green_threshold,
-            40,
-            maximum=10_000,
-        )
-        state.overlay_enabled = bool(self._get_int("edmc_mining_overlay_enabled", int(state.overlay_enabled)))
-        state.overlay_anchor_x = clamp_overlay_coordinate(
-            self._get_int("edmc_mining_overlay_anchor_x", state.overlay_anchor_x),
-            state.overlay_anchor_x,
-        )
-        state.overlay_anchor_y = clamp_overlay_coordinate(
-            self._get_int("edmc_mining_overlay_anchor_y", state.overlay_anchor_y),
-            state.overlay_anchor_y,
-        )
-        state.overlay_refresh_interval_ms = clamp_overlay_interval(
-            self._get_int("edmc_mining_overlay_refresh_ms", state.overlay_refresh_interval_ms),
-            state.overlay_refresh_interval_ms,
-        )
-        state.spansh_last_distance_min = self._get_float("edmc_mining_spansh_distance_min", None)
-        state.spansh_last_distance_max = self._get_float("edmc_mining_spansh_distance_max", None)
-        state.spansh_last_ring_signals = self._load_string_list("edmc_mining_spansh_ring_signals")
-        state.spansh_last_reserve_levels = self._load_string_list("edmc_mining_spansh_reserve_levels")
-        state.spansh_last_ring_types = self._load_string_list("edmc_mining_spansh_ring_types")
-        state.spansh_last_min_hotspots = self._get_optional_int("edmc_mining_spansh_min_hotspots")
-
-    def save(self, state: MiningState) -> None:
-        if config is None:
-            return
-
-        try:
-            config.set("edmc_mining_histogram_bin", state.histogram_bin_size)
-        except Exception:
-            _log.exception("Failed to persist histogram bin size preference")
-
-        try:
-            config.set("edmc_mining_rate_interval", state.rate_interval_seconds)
-        except Exception:
-            _log.exception("Failed to persist rate update interval")
-
-        try:
-            config.set("edmc_mining_inara_search_mode", state.inara_settings.search_mode)
-        except Exception:
-            _log.exception("Failed to persist Inara search mode preference")
-
-        try:
-            config.set("edmc_mining_inara_include_carriers", int(state.inara_settings.include_carriers))
-        except Exception:
-            _log.exception("Failed to persist Inara carrier preference")
-
-        try:
-            config.set("edmc_mining_inara_include_surface", int(state.inara_settings.include_surface))
-        except Exception:
-            _log.exception("Failed to persist Inara surface preference")
-
-        self.save_inferred_capacities(state)
-
-        try:
-            config.set("edmc_mining_auto_unpause", int(state.auto_unpause_on_event))
-        except Exception:
-            _log.exception("Failed to persist auto-unpause preference")
-
-        try:
-            config.set("edmc_mining_session_logging", int(state.session_logging_enabled))
-        except Exception:
-            _log.exception("Failed to persist session logging preference")
-
-        try:
-            config.set(
-                "edmc_mining_session_retention",
-                clamp_session_retention(state.session_log_retention),
-            )
-        except Exception:
-            _log.exception("Failed to persist session log retention preference")
-
-        try:
-            config.set("edmc_mining_discord_webhook", state.discord_webhook_url or "")
-        except Exception:
-            _log.exception("Failed to persist Discord webhook")
-
-        try:
-            config.set("edmc_mining_discord_summary", int(state.send_summary_to_discord))
-        except Exception:
-            _log.exception("Failed to persist Discord summary preference")
-
-        try:
-            config.set("edmc_mining_discord_reset_summary", int(state.send_reset_summary))
-        except Exception:
-            _log.exception("Failed to persist Discord reset summary preference")
-
-        try:
-            payload = json.dumps(state.discord_images)
-            config.set("edmc_mining_discord_images", payload)
-        except Exception:
-            _log.exception("Failed to persist Discord image list")
-
-        try:
-            config.set("edmc_mining_discord_image", "")
-        except Exception:
-            pass
-
-        try:
-            config.set("edmc_mining_show_commodities", int(state.show_mined_commodities))
-        except Exception:
-            _log.exception("Failed to persist commodities visibility preference")
-
-        try:
-            config.set("edmc_mining_show_materials", int(state.show_materials_collected))
-        except Exception:
-            _log.exception("Failed to persist materials visibility preference")
-
-        try:
-            config.set("edmc_mining_warn_non_metallic", int(state.warn_on_non_metallic_ring))
-        except Exception:
-            _log.exception("Failed to persist non-metallic warning preference")
-
-        try:
-            config.set(
-                "edmc_mining_refinement_window",
-                clamp_positive_int(state.refinement_lookback_seconds, 10, maximum=3600),
-            )
-        except Exception:
-            _log.exception("Failed to persist refinement lookback preference")
-
-        try:
-            config.set(
-                "edmc_mining_rpm_red",
-                clamp_positive_int(state.rpm_threshold_red, 1),
-            )
-        except Exception:
-            _log.exception("Failed to persist RPM red threshold")
-
-        try:
-            config.set(
-                "edmc_mining_rpm_yellow",
-                clamp_positive_int(state.rpm_threshold_yellow, 20),
-            )
-        except Exception:
-            _log.exception("Failed to persist RPM yellow threshold")
-
-        try:
-            config.set(
-                "edmc_mining_rpm_green",
-                clamp_positive_int(state.rpm_threshold_green, 40),
-            )
-        except Exception:
-            _log.exception("Failed to persist RPM green threshold")
-
-        try:
-            config.set("edmc_mining_overlay_enabled", int(state.overlay_enabled))
-        except Exception:
-            _log.exception("Failed to persist overlay enabled preference")
-
-        try:
-            config.set(
-                "edmc_mining_overlay_anchor_x",
-                clamp_overlay_coordinate(state.overlay_anchor_x, state.overlay_anchor_x),
-            )
-        except Exception:
-            _log.exception("Failed to persist overlay anchor X preference")
-
-        try:
-            config.set(
-                "edmc_mining_overlay_anchor_y",
-                clamp_overlay_coordinate(state.overlay_anchor_y, state.overlay_anchor_y),
-            )
-        except Exception:
-            _log.exception("Failed to persist overlay anchor Y preference")
-
-        try:
-            config.set(
-                "edmc_mining_overlay_refresh_ms",
-                clamp_overlay_interval(state.overlay_refresh_interval_ms, state.overlay_refresh_interval_ms),
-            )
-        except Exception:
-            _log.exception("Failed to persist overlay refresh interval preference")
-
-        try:
-            value = "" if state.spansh_last_distance_min is None else str(float(state.spansh_last_distance_min))
-            config.set("edmc_mining_spansh_distance_min", value)
-        except Exception:
-            _log.exception("Failed to persist Spansh minimum distance")
-
-        try:
-            value = "" if state.spansh_last_distance_max is None else str(float(state.spansh_last_distance_max))
-            config.set("edmc_mining_spansh_distance_max", value)
-        except Exception:
-            _log.exception("Failed to persist Spansh maximum distance")
-
-        if state.spansh_last_ring_signals is not None:
-            try:
-                payload = json.dumps(self._normalise_string_list(state.spansh_last_ring_signals))
-                config.set("edmc_mining_spansh_ring_signals", payload)
-            except Exception:
-                _log.exception("Failed to persist Spansh ring signals")
-
-        if state.spansh_last_reserve_levels is not None:
-            try:
-                payload = json.dumps(self._normalise_string_list(state.spansh_last_reserve_levels))
-                config.set("edmc_mining_spansh_reserve_levels", payload)
-            except Exception:
-                _log.exception("Failed to persist Spansh reserve levels")
-
-        if state.spansh_last_ring_types is not None:
-            try:
-                payload = json.dumps(self._normalise_string_list(state.spansh_last_ring_types))
-                config.set("edmc_mining_spansh_ring_types", payload)
-            except Exception:
-                _log.exception("Failed to persist Spansh ring types")
-
-        try:
-            value = (
-                str(max(1, int(state.spansh_last_min_hotspots)))
-                if state.spansh_last_min_hotspots is not None
-                else ""
-            )
-            config.set("edmc_mining_spansh_min_hotspots", value)
-        except Exception:
-            _log.exception("Failed to persist Spansh minimum hotspots")
-
-
-    @staticmethod
-    def _get_int(key: str, default: int) -> int:
-        if config is None:
-            return default
-        try:
-            return int(config.get_int(key=key, default=default))  # type: ignore[arg-type]
-        except Exception:
-            return default
-
-    def _get_str(self, key: str, default: str) -> str:
-        if config is None:
-            return default
-        try:
-            raw = config.get_str(key)  # type: ignore[arg-type]
-        except Exception:
-            raw = None
-        if not raw:
-            return default
-        return str(raw)
-
-    def _get_optional_str(self, key: str) -> Optional[str]:
-        if config is None:
-            return None
-        try:
-            raw = config.get_str(key)  # type: ignore[arg-type]
-        except Exception:
-            return None
-        if raw is None:
-            return None
-        value = str(raw).strip()
-        return value or None
-
-    def _get_optional_int(self, key: str) -> Optional[int]:
-        text = self._get_optional_str(key)
-        if text is None:
-            return None
-        try:
-            value = int(text)
-        except (TypeError, ValueError):
-            return None
-        if value < 1:
-            return 1
-        return value
-
-    def _get_float(self, key: str, default: Optional[float]) -> Optional[float]:
-        text = self._get_optional_str(key)
-        if not text:
-            return default
-        try:
-            return float(text)
-        except (TypeError, ValueError):
-            return default
-
-    def _load_inferred_capacities(self) -> Dict[str, int]:
-        payload = self._get_str("edmc_mining_inferred_cargo_map", "{}")
-        try:
-            data = json.loads(payload)
-        except Exception:
-            data = {}
-
-        inferred: Dict[str, int] = {}
-        if isinstance(data, dict):
-            for key, value in data.items():
-                if not isinstance(key, str):
-                    key = str(key)
-                try:
-                    capacity = int(value)
-                except (TypeError, ValueError):
-                    continue
-                if capacity > 0:
-                    inferred[key] = capacity
-        return inferred
-
-    def save_inferred_capacities(self, state: MiningState) -> None:
-        if config is None:
-            return
-
-        sanitized: Dict[str, int] = {}
-        for key, value in state.inferred_capacity_map.items():
-            if not key or value is None:
-                continue
-            try:
-                capacity = int(value)
-            except (TypeError, ValueError):
-                continue
-            if capacity > 0:
-                sanitized[str(key)] = capacity
-
-        try:
-            payload = json.dumps(sanitized, separators=(",", ":"))
-        except Exception:
-            _log.exception("Failed to encode inferred cargo capacities for persistence")
-            return
-
-        try:
-            config.set("edmc_mining_inferred_cargo_map", payload)
-        except Exception:
-            _log.exception("Failed to persist inferred cargo capacities")
-
-    @staticmethod
-    def _normalise_string_list(values: Optional[Sequence[str]]) -> List[str]:
-        if not values:
-            return []
-        cleaned: List[str] = []
-        for value in values:
-            if not value:
-                continue
-            item = str(value)
-            if item not in cleaned:
-                cleaned.append(item)
-        return cleaned
-
-    def _load_string_list(self, key: str) -> Optional[List[str]]:
-        payload = self._get_optional_str(key)
-        if payload is None:
-            return None
-        try:
-            data = json.loads(payload)
-        except Exception:
-            return []
-        if not isinstance(data, list):
-            return []
-        cleaned: List[str] = []
-        for item in data:
-            if isinstance(item, str) and item and item not in cleaned:
-                cleaned.append(item)
-        return cleaned
-
-    def _load_discord_images(self, key: str) -> List[tuple[str, str]]:
-        payload = self._get_optional_str(key)
-        if not payload:
-            return []
-        try:
-            data = json.loads(payload)
-        except Exception:
-            return []
-        entries: List[tuple[str, str]] = []
-        if isinstance(data, list):
-            for item in data:
-                if isinstance(item, (list, tuple)) and len(item) >= 2:
-                    ship = str(item[0] or "")
-                    url = str(item[1] or "").strip()
-                    if url:
-                        entries.append((ship, url))
-                elif isinstance(item, dict):
-                    ship = str(item.get("ship") or "")
-                    url = str(item.get("url") or "").strip()
-                    if url:
-                        entries.append((ship, url))
-        return entries
-
-    def reset_inferred_capacities(self, state: MiningState) -> None:
-        state.inferred_capacity_map.clear()
-        if config is None:
-            return
-        try:
-            config.set("edmc_mining_inferred_cargo_map", "{}")
-        except Exception:
-            _log.exception("Failed to clear inferred cargo capacities from config")
diff --git a/session_recorder.py b/session_recorder.py
deleted file mode 100644
index ba3cd76..0000000
--- a/session_recorder.py
+++ /dev/null
@@ -1,677 +0,0 @@
-"""Session recording utilities for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-import json
-from collections import Counter
-from datetime import datetime, timezone
-from pathlib import Path
-import threading
-from typing import Any, Dict, Iterable, Optional
-
-from logging_utils import get_logger
-from state import (
-    MiningState,
-    compute_percentage_stats,
-    resolve_commodity_display_name,
-    update_rpm,
-)
-from integrations.discord_summary import (
-    build_summary_message,
-    build_test_message,
-    format_duration,
-    send_webhook,
-)
-
-
-_log = get_logger("session_recorder")
-
-
-class SessionRecorder:
-    """Accumulates session telemetry and persists it to JSON when mining ends."""
-
-    def __init__(self, state: MiningState) -> None:
-        self._state = state
-        self._events: list[dict[str, Any]] = []
-        self._recording: bool = False
-        self._session_start: Optional[datetime] = None
-        self._session_end: Optional[datetime] = None
-
-    # ------------------------------------------------------------------
-    # Lifecycle
-    # ------------------------------------------------------------------
-    def start_session(self, timestamp: datetime, *, reason: str) -> None:
-        should_generate = bool(
-            self._state.session_logging_enabled or self._state.send_summary_to_discord
-        )
-        self._events.clear()
-        self._session_start = self._ensure_aware(timestamp)
-        self._session_end = None
-        self._recording = bool(self._state.session_logging_enabled)
-        if not should_generate:
-            return
-        if self._recording:
-            self._record_event(
-                "mining_session_started",
-                self._session_start,
-                {"reason": reason},
-            )
-
-    def end_session(
-        self,
-        timestamp: datetime,
-        *,
-        reason: str,
-        reset: bool = False,
-        force_summary: bool = False,
-    ) -> None:
-        self._session_end = self._ensure_aware(timestamp)
-        send_setting = (
-            self._state.send_reset_summary if reset else self._state.send_summary_to_discord
-        )
-        should_generate = bool(
-            self._state.session_logging_enabled
-            or send_setting
-            or force_summary
-        )
-        if not should_generate:
-            self._events.clear()
-            self._session_start = None
-            self._session_end = None
-            return
-
-        if self._recording:
-            self._record_event(
-                "mining_session_stopped",
-                self._session_end,
-                {"reason": reason},
-            )
-
-        try:
-            payload = self._build_payload()
-        except Exception:
-            _log.exception("Failed to build session payload; skipping export")
-            payload = None
-
-        json_path: Optional[Path] = None
-        if payload and self._state.session_logging_enabled:
-            json_path = self._write_payload(payload)
-
-        if payload:
-            meta = payload.setdefault("meta", {})
-            meta["session_end_reason"] = reason
-            if reset:
-                meta["ended_via_reset"] = True
-            self._maybe_send_summary(
-                payload,
-                json_path,
-                reset=reset,
-                force_summary=force_summary,
-            )
-
-        self._events.clear()
-        self._recording = False
-        self._session_start = None
-        self._session_end = None
-
-    # ------------------------------------------------------------------
-    # Event capture
-    # ------------------------------------------------------------------
-    def record_pause(self, timestamp: datetime, *, paused: bool, source: str) -> None:
-        if not self._recording:
-            return
-        event_type = "mining_session_paused" if paused else "mining_session_resumed"
-        details = {"mode": source, "auto": source == "auto"}
-        self._record_event(event_type, timestamp, details)
-
-    def record_mining_refined(
-        self,
-        timestamp: datetime,
-        *,
-        commodity_localised: Optional[str],
-        commodity_type: Optional[str],
-    ) -> None:
-        if not self._recording:
-            return
-        details = {
-            "type_localised": commodity_localised,
-            "type": commodity_type,
-        }
-        self._record_event("mining_refined", timestamp, details)
-
-    def record_cargo_event(
-        self,
-        timestamp: datetime,
-        *,
-        total_cargo: int,
-        inventory: Dict[str, int],
-        limpets: Optional[int],
-        event_count: Optional[int],
-    ) -> None:
-        if not self._recording:
-            return
-        friendly_inventory = {
-            self._format_name(name): qty for name, qty in sorted(inventory.items())
-        }
-        details = {
-            "total_cargo": total_cargo,
-            "count": event_count,
-            "inventory": friendly_inventory,
-            "limpets": limpets,
-        }
-        self._record_event("cargo", timestamp, details)
-
-    def record_buy_drones(self, timestamp: datetime, *, count: Optional[int], drone_type: Optional[str]) -> None:
-        if not self._recording:
-            return
-        details: dict[str, Any] = {}
-        if count is not None:
-            details["count"] = count
-        if drone_type:
-            details["type"] = drone_type
-        self._record_event("buy_drones", timestamp, details)
-
-    def record_launch_drone(self, timestamp: datetime, *, drone_type: Optional[str]) -> None:
-        if not self._recording:
-            return
-        details = {"type": drone_type}
-        self._record_event("launch_drone", timestamp, details)
-
-    def record_prospected_asteroid(
-        self,
-        timestamp: datetime,
-        *,
-        materials: Iterable[dict[str, Any]],
-        content_level: Optional[str],
-        remaining: Optional[float],
-        already_mined: bool,
-        duplicate: bool,
-        body: Optional[str],
-    ) -> None:
-        if not self._recording:
-            return
-        formatted_materials: list[dict[str, Any]] = []
-        for material in materials:
-            name = self._format_name(str(material.get("Name", "")))
-            proportion = material.get("Proportion")
-            try:
-                proportion_value = float(proportion)
-            except (TypeError, ValueError):
-                proportion_value = None
-            formatted_materials.append(
-                {
-                    "name": name,
-                    "percentage": proportion_value,
-                }
-            )
-        details: dict[str, Any] = {
-            "materials": formatted_materials,
-            "content": content_level,
-            "remaining_percent": remaining,
-            "already_mined": already_mined,
-            "duplicate": duplicate,
-        }
-        if body:
-            details["body"] = body
-        self._record_event("prospected_asteroid", timestamp, details)
-
-    # ------------------------------------------------------------------
-    # Payload construction
-    # ------------------------------------------------------------------
-    def _build_payload(self) -> dict[str, Any]:
-        state = self._state
-        start = self._ensure_aware(
-            state.mining_start or self._session_start or datetime.now(timezone.utc)
-        )
-        end = self._ensure_aware(
-            state.mining_end or self._session_end or datetime.now(timezone.utc)
-        )
-        duration_seconds = max(0.0, (end - start).total_seconds())
-
-        update_rpm(state, end)
-        current_rpm = round(state.current_rpm, 2)
-        max_rpm = round(state.max_rpm, 2)
-
-        total_cargo = self._safe_sum(state.cargo_totals.values())
-        tons_per_hour = self._compute_rate(total_cargo, duration_seconds)
-        if tons_per_hour is not None:
-            tons_per_hour = round(tons_per_hour, 3)
-
-        ring_name = self._derive_ring_name()
-        body_value = state.edsm_body_name or state.mining_location
-        if (
-            isinstance(body_value, str)
-            and isinstance(ring_name, str)
-            and body_value.strip().lower() == ring_name.strip().lower()
-        ):
-            body_value = self._strip_ring_from_name(body_value)
-
-        location_meta = {
-            "body": body_value,
-            "system": state.current_system,
-        }
-        if ring_name:
-            location_meta["ring"] = ring_name
-        if state.edsm_reserve_level:
-            location_meta["reserve_level"] = state.edsm_reserve_level
-        if state.edsm_ring_type:
-            location_meta["ring_type"] = state.edsm_ring_type
-
-        meta: dict[str, Any] = {
-            "start_time": self._isoformat(start),
-            "end_time": self._isoformat(end),
-            "duration_seconds": duration_seconds,
-            "overall_tph": {
-                "tons": total_cargo,
-                "elapsed_seconds": duration_seconds,
-                "tons_per_hour": tons_per_hour,
-            },
-            "location": location_meta,
-            "ship": state.current_ship,
-            "prospected": {
-                "total": state.prospected_count,
-                "already_mined": state.already_mined_count,
-                "duplicates": state.duplicate_prospected,
-            },
-            "prospectors_launched": state.prospector_launched_count,
-            "collectors_launched": state.collection_drones_launched,
-            "collectors_abandoned": state.abandoned_limpets,
-            "limpets_remaining": state.limpets_remaining,
-            "content_summary": {
-                "High": state.prospect_content_counts.get("High", 0),
-                "Medium": state.prospect_content_counts.get("Medium", 0),
-                "Low": state.prospect_content_counts.get("Low", 0),
-            },
-            "inventory_tonnage": state.current_cargo_tonnage,
-            "cargo_capacity": state.cargo_capacity,
-            "materials": self._materials_snapshot(state.materials_collected),
-            "max_rpm": max_rpm,
-            "refinement_activity": {
-                "lookback_seconds": state.refinement_lookback_seconds,
-                "current_rpm": current_rpm,
-                "max_rpm": max_rpm,
-            },
-        }
-
-        meta["commander"] = (state.cmdr_name or "").strip() or "Unknown"
-        # ring is now recorded inside meta["location"]
-        meta["prospectors_lost"] = max(0, state.prospector_launched_count - state.prospected_count)
-
-        payload = {
-            "meta": meta,
-            "commodities": self._commodity_breakdown(end),
-            "events": list(self._events),
-        }
-        return payload
-
-    def _derive_ring_name(self) -> Optional[str]:
-        ring = getattr(self._state, "mining_ring", None)
-        if isinstance(ring, str) and ring.strip():
-            return ring.strip()
-        location = self._state.mining_location
-        if isinstance(location, str) and "ring" in location.lower():
-            return location
-        return None
-
-    @staticmethod
-    def _strip_ring_from_name(value: str) -> str:
-        candidate = value.strip()
-        lowered = candidate.lower()
-        suffix = " ring"
-        if lowered.endswith(suffix):
-            return candidate[: -len(suffix)].rstrip()
-        return candidate
-
-    def _materials_snapshot(self, materials: Counter[str]) -> list[dict[str, Any]]:
-        snapshot: list[dict[str, Any]] = []
-        for name, count in sorted(materials.items()):
-            snapshot.append({
-                "name": self._format_name(name),
-                "count": count,
-            })
-        return snapshot
-
-    def _commodity_breakdown(self, end: datetime) -> dict[str, Any]:
-        state = self._state
-        result: dict[str, Any] = {}
-        total_prospected = max(1, state.prospected_count)
-        for commodity, total in sorted(state.cargo_totals.items()):
-            friendly_name = self._format_name(commodity)
-            samples = list(state.prospected_samples.get(commodity, []))
-            sample_count = len(samples)
-            percent = (sample_count / total_prospected) * 100.0 if state.prospected_count else 0.0
-            percent = round(percent, 3)
-            breakdown = self._percent_breakdown(samples)
-            start_time = state.commodity_start_times.get(commodity)
-            elapsed_seconds: Optional[float] = None
-            if start_time:
-                elapsed_seconds = max(0.0, (end - self._ensure_aware(start_time)).total_seconds())
-            tph = self._compute_rate(total, elapsed_seconds) if elapsed_seconds else None
-            if tph is not None:
-                tph = round(tph, 3)
-            stats = compute_percentage_stats(samples)
-            percentage_stats: Optional[dict[str, Optional[float]]]
-            if stats:
-                min_pct, avg_pct, max_pct = stats
-                percentage_stats = {
-                    "min": round(min_pct, 3),
-                    "avg": round(avg_pct, 3),
-                    "max": round(max_pct, 3),
-                }
-            else:
-                percentage_stats = None
-            result[friendly_name] = {
-                "asteroids_prospected": sample_count,
-                "percentage_of_asteroids": percent,
-                "gathered": {
-                    "tons": total,
-                    "elapsed_seconds": elapsed_seconds,
-                },
-                "percentage_breakdown": breakdown,
-                "percentage_stats": percentage_stats,
-                "tons_per_hour": tph,
-            }
-        return result
-
-    def _percent_breakdown(self, samples: Iterable[float]) -> list[dict[str, Any]]:
-        counter: Counter[str] = Counter()
-        for value in samples:
-            try:
-                numeric = float(value)
-            except (TypeError, ValueError):
-                continue
-            key = f"{numeric:.2f}"
-            counter[key] += 1
-        return [
-            {"percentage": float(key), "count": counter[key]}
-            for key in sorted(counter.keys(), key=lambda v: float(v))
-        ]
-
-    # ------------------------------------------------------------------
-    # File management
-    # ------------------------------------------------------------------
-    def _write_payload(self, payload: dict[str, Any]) -> Optional[Path]:
-        directory = self._resolve_output_directory()
-        if directory is None:
-            _log.warning("Plugin directory unavailable; skipping session export")
-            return None
-        try:
-            directory.mkdir(parents=True, exist_ok=True)
-        except Exception:
-            _log.exception("Failed to create session export directory: %s", directory)
-            return None
-
-        end_time = self._session_end or datetime.now(timezone.utc)
-        filename = f"session_data_{int(end_time.timestamp())}.json"
-        path = directory / filename
-
-        try:
-            with path.open("w", encoding="utf-8") as handle:
-                json.dump(payload, handle, indent=2, sort_keys=False)
-        except Exception:
-            _log.exception("Failed to write session export: %s", path)
-            return None
-
-        self._enforce_retention(directory)
-        return path
-
-    def _resolve_output_directory(self) -> Optional[Path]:
-        plugin_dir = self._state.plugin_dir
-        if plugin_dir is None:
-            return None
-        return plugin_dir / "session_data"
-
-    def _enforce_retention(self, directory: Path) -> None:
-        limit = self._state.session_log_retention
-        try:
-            limit = int(limit)
-        except (TypeError, ValueError):
-            limit = 30
-        if limit <= 0:
-            return
-
-        files = sorted(directory.glob("session_data_*.json"), key=lambda path: path.stat().st_mtime)
-        if len(files) <= limit:
-            return
-
-        excess = len(files) - limit
-        for path in files[:excess]:
-            try:
-                path.unlink()
-            except FileNotFoundError:
-                continue
-            except Exception:
-                _log.exception("Failed to delete old session export: %s", path)
-
-    # ------------------------------------------------------------------
-    # Helpers
-    # ------------------------------------------------------------------
-    def _record_event(self, event_type: str, timestamp: datetime, details: Dict[str, Any]) -> None:
-        aware_time = self._ensure_aware(timestamp)
-        payload = {
-            "type": event_type,
-            "timestamp": self._isoformat(aware_time),
-            "details": details,
-        }
-        self._events.append(payload)
-
-    def _dispatch_webhook(
-        self,
-        url: str,
-        payload: Dict[str, Any],
-        *,
-        thread_name: str,
-        success_message: str,
-        failure_message: str,
-    ) -> None:
-        def worker() -> None:
-            success, detail = send_webhook(url, payload)
-            if success:
-                _log.info(success_message)
-            else:
-                detail_text = f": {detail}" if detail else ""
-                _log.warning(
-                    "%s%s (see prior logs for details)",
-                    failure_message,
-                    detail_text,
-                )
-
-        threading.Thread(target=worker, name=thread_name, daemon=True).start()
-
-    def _maybe_send_summary(
-        self,
-        payload: dict[str, Any],
-        json_path: Optional[Path],
-        *,
-        reset: bool = False,
-        force_summary: bool = False,
-    ) -> None:
-        should_send = bool(force_summary)
-        if not should_send:
-            if reset:
-                should_send = bool(self._state.send_reset_summary)
-            else:
-                should_send = bool(self._state.send_summary_to_discord)
-        if not should_send:
-            _log.debug("Discord summary disabled; skipping delivery")
-            return
-        url = (self._state.discord_webhook_url or "").strip()
-        if not url:
-            _log.debug("Discord summary disabled: webhook URL missing")
-            return
-        summary_text = self._render_summary(payload, json_path)
-        self._state.last_session_summary = summary_text
-        if not summary_text:
-            _log.debug("Skipping Discord summary: nothing to send")
-            return
-
-        message_payload = build_summary_message(self._state, payload, json_path)
-        self._dispatch_webhook(
-            url,
-            message_payload,
-            thread_name="EDMCMA-DiscordSummary",
-            success_message="Posted mining session summary to Discord",
-            failure_message="Discord session summary delivery failed",
-        )
-
-    def _render_summary(self, payload: dict[str, Any], json_path: Optional[Path]) -> str:
-        meta = payload.get("meta", {})
-        overall = meta.get("overall_tph", {})
-        duration_seconds = float(meta.get("duration_seconds", 0.0) or 0.0)
-        duration_text = format_duration(duration_seconds)
-        total_tons = overall.get("tons")
-        tph_value = overall.get("tons_per_hour")
-        tph_text = f"{tph_value:.1f}" if isinstance(tph_value, (int, float)) else "-"
-        location_info = meta.get("location", {})
-        body = location_info.get("body") or "Unknown"
-        system = location_info.get("system") or "Unknown"
-        location_line = None
-        if body:
-            location_line = body
-            extra_location = None
-        elif system:
-            location_line = system
-            extra_location = None
-        else:
-            location_line = "Unknown"
-            extra_location = None
-        ring_info = self._format_ring_info(
-            location_info.get("reserve_level") or meta.get("reserve_level"),
-            location_info.get("ring_type") or meta.get("ring_type"),
-        )
-        if ring_info:
-            extra_location = ring_info
-        if extra_location:
-            location_line = f"{location_line} ({extra_location})"
-        ship = meta.get("ship") or "Unknown ship"
-        commander = meta.get("commander") or self._state.cmdr_name or "Unknown"
-        prospected = meta.get("prospected", {})
-        content = meta.get("content_summary", {})
-        lines = [
-            "**Mining Session Summary**",
-            f"Commander: {commander}",
-            f"Location: {location_line}",
-            f"Ship: {ship}",
-            f"Duration: {duration_text}",
-            f"Total: {total_tons}t @ {tph_text} TPH",
-        ]
-        lines.append(
-            "Asteroids prospected: "
-            f"{prospected.get('total', 0)} (High {content.get('High', 0)}, "
-            f"Medium {content.get('Medium', 0)}, Low {content.get('Low', 0)})"
-        )
-        lines.append(
-            "Prospectors launched: "
-            f"{meta.get('prospectors_launched', 0)} | Lost: {meta.get('prospectors_lost', 0)} | Duplicates: {prospected.get('duplicates', 0)} | "
-            f"Collectors: {meta.get('collectors_launched', 0)} | Limpets remaining: {meta.get('limpets_remaining', 0)}"
-        )
-        lines.append(f"Collectors abandoned: {meta.get('collectors_abandoned', 0)}")
-
-        if meta.get("ended_via_reset"):
-            lines.append("Session ended via manual reset.")
-
-        rpm_meta = meta.get("refinement_activity", {})
-
-        def _format_rpm(value: Any) -> str:
-            try:
-                return f"{float(value):.1f}"
-            except (TypeError, ValueError):
-                return "-"
-
-        rpm_parts = [
-            f"max {_format_rpm(rpm_meta.get('max_rpm', meta.get('max_rpm')))} RPM"
-        ]
-        lines.append("Refinements: " + " | ".join(rpm_parts))
-
-        commodities = payload.get("commodities", {})
-        if commodities:
-            lines.append("Top commodities:")
-            top = sorted(
-                commodities.items(),
-                key=lambda item: item[1].get("gathered", {}).get("tons", 0),
-                reverse=True,
-            )[:3]
-            for name, info in top:
-                tons = info.get("gathered", {}).get("tons", 0)
-                tph = info.get("tons_per_hour")
-                tph_text = f"{tph:.1f} TPH" if isinstance(tph, (int, float)) else "-"
-                avg_pct = None
-                if isinstance(info.get("percentage_stats"), dict):
-                    avg_candidate = info["percentage_stats"].get("avg")
-                    if isinstance(avg_candidate, (int, float)):
-                        avg_pct = avg_candidate
-                avg_fragment = f" | Avg {avg_pct:.1f}%" if avg_pct is not None else ""
-                lines.append(f"• {name}: {tons}t ({tph_text}){avg_fragment}")
-
-        materials = meta.get("materials", [])
-        if materials:
-            mat_parts = [
-                f"{m.get('name')} x{m.get('count')}" for m in materials if m.get("name")
-            ]
-            if mat_parts:
-                lines.append("Materials: " + ", ".join(mat_parts))
-
-        if json_path is not None:
-            lines.append(f"Log: {json_path.name}")
-
-        summary = "\n".join(line for line in lines if line)
-        if len(summary) > 1900:
-            summary = summary[:1890].rstrip() + "…"
-        return summary
-
-    @staticmethod
-    def _format_ring_info(
-        reserve: Optional[Any],
-        ring_type: Optional[Any],
-    ) -> Optional[str]:
-        reserve_text = reserve.strip() if isinstance(reserve, str) else None
-        ring_text = ring_type.strip() if isinstance(ring_type, str) else None
-        parts = [value for value in (reserve_text, ring_text) if value]
-        if not parts:
-            return None
-        return " ".join(parts)
-
-    def send_test_message(self) -> None:
-        url = (self._state.discord_webhook_url or "").strip()
-        if not url:
-            raise ValueError("Discord webhook URL is not configured")
-        payload = build_test_message(self._state)
-        self._dispatch_webhook(
-            url,
-            payload,
-            thread_name="EDMCMA-DiscordTest",
-            success_message="Discord webhook test message sent successfully",
-            failure_message="Discord webhook test message failed",
-        )
-
-    @staticmethod
-    def _ensure_aware(value: datetime) -> datetime:
-        if value.tzinfo is None:
-            return value.replace(tzinfo=timezone.utc)
-        return value.astimezone(timezone.utc)
-
-    @staticmethod
-    def _isoformat(value: datetime) -> str:
-        return value.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")
-
-    def _format_name(self, value: str) -> str:
-        return resolve_commodity_display_name(self._state, value)
-
-    @staticmethod
-    def _safe_sum(values: Iterable[int]) -> int:
-        total = 0
-        for value in values:
-            try:
-                total += int(value)
-            except (TypeError, ValueError):
-                continue
-        return total
-
-    @staticmethod
-    def _compute_rate(total: int, elapsed_seconds: Optional[float]) -> Optional[float]:
-        if total <= 0 or not elapsed_seconds or elapsed_seconds <= 0:
-            return None
-        hours = elapsed_seconds / 3600.0
-        if hours <= 0:
-            return None
-        return total / hours
diff --git a/state.py b/state.py
deleted file mode 100644
index b04cef8..0000000
--- a/state.py
+++ /dev/null
@@ -1,240 +0,0 @@
-"""Dataclasses that encapsulate runtime state for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-from collections import Counter, defaultdict, deque
-from dataclasses import dataclass, field
-from datetime import datetime, timedelta, timezone
-from pathlib import Path
-from typing import Deque, Dict, Iterable, List, Optional, Set, Tuple
-
-
-ProspectKey = Tuple[str, Tuple[Tuple[str, float], ...]]
-
-
-@dataclass
-class InaraSettings:
-    """User-configurable settings that influence Inara lookups."""
-
-    search_mode: int = 1  # 1=Best price, 3=Distance
-    include_carriers: bool = True
-    include_surface: bool = True
-
-
-@dataclass
-class MiningState:
-    """Represents the mutable mining session state shared across subsystems."""
-
-    plugin_dir: Optional[Path] = None
-    is_mining: bool = False
-    mining_start: Optional[datetime] = None
-    mining_end: Optional[datetime] = None
-    mining_location: Optional[str] = None
-    mining_ring: Optional[str] = None
-    current_system: Optional[str] = None
-    current_ship: Optional[str] = None
-    current_ship_key: Optional[str] = None
-    cmdr_name: Optional[str] = None
-
-    prospected_count: int = 0
-    already_mined_count: int = 0
-    duplicate_prospected: int = 0
-
-    cargo_additions: Dict[str, int] = field(default_factory=dict)
-    cargo_totals: Dict[str, int] = field(default_factory=dict)
-    commodity_display_names: Dict[str, str] = field(default_factory=dict)
-    harvested_commodities: Set[str] = field(default_factory=set)
-    commodity_start_times: Dict[str, datetime] = field(default_factory=dict)
-
-    limpets_remaining: Optional[int] = None
-    limpets_start: Optional[int] = None
-    limpets_start_initialized: bool = False
-    collection_drones_launched: int = 0
-    prospector_launched_count: int = 0
-    abandoned_limpets: int = 0
-    last_event_was_drone_launch: bool = False
-
-    prospect_content_counts: Counter[str] = field(default_factory=Counter)
-    materials_collected: Counter[str] = field(default_factory=Counter)
-    last_cargo_counts: Dict[str, int] = field(default_factory=dict)
-
-    histogram_bin_size: int = 10
-    rate_interval_seconds: int = 30
-    session_logging_enabled: bool = False
-    session_log_retention: int = 30
-
-    prospected_seen: Set[ProspectKey] = field(default_factory=set)
-    prospected_samples: Dict[str, List[float]] = field(default_factory=lambda: defaultdict(list))
-    prospected_histogram: Dict[str, Counter[int]] = field(default_factory=lambda: defaultdict(Counter))
-
-    inara_settings: InaraSettings = field(default_factory=InaraSettings)
-    cargo_capacity: Optional[int] = None
-    cargo_capacity_is_inferred: bool = False
-    current_cargo_tonnage: int = 0
-    inferred_capacity_map: Dict[str, int] = field(default_factory=dict)
-    is_paused: bool = False
-    auto_unpause_on_event: bool = True
-    discord_webhook_url: str = ""
-    send_summary_to_discord: bool = False
-    send_reset_summary: bool = False
-    last_session_summary: Optional[str] = None
-    discord_images: List[tuple[str, str]] = field(default_factory=list)
-    discord_image_cycle: Dict[str, int] = field(default_factory=dict)
-    show_mined_commodities: bool = True
-    show_materials_collected: bool = True
-    warn_on_non_metallic_ring: bool = False
-
-    refinement_lookback_seconds: int = 10
-    rpm_threshold_red: int = 1
-    rpm_threshold_yellow: int = 20
-    rpm_threshold_green: int = 40
-    recent_refinements: Deque[datetime] = field(default_factory=deque)
-    current_rpm: float = 0.0
-    max_rpm: float = 0.0
-
-    edsm_reserve_level: Optional[str] = None
-    edsm_ring_type: Optional[str] = None
-    edsm_body_name: Optional[str] = None
-    overlay_enabled: bool = False
-    overlay_anchor_x: int = 40
-    overlay_anchor_y: int = 120
-    overlay_available: bool = False
-    rpm_display_color: str = "#ffffff"
-    overlay_refresh_interval_ms: int = 1000
-    spansh_last_distance_min: Optional[float] = None
-    spansh_last_distance_max: Optional[float] = None
-    spansh_last_ring_signals: Optional[List[str]] = None
-    spansh_last_reserve_levels: Optional[List[str]] = None
-    spansh_last_ring_types: Optional[List[str]] = None
-    spansh_last_min_hotspots: Optional[int] = None
-
-
-def compute_percentage_stats(samples: Iterable[float]) -> Optional[Tuple[float, float, float]]:
-    """Return min/avg/max percentages from an iterable of sample values."""
-
-    cleaned: List[float] = []
-    for sample in samples:
-        try:
-            cleaned.append(float(sample))
-        except (TypeError, ValueError):
-            continue
-    if not cleaned:
-        return None
-    min_val = min(cleaned)
-    max_val = max(cleaned)
-    avg_val = sum(cleaned) / len(cleaned)
-    return min_val, avg_val, max_val
-
-
-def reset_mining_state(state: MiningState) -> None:
-    """Reset mutable mining metrics for a fresh session."""
-
-    state.is_mining = False
-    state.mining_start = None
-    state.mining_end = None
-    state.mining_location = None
-    state.mining_ring = None
-
-    state.prospected_count = 0
-    state.already_mined_count = 0
-    state.duplicate_prospected = 0
-
-    state.cargo_additions.clear()
-    state.cargo_totals.clear()
-    state.commodity_display_names.clear()
-    state.harvested_commodities.clear()
-    state.commodity_start_times.clear()
-
-    state.limpets_remaining = None
-    state.limpets_start = 0
-    state.limpets_start_initialized = False
-    state.collection_drones_launched = 0
-    state.prospector_launched_count = 0
-    state.abandoned_limpets = 0
-    state.last_event_was_drone_launch = False
-
-    state.prospect_content_counts.clear()
-    state.materials_collected.clear()
-    state.last_cargo_counts.clear()
-
-    state.prospected_seen.clear()
-    state.prospected_samples.clear()
-    state.prospected_histogram.clear()
-    state.current_cargo_tonnage = 0
-    state.current_ship = None
-    state.current_ship_key = None
-    state.cargo_capacity_is_inferred = False
-    state.is_paused = False
-    state.recent_refinements.clear()
-    state.current_rpm = 0.0
-    state.max_rpm = 0.0
-    state.rpm_display_color = "#ffffff"
-    state.overlay_refresh_interval_ms = 1000
-
-
-def resolve_commodity_display_name(state: MiningState, commodity: str) -> str:
-    """Return the preferred display name for a commodity."""
-
-    key = str(commodity or "").lower()
-    display = state.commodity_display_names.get(key)
-    if display:
-        return display
-    text = str(commodity or "")
-    return text.replace("_", " ").title()
-
-
-def recompute_histograms(state: MiningState) -> None:
-    """Recompute prospecting histograms based on collected samples."""
-
-    histogram: Dict[str, Counter[int]] = defaultdict(Counter)
-    size = max(1, state.histogram_bin_size)
-    for material, samples in state.prospected_samples.items():
-        if not samples:
-            continue
-        counter = histogram[material]
-        for value in samples:
-            try:
-                clamped = max(0.0, min(float(value), 100.0))
-            except (TypeError, ValueError):
-                continue
-            if clamped >= 100.0:
-                clamped = 100.0 - 1e-9
-            bin_index = int(clamped // size)
-            counter[bin_index] += 1
-    state.prospected_histogram = histogram
-
-
-def register_refinement(state: MiningState, timestamp: datetime) -> None:
-    """Record a mining refinement event and refresh RPM metrics."""
-
-    aware_time = _ensure_aware(timestamp)
-    state.recent_refinements.append(aware_time)
-    update_rpm(state, aware_time)
-
-
-def update_rpm(state: MiningState, now: Optional[datetime] = None) -> float:
-    """Recalculate current and max RPM based on recent refinements."""
-
-    if now is None:
-        now = datetime.now(timezone.utc)
-    aware_now = _ensure_aware(now)
-
-    window = max(1, int(state.refinement_lookback_seconds or 1))
-    cutoff = aware_now - timedelta(seconds=window)
-
-    refinements = state.recent_refinements
-    while refinements and refinements[0] < cutoff:
-        refinements.popleft()
-
-    count = len(refinements)
-    rpm = (count * 60.0) / window if window else 0.0
-    state.current_rpm = rpm
-    if rpm > state.max_rpm:
-        state.max_rpm = rpm
-    return rpm
-
-
-def _ensure_aware(value: datetime) -> datetime:
-    if value.tzinfo is None:
-        return value.replace(tzinfo=timezone.utc)
-    return value.astimezone(timezone.utc)
diff --git a/tests/__init__.py b/tests/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/tests/data/sample_journal.jsonl b/tests/data/sample_journal.jsonl
deleted file mode 100644
index 865bb84..0000000
--- a/tests/data/sample_journal.jsonl
+++ /dev/null
@@ -1,9 +0,0 @@
-{"timestamp":"3300-01-01T12:00:00Z","event":"LoadGame","Commander":"TestCMDR","Ship":"Krait_MkII","Ship_Localised":"Krait Mk II","GameMode":"Open"}
-{"timestamp":"3300-01-01T12:00:05Z","event":"Location","Docked":false,"StarSystem":"Test System","Body":"Test Body","BodyType":"Planet"}
-{"timestamp":"3300-01-01T12:01:00Z","event":"LaunchDrone","Type":"Prospector"}
-{"timestamp":"3300-01-01T12:01:05Z","event":"Cargo","Inventory":[{"Name":"Platinum","Name_Localised":"Platinum","Count":0},{"Name":"Gold","Name_Localised":"Gold","Count":0},{"Name":"Drones","Name_Localised":"Limpet","Count":50}],"Count":50}
-{"timestamp":"3300-01-01T12:01:20Z","event":"ProspectedAsteroid","Body":"Test Body A Ring","Content":"High","Materials":[{"Name":"Platinum","Name_Localised":"Platinum","Proportion":28.5},{"Name":"Gold","Name_Localised":"Gold","Proportion":14.2}]}
-{"timestamp":"3300-01-01T12:01:30Z","event":"MaterialCollected","Name":"iron","Count":3}
-{"timestamp":"3300-01-01T12:01:35Z","event":"MaterialCollected","Name":"carbon","Count":6}
-{"timestamp":"3300-01-01T12:01:40Z","event":"MaterialCollected","Name":"nickel","Count":9}
-{"timestamp":"3300-01-01T12:02:00Z","event":"Cargo","Inventory":[{"Name":"Platinum","Name_Localised":"Platinum","Count":5},{"Name":"Gold","Name_Localised":"Gold","Count":3},{"Name":"Drones","Name_Localised":"Limpet","Count":48}],"Count":56}
diff --git a/tests/test_journal_simulation.py b/tests/test_journal_simulation.py
deleted file mode 100644
index 8198824..0000000
--- a/tests/test_journal_simulation.py
+++ /dev/null
@@ -1,144 +0,0 @@
-import json
-import unittest
-from datetime import datetime, timedelta
-from pathlib import Path
-
-from journal import JournalProcessor
-from state import MiningState
-
-
-class JournalSimulationTest(unittest.TestCase):
-    def setUp(self) -> None:
-        self.state = MiningState()
-        self._session_started = False
-        self._session_ended = False
-        self._refresh_calls = 0
-
-        self.processor = JournalProcessor(
-            self.state,
-            refresh_ui=self._refresh_ui,
-            on_session_start=self._on_session_start,
-            on_session_end=self._on_session_end,
-            persist_inferred_capacities=lambda: None,
-            notify_mining_activity=lambda _reason: None,
-            session_recorder=None,
-            edsm_client=None,
-        )
-
-    def _refresh_ui(self) -> None:
-        self._refresh_calls += 1
-
-    def _on_session_start(self) -> None:
-        self._session_started = True
-
-    def _on_session_end(self) -> None:
-        self._session_ended = True
-
-    def _timestamp(self, offset_seconds: int) -> str:
-        base = datetime(3300, 1, 1, 12, 0, 0)
-        return (base + timedelta(seconds=offset_seconds)).strftime("%Y-%m-%dT%H:%M:%SZ")
-
-    def _cargo_event(self, timestamp: str, *, platinum: int, gold: int, limpets: int = 50) -> dict:
-        inventory = [
-            {"Name": "Platinum", "Name_Localised": "Platinum", "Count": platinum},
-            {"Name": "Gold", "Name_Localised": "Gold", "Count": gold},
-            {"Name": "Drones", "Name_Localised": "Limpet", "Count": limpets},
-        ]
-        return {
-            "event": "Cargo",
-            "timestamp": timestamp,
-            "Inventory": inventory,
-            "Count": platinum + gold + limpets,
-        }
-
-    def test_full_prospect_and_material_flow(self) -> None:
-        launch_ts = self._timestamp(0)
-        self.processor.handle_entry({
-            "event": "LaunchDrone",
-            "Type": "Prospector",
-            "timestamp": launch_ts,
-        })
-
-        self.assertTrue(self._session_started)
-        self.assertTrue(self.state.is_mining)
-        self.assertEqual(self.state.prospector_launched_count, 1)
-
-        baseline_ts = self._timestamp(10)
-        self.processor.handle_entry(self._cargo_event(baseline_ts, platinum=0, gold=0))
-
-        prospect_ts = self._timestamp(20)
-        self.processor.handle_entry({
-            "event": "ProspectedAsteroid",
-            "timestamp": prospect_ts,
-            "Body": "Test Ring",
-            "Content": "High",
-            "Materials": [
-                {"Name": "Platinum", "Name_Localised": "Platinum", "Proportion": 28.5},
-                {"Name": "Gold", "Name_Localised": "Gold", "Proportion": 14.2},
-            ],
-            "Remaining": 100.0,
-        })
-
-        self.assertEqual(self.state.prospected_count, 1)
-        self.assertEqual(self.state.prospect_content_counts.get("High"), 1)
-        self.assertIn("platinum", self.state.prospected_samples)
-        self.assertIn("gold", self.state.prospected_samples)
-
-        cargo_ts = self._timestamp(40)
-        self.processor.handle_entry(self._cargo_event(cargo_ts, platinum=5, gold=3))
-
-        self.assertEqual(self.state.cargo_additions.get("platinum"), 5)
-        self.assertEqual(self.state.cargo_additions.get("gold"), 3)
-
-        material_events = [
-            ("iron", 3),
-            ("carbon", 6),
-            ("nickel", 9),
-        ]
-        for idx, (name, count) in enumerate(material_events, start=1):
-            self.processor.handle_entry({
-                "event": "MaterialCollected",
-                "timestamp": self._timestamp(60 + idx),
-                "Name": name,
-                "Count": count,
-            })
-
-        self.assertEqual(self.state.materials_collected.get("iron"), 3)
-        self.assertEqual(self.state.materials_collected.get("carbon"), 6)
-        self.assertEqual(self.state.materials_collected.get("nickel"), 9)
-
-        platinum_samples = self.state.prospected_samples.get("platinum")
-        gold_samples = self.state.prospected_samples.get("gold")
-        self.assertIsNotNone(platinum_samples)
-        self.assertIsNotNone(gold_samples)
-        self.assertIn(28.5, [float(f"{value:.1f}") for value in platinum_samples])
-        self.assertIn(14.2, [float(f"{value:.1f}") for value in gold_samples])
-
-        self.assertGreater(self._refresh_calls, 0)
-
-    def test_replay_sample_journal(self) -> None:
-        """Replay a captured journal slice to mirror EDMC runtime behaviour."""
-
-        journal_path = Path(__file__).resolve().parent / "data" / "sample_journal.jsonl"
-        self.assertTrue(journal_path.exists(), "Sample journal file missing")
-
-        with journal_path.open("r", encoding="utf-8") as handle:
-            for line in handle:
-                payload = json.loads(line.strip())
-                self.processor.handle_entry(payload, shared_state=None)
-
-        # Expectations after replaying the sample:
-        self.assertTrue(self._session_started)
-        self.assertTrue(self.state.is_mining)
-        self.assertEqual(self.state.prospector_launched_count, 1)
-        self.assertEqual(self.state.prospected_count, 1)
-        self.assertEqual(self.state.prospect_content_counts.get("High"), 1)
-        self.assertEqual(self.state.cargo_additions.get("platinum"), 5)
-        self.assertEqual(self.state.cargo_additions.get("gold"), 3)
-        self.assertEqual(self.state.materials_collected.get("iron"), 3)
-        self.assertEqual(self.state.materials_collected.get("carbon"), 6)
-        self.assertEqual(self.state.materials_collected.get("nickel"), 9)
-
-
-if __name__ == "__main__":
-    unittest.main()
diff --git a/tooltip.py b/tooltip.py
deleted file mode 100644
index 26af21f..0000000
--- a/tooltip.py
+++ /dev/null
@@ -1,237 +0,0 @@
-"""UI utility helpers for EDMC Mining Analytics."""
-
-from __future__ import annotations
-
-from typing import Callable, Optional, Tuple
-
-try:
-    import tkinter as tk
-    from tkinter import ttk
-except ImportError as exc:  # pragma: no cover
-    raise RuntimeError("Tkinter must be available for EDMC plugins") from exc
-
-
-class TreeTooltip:
-    """Simple tooltip helper for Treeview widgets."""
-
-    def __init__(self, tree: ttk.Treeview) -> None:
-        self._tree = tree
-        self._tip: Optional[tk.Toplevel] = None
-        self._cell_texts: dict[Tuple[str, str], str] = {}
-        self._heading_texts: dict[str, str] = {}
-        self._current_key: Optional[Tuple[str, str]] = None
-
-        tree.bind("<Motion>", self._on_motion, add="+")
-        tree.bind("<Leave>", self._hide_tip, add="+")
-        tree.bind("<ButtonPress>", self._hide_tip, add="+")
-
-    def clear(self) -> None:
-        self._cell_texts.clear()
-        self._current_key = None
-        self._hide_tip()
-
-    def set_heading_tooltip(self, column_name: str, text: Optional[str]) -> None:
-        try:
-            columns = tuple(self._tree.cget("columns"))
-        except tk.TclError:
-            return
-        try:
-            idx = columns.index(column_name)
-        except ValueError:
-            return
-        col_id = f"#{idx + 1}"
-        if text:
-            self._heading_texts[col_id] = text
-        else:
-            self._heading_texts.pop(col_id, None)
-
-    def set_cell_text(self, item: str, column: str, text: Optional[str]) -> None:
-        key = (item, column)
-        if text:
-            self._cell_texts[key] = text
-        elif key in self._cell_texts:
-            del self._cell_texts[key]
-        if self._current_key == key and not text:
-            self._hide_tip()
-
-    def _on_motion(self, event: tk.Event) -> None:  # type: ignore[override]
-        region = self._tree.identify_region(event.x, event.y)
-        column = self._tree.identify_column(event.x)
-
-        if region == "heading":
-            key = ("", column or "")
-            if key == self._current_key:
-                return
-            self._hide_tip()
-            heading_text = self._heading_texts.get(column)
-            if heading_text:
-                self._current_key = key
-                x = event.x_root + 16
-                y = event.y_root + 12
-                self._show_tip(x, y, heading_text)
-            return
-
-        item = self._tree.identify_row(event.y)
-        key = (item or "", column or "")
-        if key == self._current_key:
-            return
-        self._hide_tip()
-        if not item or key not in self._cell_texts:
-            return
-        self._current_key = key
-        x = event.x_root + 16
-        y = event.y_root + 12
-        self._show_tip(x, y, self._cell_texts[key])
-
-    def _show_tip(self, x: int, y: int, text: str) -> None:
-        try:
-            tip = tk.Toplevel(self._tree)
-        except tk.TclError:
-            return
-        tip.wm_overrideredirect(True)
-        tip.wm_geometry(f"+{x}+{y}")
-        try:
-            style = ttk.Style(self._tree)
-        except tk.TclError:
-            tip.destroy()
-            return
-        try:
-            tree_background = self._tree.cget("background")
-        except tk.TclError:
-            tree_background = None
-        bg = (
-            style.lookup("TLabel", "background")
-            or style.lookup("TFrame", "background")
-            or tree_background
-            or "#ffffe0"
-        )
-        fg = style.lookup("TLabel", "foreground") or "#000000"
-        label = tk.Label(
-            tip,
-            text=text,
-            background=bg,
-            foreground=fg,
-            relief="solid",
-            borderwidth=1,
-            justify="left",
-        )
-        label.pack(ipadx=4, ipady=2)
-        self._tip = tip
-
-    def _hide_tip(self, *_: object) -> None:
-        if self._tip is not None:
-            self._tip.destroy()
-            self._tip = None
-        self._current_key = None
-
-
-class WidgetTooltip:
-    """Tooltip helper for standard Tk widgets."""
-
-    def __init__(self, widget: tk.Widget, text: Optional[str] = None, *, hover_predicate: Optional[Callable[[int, int], bool]] = None) -> None:
-        self._widget = widget
-        self._text: Optional[str] = text
-        self._tip: Optional[tk.Toplevel] = None
-        self._label: Optional[tk.Label] = None
-        self._hover_predicate = hover_predicate
-
-        widget.bind("<Enter>", self._on_enter, add="+")
-        widget.bind("<Leave>", self._on_leave, add="+")
-        widget.bind("<Motion>", self._on_motion, add="+")
-
-    def set_text(self, text: Optional[str]) -> None:
-        self._text = text or None
-        if not self._text:
-            self._hide()
-        elif self._label is not None:
-            try:
-                self._label.configure(text=self._text)
-            except tk.TclError:
-                self._hide()
-
-    def _on_enter(self, event: tk.Event) -> None:  # type: ignore[override]
-        self._maybe_show(event)
-
-    def _on_motion(self, event: tk.Event) -> None:  # type: ignore[override]
-        self._maybe_show(event)
-
-    def _on_leave(self, _event: tk.Event) -> None:  # type: ignore[override]
-        self._hide()
-
-    def _show(self, x: int, y: int) -> None:
-        text = self._text
-        if not text:
-            return
-        if self._tip is None:
-            try:
-                tip = tk.Toplevel(self._widget)
-            except tk.TclError:
-                return
-            tip.wm_overrideredirect(True)
-            try:
-                tip.wm_attributes("-topmost", True)
-            except Exception:
-                pass
-            fg, bg = self._resolve_colors()
-            label = tk.Label(
-                tip,
-                text=text,
-                justify="left",
-                background=bg,
-                foreground=fg,
-                relief=tk.SOLID,
-                borderwidth=1,
-                padx=6,
-                pady=4,
-                wraplength=320,
-            )
-            label.pack()
-            self._tip = tip
-            self._label = label
-        else:
-            try:
-                if self._label is not None:
-                    self._label.configure(text=text)
-            except tk.TclError:
-                self._hide()
-                return
-        self._position(x, y)
-
-    def _maybe_show(self, event: tk.Event) -> None:
-        if not self._text:
-            return
-        if self._hover_predicate and not self._hover_predicate(int(event.x), int(event.y)):
-            self._hide()
-            return
-        self._show(event.x_root + 12, event.y_root + 12)
-
-    def _position(self, x: int, y: int) -> None:
-        if self._tip is None:
-            return
-        try:
-            self._tip.wm_geometry(f"+{x}+{y}")
-        except tk.TclError:
-            self._hide()
-
-    def _hide(self) -> None:
-        if self._tip is not None:
-            try:
-                self._tip.destroy()
-            except tk.TclError:
-                pass
-        self._tip = None
-        self._label = None
-
-    def _resolve_colors(self) -> Tuple[str, str]:
-        try:
-            style = ttk.Style(self._widget)
-        except tk.TclError:
-            style = ttk.Style()
-        bg = (
-            style.lookup("TLabel", "background")
-            or style.lookup("TFrame", "background")
-            or self._widget.cget("background")
-            or "#ffffe0"
-        )
-        fg = style.lookup("TLabel", "foreground") or "#000000"
-        return fg, bg
diff --git a/update_manager.py b/update_manager.py
deleted file mode 100644
index 5be47f5..0000000
--- a/update_manager.py
+++ /dev/null
@@ -1,261 +0,0 @@
-"""Auto-update helper for the EDMC Mining Analytics plugin."""
-
-from __future__ import annotations
-
-import errno
-import shutil
-import threading
-from datetime import datetime
-from pathlib import Path
-from typing import Callable, Optional
-from zipfile import ZIP_DEFLATED, ZipFile
-
-import requests
-
-from logging_utils import get_logger
-from edmc_mining_analytics_version import PLUGIN_VERSION, is_newer_version
-from http_client import get_shared_session
-
-BACKUP_COUNT = 3
-DATETIME_FORMAT = "%Y-%m-%d-%H-%M-%S"
-DISABLE_FILE = "disable-auto-update.txt"
-DOWNLOAD_FILENAME = "latest.zip"
-RELEASES_URL = "https://api.github.com/repos/SweetJonnySauce/EDMC-Mining-Analytics/releases/latest"
-PACKAGE_ROOT_NAME = "EDMC-Mining-Analytics"
-
-
-class UpdateManager:
-    """Handles automatic update checks and installation."""
-
-    def __init__(
-        self,
-        plugin_dir: Path,
-        on_update_ready: Optional[Callable[[str], None]] = None,
-        session: Optional[requests.Session] = None,
-    ) -> None:
-        self._log = get_logger("update")
-        self._plugin_dir = plugin_dir
-        self._updates_dir = self._plugin_dir / "updates"
-        self._backups_dir = self._plugin_dir / "backups"
-        self._download_path = self._updates_dir / DOWNLOAD_FILENAME
-        self._thread: Optional[threading.Thread] = None
-        self._on_update_ready = on_update_ready
-        self._stop_event = threading.Event()
-        self._session = session or get_shared_session()
-
-    def start(self) -> None:
-        """Kick off the update check on a background thread."""
-
-        if not self._plugin_dir:
-            return
-
-        if (self._plugin_dir / DISABLE_FILE).exists():
-            self._log.info("Auto-update disabled via %s", DISABLE_FILE)
-            return
-
-        try:
-            self._updates_dir.mkdir(parents=True, exist_ok=True)
-            self._backups_dir.mkdir(parents=True, exist_ok=True)
-        except OSError as exc:
-            if exc.errno != errno.EEXIST:
-                self._log.warning("Unable to prepare update folders", exc_info=exc)
-                return
-
-        if self._thread and self._thread.is_alive():
-            self._log.debug("Auto-update check already running")
-            return
-
-        self._stop_event.clear()
-        self._thread = threading.Thread(
-            target=self._run_update_check,
-            name="EDMC Mining Auto Update",
-            daemon=False,
-        )
-        self._thread.start()
-
-    def stop(self, *, join: bool = True, timeout: Optional[float] = 5.0) -> None:
-        """Signal the update worker to stop and optionally wait for completion."""
-
-        self._stop_event.set()
-        thread = self._thread
-        if join and thread and thread.is_alive():
-            thread.join(timeout=timeout)
-            if thread.is_alive():
-                self._log.debug("Auto-update worker still running after stop timeout")
-        self._thread = None
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _run_update_check(self) -> None:
-        try:
-            if self._stop_event.is_set():
-                return
-
-            release = self._session.get(RELEASES_URL, timeout=10)
-            release.raise_for_status()
-        except requests.RequestException as exc:
-            self._log.debug("Unable to fetch release metadata: %s", exc)
-            self._stop_event.set()
-            return
-
-        try:
-            if self._stop_event.is_set():
-                return
-
-            try:
-                data = release.json()
-            except ValueError:
-                self._log.debug("Latest release metadata response was not valid JSON")
-                return
-            tag = str(data.get("tag_name", "")).strip()
-            if not tag:
-                return
-
-            remote_version = tag.lstrip("vV")
-            if not is_newer_version(remote_version, PLUGIN_VERSION):
-                if is_newer_version(PLUGIN_VERSION, remote_version):
-                    self._log.debug(
-                        "Current version %s is ahead of GitHub release %s",
-                        PLUGIN_VERSION,
-                        remote_version,
-                    )
-                else:
-                    self._log.debug("Current version %s is up to date", PLUGIN_VERSION)
-                return
-
-            assets = data.get("assets") or []
-            download_url = None
-            for asset in assets:
-                if self._stop_event.is_set():
-                    return
-                url = asset.get("browser_download_url")
-                if url:
-                    download_url = url
-                    break
-            if not download_url:
-                self._log.debug("No downloadable asset found in latest release")
-                return
-
-            self._log.info("New version %s available (current %s)", remote_version, PLUGIN_VERSION)
-
-            if not self._download_asset(download_url):
-                return
-
-            if self._stop_event.is_set():
-                return
-
-            if not self._create_backup():
-                return
-
-            if self._stop_event.is_set():
-                return
-
-            self._prune_backups()
-            if self._stop_event.is_set():
-                return
-
-            if not self._install_update(remote_version):
-                return
-
-            if self._on_update_ready and not self._stop_event.is_set():
-                try:
-                    self._on_update_ready(remote_version)
-                except Exception:
-                    self._log.debug("Update ready callback failed", exc_info=True)
-        finally:
-            self._stop_event.set()
-
-    def _download_asset(self, url: str) -> bool:
-        if self._stop_event.is_set():
-            return False
-        try:
-            with self._session.get(url, stream=True, timeout=30) as response:
-                response.raise_for_status()
-                with self._download_path.open("wb") as handle:
-                    for chunk in response.iter_content(chunk_size=65536):
-                        if self._stop_event.is_set():
-                            return False
-                        if chunk:
-                            handle.write(chunk)
-        except requests.RequestException as exc:
-            self._log.warning("Failed to download new release", exc_info=exc)
-            return False
-        return True
-
-    def _create_backup(self) -> bool:
-        if self._stop_event.is_set():
-            return False
-        timestamp = datetime.now().strftime(DATETIME_FORMAT)
-        backup_path = self._backups_dir / f"{timestamp}.zip"
-
-        try:
-            with ZipFile(backup_path, "w", compression=ZIP_DEFLATED) as archive:
-                for path in self._plugin_dir.rglob("*"):
-                    if self._stop_event.is_set():
-                        return False
-                    if path.is_dir():
-                        continue
-                    relative = path.relative_to(self._plugin_dir)
-                    # Skip update artefacts and backups themselves
-                    if relative.parts[0] in {"updates", "backups"}:
-                        continue
-                    if relative.name.startswith(".") or relative.suffix in {".pyc", ".pyo"}:
-                        continue
-                    archive.write(path, arcname=str(relative))
-        except Exception as exc:
-            self._log.warning("Failed to create backup", exc_info=exc)
-            return False
-        return True
-
-    def _prune_backups(self) -> None:
-        backups = sorted(self._backups_dir.glob("*.zip"), key=lambda p: p.stat().st_ctime)
-        for old_backup in backups[:-BACKUP_COUNT]:
-            if self._stop_event.is_set():
-                return
-            try:
-                old_backup.unlink()
-            except Exception:
-                self._log.debug("Unable to remove backup %s", old_backup, exc_info=True)
-
-    def _install_update(self, remote_version: str) -> bool:
-        if self._stop_event.is_set():
-            return False
-        if not self._download_path.exists():
-            self._log.debug("Downloaded update archive missing")
-            return False
-
-        extract_root = self._updates_dir / "extracted"
-        if extract_root.exists():
-            shutil.rmtree(extract_root, ignore_errors=True)
-
-        try:
-            with ZipFile(self._download_path, "r") as archive:
-                archive.extractall(extract_root)
-                if self._stop_event.is_set():
-                    return False
-        except Exception as exc:
-            self._log.warning("Failed to extract update archive", exc_info=exc)
-            return False
-
-        candidate = extract_root / PACKAGE_ROOT_NAME
-        source_dir = candidate if candidate.exists() else extract_root
-
-        for src in source_dir.rglob("*"):
-            if self._stop_event.is_set():
-                return False
-            if src.is_dir():
-                continue
-            relative = src.relative_to(source_dir)
-            target = self._plugin_dir / relative
-            target.parent.mkdir(parents=True, exist_ok=True)
-            try:
-                shutil.copy2(src, target)
-            except Exception as exc:
-                self._log.warning("Failed to copy %s", relative, exc_info=exc)
-
-        self._log.info(
-            "Auto-update installed for version %s. Changes will take effect next restart.",
-            remote_version,
-        )
-        return True
diff --git a/version.py b/version.py
deleted file mode 100644
index 99b4039..0000000
--- a/version.py
+++ /dev/null
@@ -1,45 +0,0 @@
-"""Centralized plugin metadata and version helpers."""
-
-from __future__ import annotations
-
-import re
-from typing import Iterable, Tuple
-
-
-PLUGIN_VERSION = "0.4.8"
-PLUGIN_REPO_URL = "https://github.com/SweetJonnySauce/EDMC-Mining-Analytics"
-
-
-def display_version(value: str) -> str:
-    """Return a version string prefixed with ``v`` if missing."""
-
-    value = value.strip()
-    return value if value.lower().startswith("v") else f"v{value}"
-
-
-def normalize_version(value: str) -> str:
-    """Strip a leading ``v``/``V`` and whitespace from a version string."""
-
-    return value.strip().lstrip("vV")
-
-
-def _version_key(value: str) -> Tuple[Tuple[int, object], ...]:
-    """Convert a version string into a sortable key."""
-
-    normalized = normalize_version(value)
-    if not normalized:
-        return ((0, 0),)
-    parts = re.split(r"[._-]", normalized)
-    key: list[Tuple[int, object]] = []
-    for part in parts:
-        if part.isdigit():
-            key.append((0, int(part)))
-        else:
-            key.append((1, part.lower()))
-    return tuple(key)
-
-
-def is_newer_version(latest: str, current: str) -> bool:
-    """Return True if ``latest`` is a higher semantic value than ``current``."""
-
-    return _version_key(latest) > _version_key(current)
